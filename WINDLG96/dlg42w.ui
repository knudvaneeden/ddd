/****************************************************************************

 The SemWare Editor Professional V4.2 - Standard User Interface

 Copyright 1991-2003 SemWare Corporation.  All Rights Reserved Worldwide.

 This program gives The SemWare Editor its standard user interface,
 including user preferences, certain built-in commands, menus, help, and key
 assignments.

 If you want to use a config file rather than ICONFIG for user preferences,
 include the following file:

    tse.cfg     - user preferences file

 ***************************************************************************/

/****************************************************************************
 This file has been changed, as compared to the original TSE.UI, so that
 it utilizes the new dialog boxes provided by the Dialog macro package.

 changed WhenLoaded (accesses the new dialogs now)
        basic logic didn't change

 renamed mCompressView to mShowFunctions
        normal compress now calls "DlgFind -v"
        mShowFunctions is mCompressView with normal compress removed

 assigned the new dialogs to various keys and menu entries
        search 'ExecMacro("dlg' to find these lines

 added two menu entries to the Util menu to call the todo manager

 added some backup key assignments, to be used in keyboard macros
        <CtrlShift f>           Find()
        <CtrlShift r>           Replace()
        <CtrlShift c>           GotoLine()
        <CtrlShift j>           GotoColumn()
        <CtrlShift x>           ExecMacro()

 removed internal recent files list (mListRecentFiles)

 removed "File|Change Name..."
        since the new "File|SaveAs..." command is essentially
        a combination of ChangeCurrFilename() and SaveFile()

 removed internal Ascii-Chart (mAsciiChart)

 removed global variables compress_hist & compress_option_hist
        don't need them anymore (same history is accessed by DlgFind)


 DiK 03-05-05   WindDlgs v0.96
 ***************************************************************************/

//#include ["tse.cfg"]      // config-endconfig definitions

/*****************************************************************************
 General .ui changes:

 Dec 1996   - display "e32 filename" as the window title

 Nov 1996   - filemanager (f.s) can retain last viewed dir if called with -r
              switch.  Change all calls to filemanager here to take advantage
              of this.

 Sep 10, 1997 SEM
        - add java support
        - fix problem with state macro and quitting, in whenloaded

 Jan 27, 1998 SEM
        - add java specific function list
        - fix conflict with shifting a marked block left/right and cuamark

 Jun  1, 1998 SEM
        - add asm specific function list
        - updated basic function ident regx
        - add "Empty Clipboard" item to the Clipboard menu
        - add "New File" and "Change Dir" to the filemenu.

 Oct 21, 1998 KSW
        - pass the short filename to the macro language debugger, since
          it does not properly handle long filenames

 Mar-Dec, 1999 SEM
        - Set Window Title to "filename - TSE Pro-32"
        - Make Shell and Dos commands to prompts
        - Add BrowseMode awareness to menus
        - Add Cleanup Recent Files function
        - Add ChDir command to File menu
        - Add CutToWinClip to menus, <ctrlshift grey->
        - Add Undo/Redo to menus, <alt backspace>, <altshift backspace>
        - Fix mShift interaction with CUAMark
        - Fix problem with TemplateExpansion variable
        - Fix problems with State and StartUp Menu
        - Fix SAL indenting in mCReturn, specifically, function procedures.

 July, 2000 SEM
        - Improve Java function list regular expression, thanks to Howard Kapustein
        - Improve startup logic when restoring state, thanks to Ross Boyd
        - Moved the loading of startup macros before the window size is set,
          so that startup macros can set the initial window size.

 March, 2001 SEM
        - Add ".dpr" as an alternate pascal extension, thanks to Christer Gustafsson
        - Add ".vbs" and ".pl" as language types for smart indenting, thanks to Bill Stewart
        - Add 'select' and 'with' as language keywords to indent on, thanks to Bill Stewart
        - Add python support, thanks to Howard Kapustein.

 Nov 12, 2001 SEM
        - in FindPara, string s was declared too small to hold some of the
          longer strings returned via GetFunctionStr().  Thanks to John Kopp for
          spotting this.
 Feb 21, 2002 SEM
        - Add help line to certain prompts in OnPromptStartup().  Thanks to
          Bruce Riggins for the idea.
 Mar 29, 2002 SEM
        - Updated Java Function definition, thanks to Alexander F. Gutfeldt.
        - Updated basic extensions and basic function string, thanks to
          Howard Kapustein.
        - Added Tex support, thanks to Sjoerd Rienstra.
 Apr 29, 2002 SEM
        - Updated Basic Function definition, thanks to Alexander F. Gutfeldt.

 May 28, 2002 SEM
        - Use "TSE Pro" for GUI and "TSE Pro-32" for Console titles.
        - <Alt> MainMenu added in win.ui
        - Add "try", "catch", and "finally" to keyword list (Guy Rouillier)
        - Move options on util menu to option menu (Michael Graham)
        - Rearrange the menu bar order (Michael Graham)

 Mar 11, 2003 SEM
        - Add "Compile Menu" to the Macro menu, and to the
          Macro Quick menu.

 October 2003
        - Added C# support, thanks to Greg Macdonald.

 November 2003 SEM
        - new keywords added to indent list
        - fix to recent files list scrolling problem, thanks to Shane
          Brinkman-Davis for the report.
        - EditThisFile() used in lieu of EditFile() to more easily handle
          filenames containing embedded spaces.
        - Added Windows-like shift-left-btn behavior.  Thanks to Greg
          Macdonald for the suggestion.
        - F10 in file prompts brings up a picklist.
        - shift-del, ctrl-ins, shift-ins added to all .ui files
        - new twokey menu-helper display
 *****************************************************************************/

constant MAXPATH = 255
string CONSOLE[] = "CONIN$"

dll "<kernel32.dll>"
    integer proc GetShortPathName(string inpath:cstrval, var string outpath:strptr, integer len) : "GetShortPathNameA"
end

/**************************************************************************
  GetShortPathName only works for existing path's..., so create inpath if
  it does not already exist.
 **************************************************************************/
string proc mGetShortPathname(string inpath)
    integer h, len
    string short_path[MAXPATH] = Format("":MAXPATH:Chr(0))

    h = iif(FileExists(inpath), -1, fCreate(inpath))
    len = GetShortPathName(inpath, short_path, MAXPATH)
    if h <> -1
        fClose(h)
        EraseDiskFile(inpath)
    endif
    return (iif(len > 0, short_path[1:Pos(Chr(0), short_path) - 1], inpath))
end

/****************************************************************************
  Some definitions / notes

  Macros used as commands (that are assigned to keys or menus sequences)
  are prefixed with lower case "m" to distinguish them from built-in
  commands, e.g., mDelChar() is a macro, DelChar() is a builtin command.

  Current character - The character at the cursor position in the
  currently edited file.  Where the next typed character will be
  inserted or replaced.
 ***************************************************************************/

// Global variables - assumes globals initialized to 0.

integer cmode               // (internal) used to invoke C-mode
integer sal                 // (internal) used to recognize sal
integer language            // (internal) used to invoke language package
integer sort_flags          // (internal) used for Sorting

integer recent_files        // (internal) id of the recent_files
integer save_wordwrap       // (internal) used in toggling wordwrap mode
integer save_autoindent     // (internal) used in toggling autoindent mode

string KeyWords[] = " case catch do else elseif finally for if loop otherwise proc repeat select switch try when while with "

string asm_fun[]    = "[a-zA-Z0-9] +{proc}"
string basic_fun[]  = "^{{friend}|{private}|{public}[ \t]+}?{function}|{sub}|{property}[ \t]"

string bat_fun[]    = "^[\t ]*:"
string c_fun[]      = "^_@[a-zA-Z][a-zA-Z0-9_* \t]@([~;]*$"
// Note that c++ allows a few extra characters in function names.
string cpp_fun[]    = "^{extern[ \t]+\x22C\x22[ \t]+}?_|~@[a-zA-Z:][a-zA-Z0-9_+\-*/%^&|~!=<>,\[\] \t:~]@([~;]*$"
string ini_fun[] = "^[ \t]*\[.*\][ \t]*$"
string java_fun[]   = "{private}|{protected}|{public}|{void}[ \t]+_@[a-zA-Z][\.a-zA-Z0-9_*@{\[\]}? \t]@([~;]*$"

string pas_fun[]    = "^ *{procedure}|{function} +[a-zA-Z_]"
string python_fun[] = "^[ \t]*{class}|{def} "
string sal_fun[]    = "^{menu}|{{public #}?{{integer #}|{string #}}@proc} +[a-zA-Z_]"
string tex_fun[]    = "^\\{chapter}|{{subsub}|{sub}|{}section}|{{sub}|{}paragraph}"
string xbase_fun[]  = "^{static }?{{procedure}|{function}} +[a-zA-Z_]"

string ident_set[]  = "[_a-zA-Z]"
string TEMPLATE[]   = "template"
string TSEPro_title[20]

/****************************************************************************
  A simple language indenting package, providing the following:

  When AutoIndent is on,

  BackSpace, when the cursor is on a blank line or the first
  non-blank character of a line, issues  TabLeft(), in
  effect doing an outdent.

  Return, causes an extra indent when the first word of the line
  is one of the following:

  if else elseif while repeat loop for switch case when

  Additionally, special handling of {} is provided for C
  programmers.

  To make this package work:

  Assign mBackSpace() to <backspace>
  Assign mCReturn() to <Enter>          // special handling for C
  Assign  TabLeft() to <shift tab>
  Assign mCloseBrace() to <shift ]>      // For C files

  The _ON_CHANGING_FILES_ hook sets this mode (language) for files with
  extensions of s, c, and h.
  cmode is also set for files with extensions of c and h.

 ***************************************************************************/

/****************************************************************************
  Fancy backspace() command.
  Sort of like Borlands environment.  In language mode, backspace
  does a "outdent" when there is only white space before the cursor.

  Also does special handling for overwrite mode.  In overwrite mode,
  does a "rubout" instead of a backspace.
 ***************************************************************************/
proc mBackSpace()
    if CurrPos() == 1       // at beg-of-line, just join to previous
        if PrevChar()
            JoinLine()
        endif
        return ()
    endif

    // if from here to prev-tabstop is white space, then TabLeft()
    if Query(AutoIndent) and language
        if CurrPos() <= PosFirstNonWhite()
            TabLeft()
            return ()
        endif
        PushPosition()
        GotoColumn(CurrCol() - DistanceToTab())
        if CurrPos() > PosLastNonWhite()
            PopPosition()
            TabLeft()
            return ()
        endif
        PopPosition()
    endif

    // Finally, do either rubout or backspace based on InsertMode
    if Query(Insert) or CurrPos() == CurrLineLen() + 1
        BackSpace()
    else
        Left()
        InsertText(" ", _OVERWRITE_)
        Left()
    endif
end

/****************************************************************************
   Return the first word on the line as string - '' if not there.
 ***************************************************************************/
string proc GetFirstWord()
    string first_word[32] = ''

    PushPosition()                  // Save where we're at
    GotoPos(PosFirstNonWhite())     // Go to first non white
    first_word = Lower(GetWord())   // Now get the word there
    PopPosition()                   // Restore saved position
    return (' ' + first_word + ' ') // And return the word
end

/****************************************************************************
  Fancy CarriageReturn command.  Works if language mode is on.

  11-05-93 SEM Handle SmartTabs
 ***************************************************************************/
integer proc mCReturn()
    integer ok, save_tabtype, should_indent = FALSE
    string first_word[32]

    if language and CurrPos() > PosFirstNonWhite()
        first_word = Lower(GetFirstWord())
        should_indent = Pos(first_word, KeyWords) or
            (cmode and (Pos('{', GetText(1, CurrPos())) or GetText(PosFirstNonWhite(), 6) == "} else")) or
            (sal and (first_word in " string ", " integer ") and GetText(Length(first_word), 5) == "proc ")

        if cmode and should_indent
            if GetText(CurrLineLen(), 1) == ';'
                should_indent = FALSE
            endif
        endif
    endif

    if not CReturn()
        return (FALSE)
    endif

    ok = TRUE
    if should_indent and ((Query(Insert) and Query(ReturnEqNextLine) == FALSE) or PosFirstNonWhite() == 0)
        save_tabtype = Query(TabType)
        if save_tabtype in _SMART_, _VARIABLE_
            Set(TabType, _SOFT_)                // force fixed tabs
        endif
        ok = TabRight()
        Set(TabType, save_tabtype)              // restore tabtype
    endif
    return (ok)
end

/****************************************************************************
  Special handling of } for C programmers
 ***************************************************************************/
proc mCloseBrace()
    if cmode and PosFirstNonWhite() == 0
        TabLeft()
    endif
    SelfInsert()
end

/****************************************************************************
  Helper macros/Subroutines

  These routines are:

  o not intended for use as commands by themselves
  o not intended to be assigned to keys or menus
  o intended to be called from other macros
 ***************************************************************************/

/****************************************************************************
   Returns the string "On" or "Off" based on the logical value of i.

   Used by menus to display on/off strings.
 ***************************************************************************/
string proc OnOffStr(integer i)
    return (iif(i, "On", "Off"))
end

/****************************************************************************
   Helper routines for Sort on the Options menu.

   Return the appropriate string.
 ***************************************************************************/
string proc ShowSortFlag()
    return (iif(sort_flags & _DESCENDING_, "Descending", "Ascending"))
end

/****************************************************************************
   Helper routines for Sort on the Options menu.

   Toggle the sort order or case significance.
 ***************************************************************************/
proc ToggleSortFlag(integer which)
    if sort_flags & which
        sort_flags = sort_flags & ~ which
    else
        sort_flags = sort_flags | which
    endif
end

/****************************************************************************
   Read command that returns the numeric value of the user input.
 ***************************************************************************/
integer proc ReadNum(integer n)
    string s[5] = str(n)

    return (iif(ReadNumeric(s), val(s), n))
end ReadNum

integer proc CutCopyMenuFlags()
    return (iif(IsBlockInCurrFile() or Query(UseCurrLineIfNoBlock), _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_))
end

integer proc PasteMenuFlags()
    return (iif(GetClipBoardBlockType() and not BrowseMode(), _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_))
end

integer proc EmptyClipboardMenuFlags()
    return (iif(GetClipBoardBlockType(), _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_))
end

integer proc WinClipMenuFlags()
    return (iif(isWinClipAvailable(), _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_))
end

integer proc BrowseModeMenuFlags()
    return (iif(BrowseMode(), _MF_GRAYED_, _MF_CLOSE_ALL_BEFORE_))
end

integer proc BlockMenuFlags()
    return (iif(IsBlockMarked(), _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_))
end

integer proc AtEOLMenuFlags()
    return (iif(CurrPos() <= CurrLineLen(), _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_))
end

integer proc WindowMenuFlags()
    return (iif(NumWindows() > 1, _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_))
end

integer proc NumFilesMenuFlags()
    return (iif(NumFiles() > 1, _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_))
end

integer proc MoreLinesFlags()
    return (iif(CurrLine() < NumLines(), _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_))
end

integer proc GUIMenuFlags()
    return (iif(isGUI(), _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_))
end

integer proc OEMMenuFlags()
    string fontname[32] = ""
    integer pointsize, flags

    GetFont(fontname, pointsize, flags)
    return (iif(not isGUI() or (flags & _FONT_OEM_), _MF_DONT_CLOSE_, _MF_GRAYED_))
end

///////////////////// End Help Macros/Subroutines ///////////////////////

/****************************************************************************
  Macros that follow can:

  o be assigned to keys and menus as commands
  o therefore, can be directly executed by the user

  Commands implemented in the macro langauge:

    mAsciiChart
    mBegPara
    mCapital
    mCloseBrace
    mCloseFileAndWindow
    mCompileCurrFile
    mCompressView
    mCopyCharAbove
    mCopyCharAboveToEol
    mDateTimeStamp
    mDebugCurrFile
    mEmptyClipboard
    mEndPara
    mFindWordAtCursor
    mHelpOnWordAtCursor
    mLeftBtn
    mListRecentFiles
    mMarkPara
    mNextPara
    mOpenFileAndWindow
    mPrevPara
    mRightBtn
    mShift [ShiftBlock]
    mSwapLines

  Commands augmented via macros:

    mBackSpace
    mBegFile
    mCloseWindow
    mCReturn
    mDelChar()
    mEndFile
    mFlip()
    mLower()
    mSaveSettings
    mTabLeft
    mTabRight
    mToggleAutoIndent
    mToggleWordWrap
    mUpper()
 ***************************************************************************/

proc mEmptyClipboard()
    EmptyBuffer(Query(ClipboardId))
end

/****************************************************************************
  The GetPrev command.

  Copy the character on the line above to the current position
 ***************************************************************************/
integer proc mCopyCharAbove()
    integer c, sv = Set(RemoveTrailingWhite, OFF)

    PushPosition()                  // save position
    c = iif(up(), CurrChar(), -1)   // Try for char on line above
    PopPosition()                   // back to where we were
    Set(RemoveTrailingWhite, sv)
    return (c >= 0 and InsertText(Chr(c)))
end mCopyCharAbove

/****************************************************************************
  The GetPrevToEOL command.

  Copy the character on the line above to the current position, and keep
  copying until the eol is reached (on the line above)
 ***************************************************************************/
proc mCopyCharAboveToEol()
    repeat
    until not mCopyCharAbove()
end

constant SHIFTLEFT = -1, SHIFTRIGHT = 1

/****************************************************************************
  Shift text left/right

  If in a block, shift the entire block.

   11-05-93 SEM Handle WordStar-style line blocks better
 ***************************************************************************/
integer proc mShiftBlock(integer direction)
    integer goal_line = CurrLine(),
            btype     = isCursorInBlock(),
            save_marking   = Set(Marking, off),
            p = CurrPos()

    PushPosition()
    if btype or (isBlockInCurrFile() and CurrLine() >= Query(BlockBegLine)
            and CurrLine() <= Query(BlockEndLine))
        goal_line = Query(BlockEndLine)
        GotoBlockBegin()
    endif
    repeat until not ShiftText(direction)
            or   not RollDown()
            or   CurrLine() > goal_line
    PopPosition()
    GotoPos(p)
    Set(Marking, save_marking)
    return (TRUE)
end

/****************************************************************************
  The standard Shift command.

  Shift text left/right based on the keys pressed.
 ***************************************************************************/
proc mShift()
    integer marking

    marking = Set(Marking, off)
    loop
        Message("<Left>,<Right> or <Tab>,<Shift Tab> to shift text; <Enter> when done")
        case GetKey(_EQUATE_ENHANCED_KBD_)
            when <CursorLeft>
                mShiftBlock(-1)
            when <CursorRight>
                mShiftBlock(1)
            when <Tab>
                mShiftBlock(Query(TabWidth))
            when <Shift Tab>
                mShiftBlock(-Query(TabWidth))
            when <Escape>, <Enter>, <Alt x>
                break
            when <Alt U>
                if isCursorInBlock()
                    UnMarkBlock()
                    break
                endif
        endcase
        UpdateDisplay(_REFRESH_THIS_ONLY_ | _WINDOW_REFRESH_)
    endloop

    Set(Marking, marking)

    UpdateDisplay()
end

/****************************************************************************
  Search for the word at the cursor, using the value of FindOptions
 ***************************************************************************/
integer proc mFindWordAtCursor(string option)
    if Length(GetWord(1))
        AddHistoryStr(GetWord(1), _FINDHISTORY_)
        return (Find(GetWord(1), Query(FindOptions) + option))
    endif
    ExecMacro("dlgfind")
    return (TRUE)
end mFindWordAtCursor

/****************************************************************************
  Helper routine, called by FunctionList and the next/prev/Beg/End paragraph
  movement routines.

  This function returns a regular expression that can be used to find
  functions in the current source file.

  We depend on CurrExt() returning a lower-cased extension.
 ***************************************************************************/
string proc GetFunctionStr()
    case CurrExt()
        when ".asm"
            return (asm_fun)
        when ".bas", ".cls", ".frm", ".pbi", ".pbs", ".bi", ".pb3", ".vbs"
            return (basic_fun)
        when ".bat", ".btm", ".cmd", ".kix"
            return (bat_fun)
        when ".c"
            return (c_fun)
        when ".cpp", ".cc", ".h", ".hpp"
            return (cpp_fun)
        when ".ini", ".inf"
            return (ini_fun)
        when ".py"
            return (python_fun)
        when ".cs", ".java"         // for C#, use Java for now
            return (java_fun)
        when ".s", ".ui", ".si", ".inc"
            return (sal_fun)
        when ".pas", ".pp", ".dpr"
            return (pas_fun)
        when ".prg",".spr",".mpr",".qpr",".fmt",".frg",".lbg",".ch"
            return (xbase_fun)
        when ".tex"
            return (tex_fun)
    endcase
    return ("")
end

/************************************************************************
  The CompressView command.

  If called with a non-zero value, becomes the FunctionList command.
 ************************************************************************/

proc mShowFunctions()
    string expression[100]

    expression = GetFunctionStr()
    if Length(expression) == 0
        expression = "^[a-zA-Z_]"
    endif
    if not lFind(expression, 'ixv')
        Warn(expression, " not found.")
    endif
end

integer proc FindPreviousBlankLine()
    repeat
        if not Up()
            return (FALSE)
        endif
    until PosFirstNonWhite() == 0
    return (TRUE)
end

integer proc FindPreviousNonBlankLine()
    repeat
        if not Up()
            return (FALSE)
        endif
    until PosFirstNonWhite()
    return (TRUE)
end

integer proc FindNextBlankLine()
    repeat
        if not Down()
            return (FALSE)
        endif
    until PosFirstNonWhite() == 0
    return (TRUE)
end

integer proc FindNextNonBlankLine()
    repeat
        if not Down()
            return (FALSE)
        endif
    until PosFirstNonWhite()
    return (TRUE)
end

integer proc FindPara(integer previous)
    integer col = CurrCol(), cline = CurrLine()
    string opt[1], s[255] = GetFunctionStr()

    if Length(s)
        if previous
            BegLine()
            opt = 'b'
        else
            EndLine()
            opt = ''
        endif
        lFind(s, "ix+" + opt)
    else    // unknown type, use line delimited chunks
        PushPosition()
        if previous
            Up()
            repeat until PosFirstNonWhite() or not Up()
            repeat until not Up() or PosFirstNonWhite() == 0
            if PosFirstNonWhite() == 0
                Down()
            endif
            if PosFirstNonWhite()
                KillPosition()
            else
                PopPosition()
            endif
        else
            if (PosFirstNonWhite() == 0 or FindNextBlankLine())
                    and FindNextNonBlankLine()
                KillPosition()
            else
                PopPosition()
            endif
        endif
    endif
    GotoColumn(col)
    return (CurrLine() <> cline)
end

integer proc mPrevPara()
    return (FindPara(TRUE))
end

integer proc mNextPara()
    return (FindPara(FALSE))
end

proc mBegPara()
    integer cline, pline

    cline = CurrLine()
    mPrevPara()
    pline = CurrLine()
    mNextPara()
    if cline <> CurrLine()
        GotoLine(pline)
    endif
end

proc mEndPara()
    integer cline = CurrLine()

    if mNextPara()
        FindPreviousBlankLine()
        FindPreviousNonBlankLine()
    else
        EndFile()
        repeat until CurrLine() <= cline or PosFirstNonWhite() or not Up()
    endif
end

proc mMarkPara()
    PushPosition()
    Unmarkblock()
    mBegPara()
    MarkLine()
    mEndPara()
    MarkLine()
    PopPosition()
end

//********* List Recent Files helper and command routines *******************

string proc RecentFilesStr()
    return (LoadDir() + "tsefiles.dat")
end

// Create the recent files buffer, if needed
// BOOL Return
integer proc GotoRecentFilesBuffer()
    if CreateBuffer("*Recent Files List*", _SYSTEM_, recent_files, _FORCE_NAME_)
        BinaryMode(-1)
        if NumLines() == 0 and Query(PersistentRecentFiles)
            LoadBuffer(RecentFilesStr(), -1)
        endif
    endif
    return (recent_files)
end

/****************************************************************************
  Swap the current line with the next line.
 ***************************************************************************/
proc mSwapLines()
    integer km, y = CurrRow()

    if Down()
        km = Set(KillMax, 1)
        DelLine()
        Up()
        UnDelete()
        Set(KillMax, km)
        ScrollToRow(y)
    endif
end

proc mCloseWindow()
    if NumWindows() > 1
        CloseWindow()
    else
        Exit()
    endif
end

proc mCompileCurrFile()
    ExecMacro("Compile " + QuotePath(CurrFilename()))
end

proc mCompileMenu()
    ExecMacro("Compile -m")
end

/**************************************************************************
  Since the macro debugger can't handle filenames with spaces, we need to
  pass it the short name if spaces in the name, and we need to save it
  if changed.
 **************************************************************************/
proc mDebugCurrFile()          // KSW changed
    string fn[MAXPATH]

    fn = CurrFilename()
    if Pos(' ', fn)
        if (FileChanged() or not FileExists(CurrFilename())) and not SaveFile()
            Warn("Error saving ", CurrFilename())
            return ()
        endif
        fn = mGetShortPathname(CurrFilename())
    endif
    ExecMacro("debug " + fn)
end

/*************************************************************************
   External macro support.
 *************************************************************************/
menu ExecLoadPurge()
    Title = "Macro Menu"
    Width = 16

    "&Execute..."   , ExecMacro("dlgmcc")
    "&Load..."      , ExecMacro("dlgopen -l")
    "&Purge..."     , ExecMacro("dlgmcc")
    "&Compile"      , mCompileCurrFile()
    "Compile &Menu" , mCompileMenu()
    "&Debug..."     , mDebugCurrFile()
end

proc mDateTimeStamp()
    InsertText(GetDateStr(), _INSERT_)
    InsertText(" ", _INSERT_)
    InsertText(GetTimeStr(), _INSERT_)
end

proc mOpenFileAndWindow()
    if EditThisFile()
        PrevFile()
        HWindow()
    endif
end

proc mCloseFileAndWindow()
    if QuitFile()
        CloseWindow()
    endif
end

proc mLeftBtn()
    if not ProcessHotSpot()
       MainMenu()
    endif
end

forward menu MouseMenu()
proc mRightBtn()
    if WaitForMouseEvent(_MOUSE_HOLD_TIME_|_MOUSE_RELEASE_|_MOUSE_MOVE_) == _MOUSE_RELEASE_
        MouseMenu()
    else
        MouseMarking(_COLUMN_)
    endif
end

proc mTrackMouseCursor()
    if GotoMouseCursor()
        TrackMouseCursor()
    endif
end

proc mShiftLeftBtn()
    integer blocktype = isCursorInBlock()
    if blocktype == 0
        blocktype = _NONINCLUSIVE_
        UnMarkBlock()
        MarkChar()
    endif
    mTrackMouseCursor()
    Mark(blocktype)
end

/****************************************************************************
  Commands augmented by macros:
 ***************************************************************************/

// Augment delchar by joining lines if at or passed eol
integer proc mDelChar()
    return(iif(CurrChar() >= 0, DelChar(), JoinLine()))
end

// Augment BegFile by maintaining the current column if a column block is open
proc mBegFile()
    integer col = CurrCol(), xoff = CurrXoffset()

    BegFile()
    if Query(Marking) and isBlockInCurrFile() == _COLUMN_
        GotoColumn(col)
        GotoXoffset(xoff)
    endif
end

// Augment EndFile by maintaining the current column if a column block is open
proc mEndFile()
    integer col = CurrCol(), xoff = CurrXoffset()

    EndFile()
    if Query(Marking) and isBlockInCurrFile() == _COLUMN_
        GotoColumn(col)
        GotoXoffset(xoff)
    endif
end

constant WORDCASE  = 1, LINECASE = 2, BLOCKCASE = 3
constant UPPER_CASE = 0, LOWER_CASE = 1, FLIP_CASE = 2, CAP_CASE = 3

integer casetype

// Assume type is always one of WORDCASE, LINECASE or BLOCKCASE.
proc ChangeCase(integer type)
    PushBlock()
    if type <> BLOCKCASE
        UnMarkBlock()
        if type == LINECASE
            MarkLine()
        elseif not MarkWord()
            goto done
        endif
    elseif not isCursorInBlock()
        goto done
    endif
    case casetype
        when UPPER_CASE
            Upper()
        when LOWER_CASE
            Lower()
        when FLIP_CASE
            Flip()
        otherwise
            ExecMacro("capital")
    endcase
    done:

    PopBlock()
end

menu CaseMenu()
    Command = ChangeCase(MenuOption())

    "&Word at Cursor"   ,,BrowseModeMenuFlags() // if the order of these options is changed,
    "Current &Line"     ,,BrowseModeMenuFlags() // Change to order of the constants
    "&Block"            ,,BrowseModeMenuFlags() | BlockMenuFlags()      // WORDCASE, LINECASE, and BLOCKCASE
end

proc mUpper()
    casetype = UPPER_CASE
    CaseMenu("Upper Case")
end

proc mLower()
    casetype = LOWER_CASE
    CaseMenu("Lower Case")
end

proc mFlip()
    casetype = FLIP_CASE
    CaseMenu("Flip Case")
end

proc mCapital()
    casetype = CAP_CASE
    CaseMenu("Capitalize")
end

integer proc mSaveSettings()
    if YesNo("Overwrite existing config?") == 1
        return (iif(SaveSettings(), TRUE, Warn("Error updating executable")))
    endif
    return (FALSE)
end

proc mHelpOnWordAtCursor()
    string cur_word[64]

    cur_word = Trim(GetText(CurrPos(), sizeof(cur_word)))
    PushPosition()
    if isWord() or lFind(ident_set, "xcb") or lFind(ident_set, "xc+")
        cur_word = GetWord(TRUE)
    endif
    PopPosition()
    Help(cur_word, TRUE)
end

proc mLoadTemplate()
    if not isMacroLoaded(TEMPLATE)
        LoadMacro(TEMPLATE)
    endif
end

integer proc mQueryTemplate()
    if Query(TemplateExpansion)
        mLoadTemplate()
        return (TRUE)
    endif
    return (FALSE)
end

proc mToggleTemplateExpand()
    Toggle(TemplateExpansion)
    mQueryTemplate()
end

proc ToggleHexEdit()
    if HexEdit(TRUE)
        HexEdit(FALSE)
    endif
end

proc mTabRight()
    if DisplayMode() == _DISPLAY_HEX_
        ToggleHexEdit()
    elseif Query(TabShiftsBlock) and isCursorInBlock() and Query(Insert)
        mShiftBlock(Query(TabWidth))
    else
        TabRight()
    endif
end

proc mTabLeft()
    if Query(TabShiftsBlock) and isCursorInBlock() and Query(Insert)
        mShiftBlock(-Query(TabWidth))
    else
        TabLeft()
    endif
end

proc mToggleAutoIndent()
    if Query(AutoIndent)
        save_autoindent = Set(AutoIndent, OFF)
    else
        if save_autoindent == OFF
            save_autoindent = ON
        endif
        Set(AutoIndent, save_autoindent)
    endif
end

proc mToggleWordWrap()
    if Query(WordWrap)
        save_wordwrap = Set(WordWrap, OFF)
    else
        if save_wordwrap == OFF
            save_wordwrap = ON
        endif
        Set(WordWrap, save_wordwrap)
    endif
end

proc AddToTop(string s, integer max_count)
    if lFind(s, "^$ig")
        KillLine()
    elseif NumLines() >= max_count
        EndFile()
        KillLine()
    endif
    BegFile()
    InsertLine(s)
end

/****************************************************************************
  TSE-called macros, including:

  WhenLoaded
  Main
  Hooked functions
 ***************************************************************************/
// This is a hooked macro
// Be careful not to add files without names!
// 04/19/96 SEM ignore case of files for WIN32
proc AfterUpdateDisplay()
    string fn[MAXPATH] = CurrFilename()
    integer cid = GetBufferId()
    Unhook(AfterUpdateDisplay)
    SetWindowTitle(SplitPath(fn, _NAME_|_EXT_) + " - " + TSEPro_title)
    if Length(fn) and BufferType() == _NORMAL_
        if GotoRecentFilesBuffer()
            AddToTop(fn, Query(MaxRecentFiles))
        endif
        GotoBufferId(cid)
    endif
end

/****************************************************************************
  This macro is called everytime EditFile() or Next/PrevFile() is called.

  This is a hooked macro.

  We depend on CurrExt() returning a lower-cased extension.
 ***************************************************************************/
proc OnChangingFiles()
    // For 'RecentFiles' processing, only show files that are displayed
    Hook(_AFTER_UPDATE_DISPLAY_, AFterUpdateDisplay)
    language = FALSE
    cmode = FALSE
    sal = FALSE
    case CurrExt()
        when ".ui", ".s", ".si", ".inc"
            language = TRUE
            sal = TRUE
        when ".c", ".h", ".cpp", ".cc", ".hpp", ".cs", ".java"
            language = TRUE
            cmode = TRUE
        when ".asm", ".pas", ".pp", ".dpr", ".prg", ".bas", ".vbs", ".pl", ".py"
            language = TRUE
    endcase
end

integer proc isEditFilePrompt()
    return (Query(CurrHistoryList) in _EDIT_HISTORY_, _NEWNAME_HISTORY_)
end

proc mPromptPickFile()
    string reply[255]

    if isEditFilePrompt()
        reply = GetText(1, CurrLineLen())
        if Pos('*', reply) == 0
            case RightStr(reply, 1)
                when '\', ':'
                    reply = reply + "*.*"
                otherwise
                    reply = "*.*"
            endcase
        endif
        BegLine()
        KillToEOL()
        InsertText(reply)
        PushKey(<enter>)
    endif
end

/**************************************************************************
  Additional keys active during prompt boxes.
 **************************************************************************/

proc AsciiChart()
    PushPosition()
    ExecMacro("dlgascii -x")
    PopPosition()
    PushKeyStr(Query(MacroCmdLine))
end

keydef AdditionalKeys
    <Ctrl A>    AsciiChart()
//    <Ctrl 0>    if isEditFilePrompt() mPromptRecentFiles() endif
    <f9>        Shell()
    <Alt f9>    Dos()
    <f10>       mPromptPickFile()
end

// This is a hooked macro
proc OnPromptStartup()
    Enable(AdditionalKeys)
    // show available keys

    case Query(CurrHistoryList)
        when _EDIT_HISTORY_, _NEWNAME_HISTORY_
            WindowFooter("{F10}-PickFile {Tab}-Complete {Ctrl 0}-Recent Files {F9}-Shell {Alt-F9}-OS Cmd")
        when _EXECMACRO_HISTORY_, _LOADMACRO_HISTORY_, _KEYMACRO_HISTORY_
            WindowFooter("{F9}-Shell {AltF9}-DOS")
        when _FIND_HISTORY_, _REPLACE_HISTORY_, _FILLBLOCK_HISTORY_
            WindowFooter("{Ctrl A}-Ascii Chart {F9}-Shell {AltF9}-OS Cmd")
/**************************************************************************
        _GOTOLINE_HISTORY_
        _GOTOCOLUMN_HISTORY_
        _REPEATCMD_HISTORY_
        _DOS_HISTORY_
        _FINDOPTIONS_HISTORY_
        _REPLACEOPTIONS_HISTORY_
 **************************************************************************/
    endcase
end

/****************************************************************************
  This macro is called the first time a file is loaded into the editor.

  This is a hooked macro
 ***************************************************************************/
proc OnFirstEdit()
end

// This is a hooked macro
proc MaybeAutoWrap()
    integer line

    if Query(WordWrap) > ON
        line = CurrLine()
        PushPosition()
        EndLine()
        if Abs(CurrCol() - Query(RightMargin)) > 1
            WrapPara()
        endif
        PopPosition()
        GotoXoffset(0)
        if line <> CurrLine() and CurrLine() < Query(WindowRows) / 2
            ScrollUp()
        endif
    endif
end

// called on delchar/bs/drw/dlw
// This is a hooked macro
proc OnDelChar()
    MaybeAutoWrap()
end

// Called on each char insert.
// This is a hooked macro
proc OnSelfInsert()
    if Query(WordWrap) == ON and CurrCol() > Query(RightMargin) + 1
        WrapLine()
    else
        MaybeAutoWrap()
    endif
end

// This macro is automatically called by TSE just before the _ON_ABANDON_EDITOR_
// hook is called.
proc WhenPurged()
    PushPosition()
    if Query(PersistentRecentFiles) and GotoBufferId(recent_files) and NumLines()
        SaveAs(RecentFilesStr(), _OVERWRITE_ | _DONT_PROMPT_)
    endif
    PopPosition()
end

/****************************************************************************
  This macro is automatically called by TSE just after the editor has
  initialized all necessary processes and managers.

  Minimally, this macro should call EditFile() if the command line is empty,
  or EditFile(Query(DosCmdLine)) if the command line is non-empty.

  Many additional 'startup' tasks should be performed here.

  The following are performed in this version:

  - The initial video mode is set
  - The signon screen is displayed
  - TSEStart is executed
  - The autoload macros are loaded
  - Various events are hooked
  - If the output of a command has been piped to us, load it as a file
  - Process the DOS command line, by calling EditFile
  - If the DOS command line is empty, use the StartupFlags editor variable
    to determine what to do
 ***************************************************************************/
menu StartupMenu()
    history
    nokeys

    "&Open...",         ExecMacro("dlgopen")
    "&New File",        NewFile()
    "&File Manager...", ExecMacro("f -r")
    "List &Recent...",  ExecMacro("dlgrcnt")
    "&Pick File...",    ExecMacro("dlgopen")
    "Restore &State",   ExecMacro("state -r -q")
    "&Where",           ExecMacro("where")
    "E&xit",            AbandonEditor()
end

proc WhenLoaded()
    string s[MAXPATH]
    integer new_handle
    integer rows, cols, changed

    TSEPro_title = iif(isGUI(), "TSE Pro", "TSE Pro-32")
    SetWindowTitle(TSEPro_title)
    LoadStartupMacros()                         // tsestart and autoload macros
    Set(CurrVideoMode, Query(StartupVideoMode))
    if Query(StartupVideoMode) == _AUTODETECT_
        // if rows/cols < 25/80, force video mode
        changed = FALSE
        rows = Query(ScreenRows)
        cols = Query(ScreenCols)
        if rows < 25
            rows = 25
            changed = TRUE
        endif
        if cols < 80
            cols = 80
            changed = TRUE
        endif
        if changed
            SetVideoRowsCols(rows, cols)
        endif
    endif

    if Query(TemplateExpansion)
        mLoadTemplate()
    endif

    // Hook the events we want to get control of
    Hook(_ON_CHANGING_FILES_,   OnChangingFiles)
    Hook(_ON_FIRST_EDIT_,       OnFirstEdit)
    Hook(_PROMPT_STARTUP_,      OnPromptStartup)
    Hook(_ON_SELFINSERT_,       OnSelfInsert)
    Hook(_ON_DELCHAR_,          OnDelChar)

    // See if input is redirected, if so, read it in as a file
    if isCharDevice(_STDIN_) == FALSE and CreateBuffer("")
        fReadFile(_STDIN_)
        BegFile()
        ChangeCurrFilename("[<stdin>]", _DONT_EXPAND_)      // call ON_FIRST_EDIT and ON_CHANGING_FILES hooks

        new_handle = fOpen(CONSOLE, _OPEN_READWRITE_)
        if new_handle <> -1
            fDup2(new_handle, _STDIN_)
            fClose(new_handle)
        endif
    endif

    // Finally, process the command line
    s = Query(DosCmdLine)
    if Length(s)
        AddHistoryStr(s, _EDIT_HISTORY_)
        SignOn()
        if StartedFromDOSPrompt()
            EditFile(s, _FROM_CMDLINE_)
        else
            EditThisFile(s, _FROM_CMDLINE_)
        endif
    elseif NumFiles() == 0
        case Query(StartupFlags)
            when _STARTUP_RESTORESTATE_
                case Query(SaveState)
                    when _LOCAL_
                        ExecMacro("state -r -q -l")
                    when _ON_
                        ExecMacro("state -r -q -g")
                    otherwise
                        ExecMacro("state -r -q")
                endcase
            when _STARTUP_FILEMGR_
                loop
                    ExecMacro("f -r")
                    if NumFiles()
                        Process(1)
                    else
                        return ()
                    endif
                endloop
                return ()
            when _STARTUP_UNNAMED_
                NewFile()
                return ()
            when _STARTUP_RECENTFILES_
                ExecMacro("dlgrcnt")
            when _STARTUP_PICKLIST_
                EditFile("-a- *.*")
            when _STARTUP_MENU_
                loop
                    SetWindowTitle(TSEPro_title)
                    lShowEntryScreen()
                    SignOn()

                    Set(X1, (Query(ScreenCols) / 2) - 9)
                    case Query(ScreenRows)
                        when 10..22     Set(y1, Query(ScreenRows) - 9)
                        when 23         Set(y1, 14)
                        when 24         Set(y1, 15)
                        when 25..10000  Set(y1, 16)
                    endcase
                    StartupMenu()
                    if MenuOption() == 0
                        if not (Query(key) in <LeftBtn>, <RightBtn>)
                            return ()
                        endif
                    endif

                    if NumFiles()
                        if NumWindows() < 2 and not isZoomed()
                            OneWindow()
                        endif
                        Process(1)
                    endif
                    OneWindow()
                endloop
        endcase
    endif

    // _STARTUP_PROMPT_ case and error loading specified file cases come here
    if NumFiles() == 0
        SignOn()
        ExecMacro("dlgopen")
    endif
end

/****************************************************************************
  TSE Pull-down Menus
 ***************************************************************************/

menu FileMenu()
    history

    "Ne&w"                          ,   NewFile()
    "&Open..."                      ,   ExecMacro("dlgopen")
    "&Insert..."                    ,   ExecMacro("dlgopen -i"),BrowseModeMenuFlags()
    "&File Manager..."              ,   ExecMacro("f -r")
    "Change &Dir..."                ,   ExecMacro("dlgbrows -c -g")
    ""                              ,                       ,   Divide
    "&Next"                         ,   NextFile()          ,   NumFilesMenuFlags()
    "&Previous"                     ,   PrevFile()          ,   NumFilesMenuFlags()
    "Lis&t Open..."                 ,   ExecMacro("dlgbuff")
    "List &Recent..."               ,   ExecMacro("dlgrcnt")
    "Current File"                  ,                       ,   Divide
    "&Save"                         ,   SaveFile()          ,   BrowseModeMenuFlags()
    "Save &As..."                   ,   ExecMacro("dlgopen -s")
    "Save && C&lose"                ,   SaveAndQuitFile()   ,   BrowseModeMenuFlags()
    "&Close"                        ,   QuitFile()
    "S&how File Info"               ,   ExecMacro("fileinfo")
    "All Files"                     ,                       ,   Divide
    "Sa&ve All"                     ,   SaveAllFiles()
    "Save All && &Exit"             ,   SaveAllAndExit()
    "E&xit"                         ,   Exit()
end

/**************************************************************************
  Notes:
  Extra spaces on "Cu&t" line to make the menu look less crowded. Chr(255)
  is used to distinguish (for the online help) the same-named menu items
  from each other.
 **************************************************************************/
menu ClipMenu()
    history

    "Cu&t"+"                     "  ,   Cut()               , BrowseModeMenuFlags() | CutCopyMenuFlags()
    "Cut &Append"                   ,   CutAppend()         , BrowseModeMenuFlags() | CutCopyMenuFlags()
    "&Copy"                         ,   Copy()              , CutCopyMenuFlags()
    "Copy App&end"                  ,   CopyAppend()        , CutCopyMenuFlags()
    "&Paste"                        ,   Paste()             , BrowseModeMenuFlags() | PasteMenuFlags()
    "Paste O&ver"                   ,   Paste(_OVERWRITE_)  , BrowseModeMenuFlags() | PasteMenuFlags()
    "E&mpty"                        ,   mEmptyClipboard()   , EmptyClipboardMenuFlags()
    "Windows Clipboard"             ,                       , Divide
    "C&ut"+Chr(255)                 ,   CutToWinClip()      , BrowseModeMenuFlags() | CutCopyMenuFlags()
    "Cut Appe&nd"+Chr(255)          ,   CutAppendToWinClip(), BrowseModeMenuFlags() | CutCopyMenuFlags()
    "C&opy"+Chr(255)                ,   CopyToWinClip()     , CutCopyMenuFlags()
    "Copy Appen&d"+Chr(255)         ,   CopyAppendToWinClip(),CutCopyMenuFlags()
    "Pa&ste"+Chr(255)               ,   PasteFromWinClip()  , BrowseModeMenuFlags() | WinClipMenuFlags()
    "Paste Ove&r"+Chr(255)          ,   PasteFromWinClip(_OVERWRITE_), BrowseModeMenuFlags() | WinClipMenuFlags()
    "Empt&y"+Chr(255)               ,   EmptyWinClip()      , WinClipMenuFlags()
    ""                              ,                       , Divide
    "Named Clip&Boards  "          ,   ExecMacro("nameclip"),DontClose
end

menu WindowMenu()
    history

    "Split &Horizontally"   ,   HWindow()
    "Split &Vertically"     ,   VWindow()
    "&Resize..."            ,   ResizeWindow()          , WindowMenuFlags()
    "&Go to..."             ,   GotoWindow()            , WindowMenuFlags()
    "&Zoom"                 ,   ZoomWindow()            , WindowMenuFlags()
    "&One"                  ,   OneWindow()             , WindowMenuFlags()
    "&Close..."             ,   mCloseWindow()
    ""                          ,                       , Divide
    "Open &File && Window"  ,   mOpenFileAndWindow()
    "Close File && &Window" ,   mCloseFileAndWindow()
    ""                          ,                       , Divide
    "&Toggle Sync Scrolling",   ExecMacro("synchscr")   , WindowMenuFlags()
    "Togg&le Horiz/Vertical",   ExecMacro("togwin")     , iif(NumWindows() == 2, _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_)
end

menu BlockMenu()
    history

    "Mark &Line"                ,   MarkLine()
    "Mark Ch&aracter"           ,   MarkStream()
    "Mar&k Column"              ,   MarkColumn()
    "Mark to &EOL"              ,   MarkToEOL()         , AtEOLMenuFlags()
    "Mark Para&graph"           ,   mMarkPara()
    "&UnMark"                   ,   UnMarkBlock()       , BlockMenuFlags()
    ""                          ,                       , Divide
    "&Copy"                     ,   CopyBlock()         , BrowseModeMenuFlags() | BlockMenuFlags()
    "&Move"                     ,   MoveBlock()         , BrowseModeMenuFlags() | BlockMenuFlags()
    "&Shift..."                 ,   mShift()            , BrowseModeMenuFlags() | BlockMenuFlags()
    "&Write to File..."         ,   ExecMacro("dlgopen -b")
    "&Fill..."                  ,   ExecMacro("dlgfill"), BrowseModeMenuFlags() | BlockMenuFlags()
    "&Delete"                   ,   DelBlock()          , BrowseModeMenuFlags() | BlockMenuFlags()
    ""                          ,                       , Divide
    "U&pper  "                 ,   mUpper()            , DontClose
    "Lowe&r  "                 ,   mLower()            , DontClose
    "Fl&ip   "                 ,   mFlip()             , DontClose
    "Capitali&ze  "            ,   mCapital()          , DontClose
end

menu SearchMenu()
    history

    "&Find..."                      ,   ExecMacro("dlgfind")
    "&Replace..."                   ,   ExecMacro("dlgrplc"),   BrowseModeMenuFlags()
    "&Again"                        ,   RepeatFind()
    "Find and &Do..."               ,   ExecMacro("find&do1")
    ""                              ,                       , Divide
    "Find &Word at Cursor"          ,   mFindWordAtCursor('+')
    "&Incremental Search..."        ,   ExecMacro("isrch")
    "&Match"                        ,   ExecMacro("match")
    ""                              ,                       , Divide
    "Compressed &View..."           ,   ExecMacro("dlgfind -v")
    "F&unction List..."             ,   mShowFunctions()
    "Grep i&n Files..."             ,   ExecMacro("grep")
    "R&edisplay View PickList"      ,   ViewFinds()
    ""                              ,                       , Divide
    "&Place Bookmark..."            ,   PlaceMark()
    "&Go to Bookmark..."            ,   GotoMark()
    ""                              ,                       , Divide
    "Go to &Line..."                ,   ExecMacro("dlggoto")
    "Go to &Column..."              ,   ExecMacro("dlggoto -c")
end

menu PrintMenu()
    history

    "&File"                 ,   PrintFile()
    "&Block"                ,   PrintBlock(), BlockMenuFlags()
//    "&Send Formfeed"        ,   mSendFormFeed()
//    "Send &Init String"     ,   mSendInitString(), DontClose
    "Set &Options  "       ,   ExecMacro("Iconfig PrintConfig"), DontClose
end PrintMenu

menu MacroMenu()
    Title = "Keyboard Macros"
    history

    "&Record Key Macro..."          ,   RecordKeyMacro()
    "&Save Key Macro..."            ,   ExecMacro("dlgopen -v")
    "Load &Key Macro..."            ,   ExecMacro("dlgopen -k")
    "Run Scrap &Macro"              ,   ExecScrapMacro()
    "Edi&t Key Macro"               ,   ExecMacro("editkbd")
    "Pur&ge Key Macro"              ,   PurgeKeyMacro()
    "Compiled Macros"               ,                   ,   Divide
    "&Execute..."                   ,   ExecMacro("dlgmcc")
    "&Load..."                      ,   ExecMacro("dlgopen -l")
    "&Purge..."                     ,   ExecMacro("dlgmcc")
    "&Compile"                      ,   mCompileCurrfile()
    "Compile Men&u"                 ,   mCompileMenu()
    "&Debug..."                     ,   mDebugCurrfile()
    "&AutoLoad List"                ,   EditAutoLoadList()
end

menu TextMenu()
    history

    "&Add Line (below)"         ,   AddLine()       ,   BrowseModeMenuFlags()
    "&Insert Line (above)"      ,   InsertLine()    ,   BrowseModeMenuFlags()
    "D&up Line"                 ,   DupLine()       ,   BrowseModeMenuFlags()
    "&Join Line"                ,   JoinLine()      ,   BrowseModeMenuFlags() | MoreLinesFlags()
    "Spli&t Line"               ,   SplitLine()     ,   BrowseModeMenuFlags()
    "&Swap Lines"               ,   mSwapLines()    ,   BrowseModeMenuFlags() | MoreLinesFlags()
    ""                          ,                   ,   Divide
    "&Delete Line"              ,   DelLine()       ,   BrowseModeMenuFlags() | iif(NumLines(), _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_)
    "Delete to &End of Line"    ,   DelToEol()      ,   BrowseModeMenuFlags() | AtEOLMenuFlags()
    "Delete Right &Word"        ,   DelRightWord()  ,   BrowseModeMenuFlags() | (iif(CurrPos() <= CurrLineLen() or CurrLine() < NumLines(), _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_))
    ""                          ,                   ,   Divide
    "Undo"                      ,   Undo()          ,   BrowseModeMenuFlags() | iif(UndoCount(), _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_)
    "Redo"                      ,   Redo()          ,   BrowseModeMenuFlags() | iif(RedoCount(), _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_)
    "&Global UnDelete"          ,   GlobalUnDelete(),   BrowseModeMenuFlags()
    "&Local UnDelete"           ,   UnDelete()      ,   BrowseModeMenuFlags()
    "Paste U&nDelete"           ,   PasteUnDelete() ,   BrowseModeMenuFlags()
    "&Restore Cursor Line"      ,   RestoreCursorLine(), BrowseModeMenuFlags()
    ""                          ,                   ,   Divide
    "Wrap &Paragraph"           ,   ExecMacro("wrappara"),BrowseModeMenuFlags()
    "&Center Line"              ,   ExecMacro("center"),  BrowseModeMenuFlags()
    "&Quote/Comment Line"       ,   ExecMacro("quote"),   BrowseModeMenuFlags()
end

menu UtilMenu()
    history

    "Line Dra&wing" [OnOffStr(Query(LineDrawing)):3], Toggle(LineDrawing), OEMMenuFlags()
    "Li&ne Type  "         ,   LineTypeMenu()      ,   OEMMenuFlags()
    ""                          ,                   ,   Divide
    "&Sort"                 ,   ExecMacro("sort " + Str(sort_flags)), BrowseModeMenuFlags() | BlockMenuFlags()
    "Sort &Order"   [ShowSortFlag() : 10], ToggleSortFlag(_DESCENDING_), DontClose
    "&Case-Sensitive Sort" [OnOffStr((sort_flags & _IGNORE_CASE_) == 0):3], ToggleSortFlag(_IGNORE_CASE_), DontClose
    ""                          ,                   ,   Divide
    "S&pell Check  "       ,   ExecMacro("SpellChk")
    "&ASCII Chart..."       ,   ExecMacro("dlgascii -x")
    "&Todo List..."         ,   ExecMacro("todo")
    "Add Todo &Item..."     ,   ExecMacro("todo -t")
    "&Date/Time Stamp"      ,   mDateTimeStamp(), BrowseModeMenuFlags()
    "S&hell"                ,   Shell()
    "Captu&re OS Output"    ,   ExecMacro("dlgdos -c")
    "Potpo&urri..."         ,   ExecMacro("Potpourr")
    "Ca&lculator..."        ,   ExecMacro("expr")
    "Where &Is..."          ,   ExecMacro("where")
end

menu AutoIndentMenu()
    command = Set(AutoIndent, MenuOption() - 1)
    history = Query(AutoIndent) + 1

    "O&ff"      ,, CloseBefore
    "O&n"       ,, CloseBefore
    "&Sticky"   ,, CloseBefore
end

menu WordWrapMenu()
    command = Set(WordWrap, MenuOption() - 1)
    history = Query(WordWrap) + 1

    "O&ff"      ,, CloseBefore
    "O&n"       ,, CloseBefore
    "&Auto"     ,, CloseBefore
end

menu SaveStateMenu()
    command = Set(SaveState, MenuOption() - 1)
    history = Query(SaveState) + 1

    "O&ff"                                  ,, CloseBefore
    "O&n    (Saved in loaddir)"             ,, CloseBefore
    "&Local (Saved in current directory)"   ,, CloseBefore
end

menu TabTypeMenu()
    history = Query(TabType) + 1
    command = Set(TabType,MenuOption()-1)

    "&Hard"     ,, CloseBefore
    "&Soft"     ,, CloseBefore
    "Smar&t"    ,, CloseBefore
    "&Variable" ,, CloseBefore
end

menu OptionsMenu()
    history

    "&AutoIndent"           [MenuStr(AutoIndentMenu,Query(AutoIndent)+1) : 6],
                            AutoIndentMenu()            ,   DontClose
    "&WordWrap"             [MenuStr(WordWrapMenu,Query(WordWrap)+1) : 4],
                            WordWrapMenu()            ,   DontClose
    "&Right Margin"         [Query(RightMargin) : 5],
                            Set(RightMargin, ReadNum(Query(RightMargin))),   DontClose
    "&Left Margin"          [Query(LeftMargin) : 5],
                            Set(LeftMargin, ReadNum(Query(LeftMargin))),   DontClose
    ""                          ,                   ,   Divide
    "Tab Ty&pe"             [MenuStr(TabTypeMenu,Query(TabType)+1) : 8],
                            TabTypeMenu()               ,   DontClose
    "&Tab Width"            [Query(TabWidth) : 5],
                            Set(TabWidth, ReadNum(Query(TabWidth))),   DontClose
    ""                          ,                   ,   Divide
    "Browse &Mode"          [OnOffStr(BrowseMode()) : 3],
                            BrowseMode(not BrowseMode())    ,   DontClose
    "&Backups"              [OnOffStr(Query(MakeBackups)) : 3],
                            Toggle(MakeBackups)         ,   DontClose
    "Save State on &Exit"   [iif(Query(SaveState) < 2, OnOffStr(Query(SaveState)), "Local") : 5],
                            SaveStateMenu()            ,   DontClose
    ""                          ,                   ,   Divide
    "Change &Video Mode..." ,   ExecMacro("dlgvideo")
//    "Change Display Si&ze  " ,   ExecMacro("Video")     ,DontClose
    "Set F&ont..."      ,   SetFont(), GUIMenuFlags()
    "He&x View"             [OnOffStr(DisplayMode() == _DISPLAY_HEX_):3],
                            DisplayMode(iif(DisplayMode() == _DISPLAY_TEXT_, _DISPLAY_HEX_, _DISPLAY_TEXT_))

    "Template Expa&nsion"   [OnOffStr(mQueryTemplate()):3], mToggleTemplateExpand(), DontClose
    ""                          ,                   ,   Divide
    "&Full Configuration  ",     ExecMacro("iconfig"),DontClose
    "&Save Current Settings  ",  mSaveSettings()
end

menu HelpMenu()
    history

    "Table of &Contents" ,   Help()
    "&Key Assignments"   ,   Help("Key Assignments")
    "&Index"             ,   Help("Index")
    "&Word at Cursor"    ,   mHelpOnWordAtCursor()
    "&Previous Topic"    ,   PrevHelp()
    "&Search"            ,   SearchHelp()
    "&About..."          ,   About()
end

menubar MainMenu()
    history

    "&File"    ,    FileMenu()
    "&Text"    ,    TextMenu()
    "&Search"  ,    SearchMenu()
    "&Block"   ,    BlockMenu()
    "&Clip"    ,    ClipMenu()
    "&Window"  ,    WindowMenu()
    "&Macro"   ,    MacroMenu()
    "&Print"   ,    PrintMenu()
    "&Util"    ,    UtilMenu()
    "&Options" ,    OptionsMenu()
    "&Help"    ,    HelpMenu()
end

// Mouse functions:

menu MouseMenu()
   Title="Mouse Menu"
   "&Cut",                           Cut()                  ,   BrowseModeMenuFlags() | CutCopyMenuFlags()
   "Cop&y",                          Copy()                 ,   CutCopyMenuFlags()
   "&Paste",                         Paste()                ,   BrowseModeMenuFlags() | PasteMenuFlags()
   "Paste &Over",                    Paste(_OVERWRITE_)     ,   BrowseModeMenuFlags() | PasteMenuFlags()
   "&UnMark",                        UnMarkBlock()          ,   BlockMenuFlags()
      ""                         ,                         ,   Divide
   "Cu&t to WinClip",                CutToWinClip()         ,   BrowseModeMenuFlags() | CutCopyMenuFlags()
   "Copy to &WinClip",               CopyToWinClip()        ,   CutCopyMenuFlags()
   "P&aste from WinClip",            PasteFromWinClip()     ,   BrowseModeMenuFlags() | WinClipMenuFlags()
      ""                         ,                         ,   Divide
   "Copy &Block",                    CopyBlock()            ,   BrowseModeMenuFlags() | BlockMenuFlags()
   "Copy O&ver Block",               CopyBlock(_OVERWRITE_) ,   BrowseModeMenuFlags() | BlockMenuFlags()
   "&Move Block",                    MoveBlock()            ,   BrowseModeMenuFlags() | BlockMenuFlags()
   "&Delete Block",                  DelBlock()             ,   BrowseModeMenuFlags() | BlockMenuFlags()
      ""                         ,                         ,   Divide
   "&Fill Block",                    FillBlock()            ,   BrowseModeMenuFlags() | BlockMenuFlags()
   "&Sort",                          ExecMacro("sort " + Str(sort_flags)),  BrowseModeMenuFlags() | BlockMenuFlags()
      ""                         ,                         ,   Divide
   "Uppe&r   ",                     mUpper()
   "&Lower   ",                     mLower()
   "Fl&ip    ",                     mFlip()
   "Capitali&ze"                 ,  mCapital()             ,   DontClose
end

/****************************************************************************
   This macro is called just after the first file is loaded, but before the
   user is given control, and before any hook functions are called.
 ***************************************************************************/
proc Main()
end

//*** Key-assignment Help screen ********************************************
helpdef KeyAssignments
    title = "Classic TSEPro Key Assignments"
""
" Movement"
" --------"
""
" right/left/up/down  Right/Left/Up/Down"
" ctrl up/down        Roll Up/Down"
" ctrl right/left     Word Right/Left"
" home/end            Begin/End Line"
" ctrl home/end       Begin/End Window"
" pgup/pgdn           Page Up/Down"
" ctrl pgup/dn        Begin/End File"
""
" alt pgup/dn         Prev/Next Para"
""
" shift f5            Scroll to Center"
" f5                  Scroll to Top"
" ctrl z/w            Scroll Down/Up"
""
" alt f5/f6           Roll Left/Right"
" ctrl q-p            Prev Position"
""
" Editing"
" -------"
""
" f2                  Add Line"
" alt f2 or ctrl n    Insert Line"
" f4                  Duplicate Line"
""
" ctrl p              Literal"
" ctrl -              Copy Char from Above Line"
" alt -               Copy Chars from Above LIne until End-of-line"
""
" backspace           Delete Left Char"
" del                 Delete Char"
" ctrl backspace      Delete Left Word"
" ctrl del or ctrl t  Delete Right Word"
" alt del or f6       Delete until End-of-line"
" alt d or ctrl d/y   Delete Line"
""
" alt s/j             Split/Join Line"
""
" shift f3            Sort Block"
" ctrl f2             Swap Lines"
""
" alt/shift f4        Lower/Upper Case Change Menu"
" ctrl o-t            Center Line/Block"
" alt b               Wrap Para"
""
" ctrl 8              Comment out Line/Block"
" ctrlshift 8         Insert block comment"
""
" alt backspace       Undo"
" altshift backspace  Redo"
" ctrl q-l            Undo Cursor Line Changes"
""
" ctrl u              Undelete"
""
""
" Block"
" -----"
""
" shift f7/f8         Shift Line/Block Left/Right"
" ctrl f7             prompted Shift Line/Block"
""
" grey -/+/*          Cut/Copy/Paste"
" ctrlshift grey-/+/* Cut/Copy/Paste to Windows Clipboard"
""
" ctrl grey -/+       Cut/Copy Append"
" ctrl grey *         Paste Overwrite"
""
" ctrl [/]            Goto Block Begin/End"
""
" alt a/i/k/l         Start Marking Stream/Char/Column/Line Block"
" ctrl k-t            Mark Word"
" alt y               Mark until End-of-line"
""
" alt u               Unmark Block"
""
" alt c/m/g/w         Copy/Move/Delete/Write Block"
" alt z               Copy Overwrite Block"
" ctrl k-l            Fill Block with Char"
""
" ctrl b              Named Clipboards menu"
""
" Find/Replace"
" ------------"
""
" ctrl f/r/l          Find/Replace/Repeat Last Find/Replace"
" ctrlshift l         Repeat Last Find/Replace in Reverse Direction"
" ctrl i              Incremental Search"
""
" alt =               Find Word at Cursor"
" ctrl =              Find Word at Cursor Backwards"
" ctrl \              Find Word at Cursor Starting at Beginning-of-file"
""
" alt v               Compressed View"
" altshift v          Review Last Compressed View"
" ctrl g              List Functions"
""
" ctrl j/c            Goto Line/Column"
""
" alt f3              Find Matching Char"
""
" File"
" ----"
""
" alt e               Open a File for Editing"
" alt n/p             Goto the Next/Prev File"
" alt 0/ctrl 0        List Open/Recently Edited Files"
" alt r               Insert a File at Current Position"
" alt w               Save As or Write Block"
" alt o               Rename Current File"
" ctrl k-z            Erase Current File from Disk"
" ctrl k-q            Close Current File (prompted)"
" ctrl k-s            Save Current File"
" ctrl k-x            Save and Quit Current File"
" alt x               Exit (prompted)"
""
" Windows"
" -------"
""
" alt 1..9            Go to Window 1..9"
""
" Ctrl o-c            Close Current Window"
" Ctrl o-d            Delete Selected Window"
" Ctrl o-g            Goto Window"
" Ctrl o-h            Horizontal Window"
" Ctrl o-n            Next Window"
" Ctrl o-o            Close All but Current"
" Ctrl o-p            Previous Window"
" Ctrl o-r            Resize Window"
" Ctrl o-v            Vertical Window"
" Ctrl o-z            Zoom Window"
" Ctrl o-y            Toggle Synch Scrolling"
""
" Bookmarks"
" ---------"
""
" ctrl 6/2            Goto/Place Mark"
" ctrl q-0..9         Goto Mark 'q'..'z'"
" ctrl k-0..9         Place Mark 'q'..'z'"
""
" Macros"
" ------"
""
" ctrl enter          Run Scrap Macro"
" ctrl m              Start/Stop recording a Macro"
""
" ctrl x              Run Compiled Macro"
" ctrl f10            Macro menu"
" ctrl f9             Compile Current File"
" shift f9            Compile Menu"
""
" Miscellaneous"
" -------------"
""
" f10/escape          Main Menu"
" f1                  Help"
" ctrl f1             Help on Word at Cursor"
" alt f1              Previous Help Topic"
" shift f1            Show Key Assignments"
""
" ctrl a              Show Ascii Chart"
" alt f10             Show Entry Screen"
""
" ins                 Toggle Insert Mode"
" Ctrl o-w            Toggle Word Wrap Mode"
" Ctrl q-i            Toggle AutoIndent Mode"
" f11                 Toggle Maximized Window"
""
" ctrl qq             Repeat Last Command"
""
" altshift f9         Capture OS Command Output"
" alt f9              OS Command"
" f9                  OS Shell"
" f12                 Spell Check"
""
" shift f10           Potpourri Menu"
""
""
end

//
// Keyboard bindings...
//

keydef PromptKeys
<Shift Del>             CutToWinClip()
<Ctrl Ins>              CopyToWinClip()
<Shift Ins>             PasteFromWinClip()
end

/****************************************************************************
  Available keys include:

    Ctrl Tab
    Alt []
    Alt or Ctrl `;',./
    Alt h, Alt q
    Ctrl e, Ctrl s, Ctrl h
    F3, F7, F8
    Ctrl-F3, Ctrl-F4, Ctrl-F5, Ctrl-F6, Ctrl-F8
    Alt F7, Alt F8
    Shift F2, Shift F6, Shift F9

    {Alt Tab, Alt Escape, Alt Enter} - reserved by Windows
 ***************************************************************************/

//*** HelpLine assignments **************************************************

<HelpLine>        "{F1}-Help {F2}-AddLn {F4}-DupLn {F5}-ScrollTop {F6}-DelToEol {F9}-Shell {F10}-Menu"
<Alt HelpLine>    "{Alt: F2}-InsLn {F3}-Match {F4}-Lower {F5}-RollLt {F6}-RollRt {F9}-Dos {F10}-ShowEntry"
<Ctrl HelpLine>   "{Ctrl: F1}-HelpWord {F2}-SwapLns {F7}-Shift {F9}-Compile {F10}-MacroMenu"
<Shift HelpLine>  "{Shift: F1}-Keys {F3}-Sort {F4}-Upper {F5}-ScrollCtr {F7}-ShiftLt {F8}-ShiftRt {F10}-Potpourri"

<Ctrl k><HelpLine> "menu:{L}   Fill Block;{Q}   Quit File;{S}   Save File;{T}   Mark Word;{X}   Save and Quit File;{Z}   Kill File;{0}-{9} Place Mark"
<Ctrl o><HelpLine> "menu:{C} Close Window;{D} Delete Window;{G} Goto Window;{H} Horizontal Window;{N} Next Window;{O} One Window;{P} Previous Window;{R} Resize Window;{T} Center Line/Block;{V} Vertical Window;{W} Toggle Word Wrap;{Y} Toggle SynchScroll;{Z} Zoom Window;"
<Ctrl q><HelpLine> "menu:{I}   Toggle AutoIndent;{L}   Restore Cursor Line;{P}   Previous Position;{Q}   Repeat Previous Command;{0}-{9} Goto Mark;"

//*** Cursor Movement commands **********************************************

<Ctrl Home>             BegWindow()
<Ctrl End>              EndWindow()

<Ctrl PgUp>             mBegFile()
<Ctrl PgDn>             mEndFile()

<Shift PgUp>            mPrevPara()
<Alt PgUp>              mPrevPara()
<Shift PgDn>            mNextPara()
<Alt PgDn>              mNextPara()

<Shift F5>              ScrollToCenter()
<F5>                    ScrollToTop()
<Ctrl z>                Scrolldown()
<Ctrl w>                Scrollup()

<Alt F5>                RollLeft()
<Alt F6>                RollRight()

<Ctrl q><p>             PrevPosition()

//*** Text editing commands *************************************************

<Alt t>                 MainMenu('T')      // Bring up Text SubMenu

<Ctrl Backspace>        DelLeftWord()
<Ctrl Del>              DelRightWord()
<Alt Del>               DelToEol()

<F2>                    AddLine()
<Alt F2>                InsertLine()
<Ctrl n>                InsertLine()
<F4>                    DupLine()

<Ctrl p>                Literal()
<Ctrl ->                mCopyCharAbove()
<Alt ->                 mCopyCharAboveToEol()

<BackSpace>             mBackSpace()
<Del>                   mDelChar()
<Ctrl t>                DelRightWord()
<F6>                    DelToEol()
<Alt d>                 DelLine()
<Ctrl d>                DelLine()
<Ctrl y>                DelLine()

<Enter>                 mCreturn()
<Alt s>                 SplitLine()
<Alt j>                 JoinLine()

<Shift Tab>             mTabLeft()
<Tab>                   mTabRight()

<Shift F7>              mShiftBlock(SHIFTLEFT)
<Shift F8>              mShiftBlock(SHIFTRIGHT)

<Shift F3>              ExecMacro("sort " + Str(sort_flags))
<Ctrl F2>               mSwapLines()

<Alt F4>                mLower()
<Shift F4>              mUpper()

<Ctrl o><t>             ExecMacro("center")
<Alt b>                 ExecMacro("wrappara")

<Ctrl q><l>             RestoreCursorLine()
<Ctrl u>                GlobalunDelete()

<Alt BackSpace>         Undo()
<AltShift BackSpace>    Redo()

<Ctrl 8>                ExecMacro("quote")
<CtrlShift 8>           ExecMacro("quote cmt")

//*** Block commands ********************************************************

<Shift Del>             CutToWinClip()
<Ctrl Ins>              CopyToWinClip()
<Shift Ins>             PasteFromWinClip()

<Grey+>                 Copy()
<CtrlShift Grey+>       CopyToWinClip()
<CtrlShift Grey->       CutToWinClip()

<Grey->                 Cut()

<Ctrl Grey+>            CopyAppend()
<Ctrl Grey->            CutAppend()

<Grey*>                 Paste()
<Ctrl Grey*>            Paste(_OVERWRITE_)
<Ctrl PrtSc>            Paste(_OVERWRITE_)
<CtrlShift Grey*>       PasteFromWinClip()

<Ctrl [>                Gotoblockbegin()
<Ctrl ]>                Gotoblockend()

<Alt a>                 MarkStream()
<Alt i>                 MarkChar()
<Alt k>                 MarkColumn()
<Alt l>                 MarkLine()
<Ctrl k><t>             MarkWord()
<Alt y>                 MarkToEOL()
<Alt u>                 UnmarkBlock()

<Alt c>                 CopyBlock()
<Alt z>                 CopyBlock(_OVERWRITE_)
<Alt m>                 MoveBlock()
<Alt g>                 DelBlock()

<Alt w>                 ExecMacro("dlgopen -b")
<Ctrl k><l>             FillBlock()
<Ctrl F7>               mShift()        // Block/Text shifting

<Ctrl b>                ExecMacro("nameclip Named ClipBoards")

//*** Window commands *******************************************************

// Alt 1..9 goto the numbered window

<Alt 1>                 GotoWindow(1)
<Alt 2>                 GotoWindow(2)
<Alt 3>                 GotoWindow(3)
<Alt 4>                 GotoWindow(4)
<Alt 5>                 GotoWindow(5)
<Alt 6>                 GotoWindow(6)
<Alt 7>                 GotoWindow(7)
<Alt 8>                 GotoWindow(8)
<Alt 9>                 GotoWindow(9)

<Ctrl o><c>             CloseWindow()
<Ctrl o><d>             DelWindow()
<Ctrl o><g>             GotoWindow()
<Ctrl o><h>             HWindow()
<Ctrl o><n>             NextWindow()
<Ctrl o><o>             OneWindow()
<Ctrl o><p>             PrevWindow()
<Ctrl o><r>             ResizeWindow()
<Ctrl o><v>             VWindow()
<Ctrl o><z>             ZoomWindow()
<Ctrl o><y>             ExecMacro("synchscr")

//*** BookMark commands *****************************************************

<Ctrl 6>                GotoMark()
<Ctrl 2>                PlaceMark()

<Ctrl q><0>             GotoMark("q")
<Ctrl q><1>             GotoMark("r")
<Ctrl q><2>             GotoMark("s")
<Ctrl q><3>             GotoMark("t")
<Ctrl q><4>             GotoMark("u")
<Ctrl q><5>             GotoMark("v")
<Ctrl q><6>             GotoMark("w")
<Ctrl q><7>             GotoMark("x")
<Ctrl q><8>             GotoMark("y")
<Ctrl q><9>             GotoMark("z")

<Ctrl k><0>             PlaceMark("q")
<Ctrl k><1>             PlaceMark("r")
<Ctrl k><2>             PlaceMark("s")
<Ctrl k><3>             PlaceMark("t")
<Ctrl k><4>             PlaceMark("u")
<Ctrl k><5>             PlaceMark("v")
<Ctrl k><6>             PlaceMark("w")
<Ctrl k><7>             PlaceMark("x")
<Ctrl k><8>             PlaceMark("y")
<Ctrl k><9>             PlaceMark("z")

//*** Find/Replace commands *************************************************

<Ctrl f>                ExecMacro("dlgfind")
<CtrlShift f>           Find()
<Ctrl i>                ExecMacro("isrch")
<Ctrl l>                Repeatfind()
<CtrlShift l>           RepeatFind(_REVERSE_)
<Ctrl r>                ExecMacro("dlgrplc")
<CtrlShift r>           Replace()

<Alt =>                 mFindWordAtCursor('+')
<Ctrl =>                mFindWordAtCursor('b')
<Ctrl \>                mFindWordAtCursor('g')

<Alt v>                 ExecMacro("dlgfind -v")
<AltShift v>            ViewFinds()
<Ctrl g>                mShowFunctions()
<Ctrl c>                ExecMacro("dlggoto -c")
<Ctrl j>                ExecMacro("dlggoto")
<CtrlShift c>           GotoColumn()
<CtrlShift j>           GotoLine()

<Alt F3>                ExecMacro("match")

//*** Macro commands ********************************************************

<Ctrl Enter>            ExecScrapMacro()
<Ctrl m>                RecordKeyMacro()

<Ctrl x>                ExecMacro("dlgmcc")     // Execute SAL macro
<CtrlShift x>           ExecMacro()             // Execute SAL macro
<Ctrl F10>              ExecLoadPurge() // Macro (SAL) manipulation

<Ctrl F9>               mCompileCurrFile()
<Shift F9>              ExecMacro("Compile -m")

//*** File commands *********************************************************

<Alt f>                 MainMenu('F')  // Bring up the FileMenu

<Alt e>                 ExecMacro("dlgopen")

<Alt n>                 Nextfile()
<Alt p>                 Prevfile()

<Alt 0>                 ExecMacro("dlgbuff")
<Ctrl 0>                ExecMacro("dlgrcnt")

<Alt r>                 ExecMacro("dlgopen -i")
<Alt o>                 ChangeCurrFilename()
<Ctrl k><z>             Killfile()

<Ctrl k><q>             QuitFile()
<Ctrl k><s>             SaveFile()
<Ctrl k><x>             SaveAndQuitFile()

<Alt x>                 Exit()

//*** Other commands ********************************************************

<F10>                   MainMenu()
<Escape>                MainMenu()

<F1>                    Help()
<Ctrl F1>               mHelpOnWordAtCursor()
<Alt F1>                PrevHelp()
<Shift F1>              Help("Key Assignments")

<Ctrl a>                ExecMacro("dlgascii -x")
<Alt F10>               ShowEntryScreen()

<Ctrl o><w>             mToggleWordWrap()
<Ctrl q><i>             mToggleAutoIndent()

<}>                     mCloseBrace()

<Ctrl q><q>             RepeatCmd()

<AltShift F9>           ExecMacro("dlgdos -c")
<Alt F9>                Dos()
<F9>                    Shell()
<F12>                   ExecMacro("SpellChk")

<Shift F10>             ExecMacro("Potpourr")

<CtrlAlt SpaceBar>      lVersion()
<f11>                   ExecMacro("togmax")

//*** Mouse keys ************************************************************

<LeftBtn>               mLeftBtn()
<Ctrl LeftBtn>          MouseMarking(_COLUMN_)
<Alt LeftBtn>           MouseMarking(_LINE_)
<Shift LeftBtn>         mShiftLeftBtn()
<RightBtn>              mRightBtn()

