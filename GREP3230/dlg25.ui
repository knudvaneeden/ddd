/****************************************************************************

               The SemWare Editor V2.5 - Standard User Interface

    Copyright 1991-1996 SemWare Corporation.  All Rights Reserved Worldwide.

 This program gives The SemWare Editor its standard user interface, including
 user preferences, certain built-in commands, menus, help, and key assignments.

 If you want to use a config file rather than ICONFIG for user preferences,
 include the following file:

    tse.cfg     - user preferences file

 ***************************************************************************/

/****************************************************************************
 This file has been changed, as compared to the original TSE.UI, so that
 it utilizes the new dialog boxes provided by the Dialog macro package.

 changed WhenLoaded (accesses the new dialogs now)
        basic logic didn't change

 changed OnPromptStartup to call the new ascii chart dialog

 renamed mCompressView to mShowFunctions
        normal compress now calls "DlgFind -v"
        mShowFunctions is mCompressView with normal compress removed

 assigned the new dialogs to a couple of keys and menu entries
        search 'ExecMacro("dlg' to find these lines

 added a couple of backup key assignments, to be used in keyboard macros
        <CtrlShift f>           Find()
        <CtrlShift r>           Replace()
        <CtrlShift c>           GotoLine()
        <CtrlShift j>           GotoColumn()
        <CtrlShift x>           ExecMacro()

 removed "File|Change Name..."
        since the new "File|SaveAs..." command is essentially
        a combination of ChangeCurrFilename() and SaveFile()

 removed internal recent files list (mListRecentFiles)

 removed internal Ascii-Chart (mAsciiChart)

 removed global variables compress_hist & compress_option_hist
        don't need them anymore (same history is accessed by DlgFind)

 added GetRecentFilesId() which returns the id of the recent
        files buffer without actually going to that buffer

 commented LongestLineInBuffer (never used)

 DiK 05-10-05   v2.22
 DiK 01-07-99   v2.02
 DiK 10-24-96   v2.00
 DiK 05-17-96   v1.21
 DiK 03-18-96   v1.20
 DiK 10-08-95   v1.10
 DiK 12-19-95   v1.00
 ***************************************************************************/

//#include ["tse.cfg"]      // config-endconfig definitions

#ifdef WIN32
    constant MAXPATH = 255
    string CONSOLE[] = "CONIN$"
#else
    constant MAXPATH = 80
    string CONSOLE[] = "CON"

    integer proc isCharDevice(integer handle)
        register r

        r.ax = 0x4400
        r.bx = handle
        intr(0x21, r)
        return ((r.dx & 0x80) <> 0)
    end

    integer proc fDup2(integer oldhandle, integer newhandle)
        register r

        r.ax = 0x4600
        r.bx = oldhandle
        r.cx = newhandle
        intr(0x21, r)
        return (0)
    end

    /****************************************************************************
      Empties the current buffer
      sets the binary mode to reclen
      Loads fn into it
      returns true(non-zero)/false(zero)

      No hooks are called
     ****************************************************************************/
    integer proc LoadBuffer(string fn, integer reclen)
        integer ok

        EmptyBuffer()
        BinaryMode(reclen)
        PushBlock()
        ok = InsertFile(fn, _DONT_PROMPT_)
        PopBlock()
        return (ok)
    end

    /****************************************************************************
      Creates a new temporary buffer of type flags (_SYSTEM_ if not passed)
      sets the binary mode to reclen
      Loads fn into it
      makes it the current buffer
      returns id

      No hooks are called
     ****************************************************************************/
    integer proc EditBuffer(string fn, integer flags, integer reclen)
        integer id

        id = CreateBuffer("", iif(flags == 0, _SYSTEM_, flags))
        if id
            LoadBuffer(fn, reclen)
        endif
        return (id)
    end

//      integer proc LongestLineInBuffer()
//          integer maxlen = 0
//
//          PushPosition()
//          BegFile()
//          repeat
//              maxlen = Max(maxlen, CurrLineLen())
//          until not Down()
//          PopPosition()
//          return (maxlen)
//      end

    string proc QuotePath(string path)
        return (path)
    end

#endif

/****************************************************************************
  Some definitions / notes

  Macros used as commands (that are assigned to keys or menus sequences)
  are prefixed with lower case "m" to distinguish them from built-in
  commands, e.g., mDelChar() is a macro, DelChar() is a builtin command.

  Current character - The character at the cursor position in the
  currently edited file.  Where the next typed character will be
  inserted or replaced.
 ***************************************************************************/

// Global variables - assumes globals initialized to 0.

integer cmode               // (internal) used to invoke C-mode
integer language            // (internal) used to invoke language package
integer sort_flags          // (internal) used for Sorting

integer recent_files        // (internal) id of the recent_files
integer save_wordwrap       // (internal) used in toggling wordwrap mode
integer save_autoindent     // (internal) used in toggling autoindent mode

string KeyWords[] = " case do else elseif for if loop otherwise proc repeat switch when while "

string c_fun[]      = "^_@[a-zA-Z][a-zA-Z0-9_* \t]@([~;]*$"
// Note that c++ allows a few extra characters in function names.
//string cpp_fun[]    = "^_|~@[a-zA-Z:~][a-zA-Z0-9_* \t:~]@([~;]*$"
string cpp_fun[]    = "^{extern[ \t]+\x22C\x22[ \t]+}?_|~@[a-zA-Z:][a-zA-Z0-9_+\-*/%^&|~!=<>,\[\] \t:~]@([~;]*$"
string sal_fun[]    = "^{menu}|{{public #}?{{integer #}|{string #}}@proc} +[a-zA-Z_]"
string pas_fun[]    = "{procedure}|{function} +[a-zA-Z_]"
string xbase_fun[]  = "^{static }?{{procedure}|{function}} +[a-zA-Z_]"
string basic_fun[]  = "{^ @def fn}|{^ @sub}"
string ini_fun[]    = "\[.*\]"      // .ini files
string ident_set[]  = "[_a-zA-Z]"
string TEMPLATE[]   = "template"

/****************************************************************************
  A simple language indenting package, providing the following:

  When AutoIndent is on,

  BackSpace, when the cursor is on a blank line or the first
  non-blank character of a line, issues  TabLeft(), in
  effect doing an outdent.

  Return, causes an extra indent when the first word of the line
  is one of the following:

  if else elseif while repeat loop for switch case when

  Additionally, special handling of {} is provided for C
  programmers.

  To make this package work:

  Assign mBackSpace() to <backspace>
  Assign mCReturn() to <Enter>          // special handling for C
  Assign  TabLeft() to <shift tab>
  Assign mCloseBrace() to <shift ]>      // For C files

  The _ON_CHANGING_FILES_ hook sets this mode (language) for files with
  extensions of s, c, and h.
  cmode is also set for files with extensions of c and h.

 ***************************************************************************/

/****************************************************************************
  Fancy backspace() command.
  Sort of like Borlands environment.  In language mode, backspace
  does a "outdent" when there is only white space before the cursor.

  Also does special handling for overwrite mode.  In overwrite mode,
  does a "rubout" instead of a backspace.
 ***************************************************************************/
proc mBackSpace()
    if CurrPos() == 1       // at beg-of-line, just join to previous
        if PrevChar()
            JoinLine()
        endif
        return ()
    endif

    // if from here to prev-tabstop is 'white', then TabLeft()

    if Query(AutoIndent) and language
        if CurrPos() <= PosFirstNonWhite()
            TabLeft()
            return ()
        endif
        PushPosition()
        GotoColumn(CurrCol() - DistanceToTab())
        if CurrPos() > PosLastNonWhite()
            PopPosition()
            TabLeft()
            return ()
        endif
        PopPosition()
    endif

    // Finally, do either rubout or backspace based on InsertMode

    Left()
    if CurrChar() >= 0
        if Query(Insert) or CurrPos() == CurrLineLen()
            DelChar()
        else
            InsertText(" ", _OVERWRITE_)
            Left()
        endif
    endif
end

/****************************************************************************
   Return the first word on the line as string - '' if not there.
 ***************************************************************************/
string proc GetFirstWord()
    string word[32] = ''

    PushPosition()                  // Save where we're at
    GotoPos(PosFirstNonWhite())     // Go to first non white
    word = Lower(GetWord())         // Now get the word there
    PopPosition()                   // Restore saved position
    return (' ' + word + ' ')       // And return the word
end

/****************************************************************************
  Fancy CarriageReturn command.  Works if language mode is on.

  11-05-93 SEM Handle SmartTabs
 ***************************************************************************/
integer proc mCReturn()
    integer ok, save_tabtype, found = FALSE

    if language and CurrPos() > PosFirstNonWhite()
        found = Pos(Lower(GetFirstWord()), KeyWords) <> 0
            or (cmode and Pos('{', GetText(1, CurrPos())) <> 0)
    endif
    if not CReturn()
        return (FALSE)
    endif

    ok = TRUE
    if found and ((Query(Insert) and Query(ReturnEqNextLine) == FALSE)
            or PosFirstNonWhite() == 0)

        save_tabtype = Set(TabType, _SOFT_)     // force fixed tabs
        ok = TabRight()
        Set(TabType, save_tabtype)              // restore tabtype
    endif
    return (ok)
end

/****************************************************************************
  Special handling of } for C programmers
 ***************************************************************************/
integer proc mCloseBrace()
    if cmode and PosFirstNonWhite() == 0
        TabLeft()
    endif
    return (InsertText("}"))
end

/****************************************************************************
  Helper macros/Subroutines

  These routines are:

   not intended for use as commands by themselves
   not intended to be assigned to keys or menus
   intended to be called from other macros
 ***************************************************************************/

/****************************************************************************
   Returns the string "On" or "Off" based on the logical value of i.

   Used by menus to display on/off strings.
 ***************************************************************************/
string proc OnOffStr(integer i)
    return (iif(i, "On", "Off"))
end

/****************************************************************************
   Helper routines for Sort on the Options menu.

   Return the appropriate string.
 ***************************************************************************/
string proc ShowSortFlag()
    return (iif(sort_flags & _DESCENDING_, "Descending", "Ascending"))
end

/****************************************************************************
   Helper routines for Sort on the Options menu.

   Toggle the sort order or case significance.
 ***************************************************************************/
proc ToggleSortFlag(integer which)
    if sort_flags & which
        sort_flags = sort_flags & ~ which
    else
        sort_flags = sort_flags | which
    endif
end

/****************************************************************************
   Read command that returns the numeric value of the user input.
 ***************************************************************************/
integer proc ReadNum(integer n)
    string s[5] = str(n)

    return (iif(ReadNumeric(s), val(s), n))
end ReadNum

///////////////////// End Help Macros/Subroutines ///////////////////////

/****************************************************************************
  Macros that follow can:

   be assigned to keys and menus as commands
   therefore, can be directly executed by the user

  Commands implemented in the macro langauge:

     mCopyCharAbove
     mShift [ShiftBlock]
     mFindWordAtCursor
     mCompressView (mShowFunctions)     // renamed DiK 03-11-96
     mAsciiChart                        // removed DiK 12-11-95
     mListRecentFiles                   // removed DiK 10-08-95
     mSwapLines
     mSendFormFeed
     SendInit
     mDateTimeStamp

  Commands augmented via macros:

     mDelChar()
     mUpper()
     mLower()
     mFlip()
     mWrapPara
     mBegFile
     mEndFile
 ***************************************************************************/

/****************************************************************************
  The GetPrev command.

  Copy the character on the line above to the current position
 ***************************************************************************/
integer proc mCopyCharAbove()
    integer c, sv = Set(RemoveTrailingWhite, OFF)

    PushPosition()                  // save position
    c = iif(up(), CurrChar(), -1)   // Try for char on line above
    PopPosition()                   // back to where we were
    Set(RemoveTrailingWhite, sv)
    return (c >= 0 and InsertText(Chr(c)))
end mCopyCharAbove

/****************************************************************************
  The GetPrevToEOL command.

  Copy the character on the line above to the current position, and keep
  copying until the eol is reached (on the line above)
 ***************************************************************************/
proc mCopyCharAboveToEol()
    repeat
    until not mCopyCharAbove()
end

constant SHIFTLEFT = -1, SHIFTRIGHT = 1

/****************************************************************************
  Shift text left/right

  If in a block, shift the entire block.

   11-05-93 SEM Handle WordStar-style line blocks better
 ***************************************************************************/
integer proc mShiftBlock(integer direction)
    integer goal_line = CurrLine(),
            btype     = isCursorInBlock(),
            save_marking   = Set(Marking, off),
            p = CurrPos()

    PushPosition()
    if btype or (isBlockInCurrFile() and CurrLine() >= Query(BlockBegLine)
            and CurrLine() <= Query(BlockEndLine))
        goal_line = Query(BlockEndLine)
        GotoBlockBegin()
    endif
    repeat until not ShiftText(direction)
            or   not RollDown()
            or   CurrLine() > goal_line
    PopPosition()
    GotoPos(p)
    Set(Marking, save_marking)
    return (TRUE)
end

/****************************************************************************
  The standard Shift command.

  Shift text left/right based on the keys pressed.
 ***************************************************************************/
proc mShift()
    integer k = Set(EquateEnhancedKbd, ON)

    loop
        Message("<Left>,<Right> or <Tab>,<Shift Tab> to shift text; <Enter> when done")
        case GetKey()
            when <CursorLeft>
                mShiftBlock(-1)
            when <CursorRight>
                mShiftBlock(1)
            when <Tab>
                mShiftBlock(Query(TabWidth))
            when <Shift Tab>
                mShiftBlock(-Query(TabWidth))
            when <Escape>, <Enter>, <Alt x>
                break
            when <Alt U>
                if isCursorInBlock()
                    UnMarkBlock()
                    break
                endif
        endcase
        UpdateDisplay(_REFRESH_THIS_ONLY_ | _WINDOW_REFRESH_)
    endloop
    Set(EquateEnhancedKbd, k)
    UpdateDisplay()
end

/****************************************************************************
  Search for the word at the cursor, using the value of FindOptions
 ***************************************************************************/
integer proc mFindWordAtCursor(string option)
    if Length(GetWord(1))
        AddHistoryStr(GetWord(1), _FINDHISTORY_)
        return (Find(GetWord(1), Query(FindOptions) + option))
    endif
    ExecMacro("dlgfind")
    return (TRUE)
end mFindWordAtCursor

/****************************************************************************
  Helper routine, called by FunctionList and the next/prev/Beg/End paragraph
  movement routines.

  This function returns a regular expression that can be used to find
  functions in the current source file.

  04/19/96 SEM ignore case of files for WIN32
 ***************************************************************************/
string proc GetFunctionStr()
    case Lower(CurrExt())
        when ".c", ".h"
            return (c_fun)
        when ".cpp", ".hpp"
            return (cpp_fun)
        when ".s", ".ui", ".si"
            return (sal_fun)
        when ".pas"
            return (pas_fun)
        when ".prg",".spr",".mpr",".qpr",".fmt",".frg",".lbg",".ch"
            return (xbase_fun)
        when ".bas"
            return (basic_fun)
        when ".ini"
            return (ini_fun)
    endcase
    return ("")
end

/************************************************************************
  The CompressView command.

  If called with a non-zero value, becomes the FunctionList command.
 ************************************************************************/

proc mShowFunctions()
    string expression[100]

    expression = GetFunctionStr()
    if Length(expression) == 0
        expression = "^[a-zA-Z_]"
    endif
    if not lFind(expression, 'ixv')
        Warn(expression, " not found.")
    endif
end

integer proc FindPreviousBlankLine()
    repeat
        if not Up()
            return (FALSE)
        endif
    until PosFirstNonWhite() == 0
    return (TRUE)
end

integer proc FindPreviousNonBlankLine()
    repeat
        if not Up()
            return (FALSE)
        endif
    until PosFirstNonWhite()
    return (TRUE)
end

integer proc FindNextBlankLine()
    repeat
        if not Down()
            return (FALSE)
        endif
    until PosFirstNonWhite() == 0
    return (TRUE)
end

integer proc FindNextNonBlankLine()
    repeat
        if not Down()
            return (FALSE)
        endif
    until PosFirstNonWhite()
    return (TRUE)
end

integer proc FindPara(integer previous)
    integer col = CurrCol(), cline = CurrLine()
    string opt[1], s[80] = GetFunctionStr()

    if Length(s)
        if previous
            BegLine()
            opt = 'b'
        else
            EndLine()
            opt = ''
        endif
        lFind(s, "ix+" + opt)
    else    // unknown type, use line delimited chunks
        PushPosition()
        if previous
            Up()
            repeat until PosFirstNonWhite() or not Up()
            repeat until not Up() or PosFirstNonWhite() == 0
            if PosFirstNonWhite() == 0
                Down()
            endif
            if PosFirstNonWhite()
                KillPosition()
            else
                PopPosition()
            endif
        else
            if (PosFirstNonWhite() == 0 or FindNextBlankLine())
                    and FindNextNonBlankLine()
                KillPosition()
            else
                PopPosition()
            endif
        endif
    endif
    GotoColumn(col)
    return (CurrLine() <> cline)
end

integer proc mPrevPara()
    return (FindPara(TRUE))
end

integer proc mNextPara()
    return (FindPara(FALSE))
end

proc mBegPara()
    integer cline, pline

    cline = CurrLine()
    mPrevPara()
    pline = CurrLine()
    mNextPara()
    if cline <> CurrLine()
        GotoLine(pline)
    endif
end

proc mEndPara()
    integer cline = CurrLine()

    if mNextPara()
        FindPreviousBlankLine()
        FindPreviousNonBlankLine()
    else
        EndFile()
        repeat until CurrLine() <= cline or PosFirstNonWhite() or not Up()
    endif
end

proc mMarkPara()
    PushPosition()
    Unmarkblock()
    mBegPara()
    MarkLine()
    mEndPara()
    MarkLine()
    PopPosition()
end

string proc RecentFilesStr()
    return (LoadDir() + "tsefiles.dat")
end

// Create the recent files buffer, if needed
// BOOL Return
integer proc GotoRecentFilesBuffer()
    if not GotoBufferId(recent_files)
        recent_files = iif(Query(PersistentRecentFiles),
                EditBuffer(RecentFilesStr(), _SYSTEM_, -1),
                CreateTempBuffer())
    endif
    return (recent_files)
end

string proc GetRecentFilesId()
    integer curr = GetBufferId()
    GotoRecentFilesBuffer()
    GotoBufferId(curr)
    return (Str(recent_files))
end

/****************************************************************************
  Swap the current line with the next line.
 ***************************************************************************/
proc mSwapLines()
    integer km, y = CurrRow()

    if Down()
        km = Set(KillMax, 1)
        DelLine()
        Up()
        UnDelete()
        Set(KillMax, km)
        ScrollToRow(y)
    endif
end

proc mCompileCurrFile()
    ExecMacro("Compile " + QuotePath(CurrFilename()))
end

proc mDebugCurrFile()
    ExecMacro("debug " + QuotePath(CurrFilename()))
end

/*************************************************************************
   External macro support.
 *************************************************************************/
menu ExecLoadPurge()
    Title = "Macro Menu"
    Width = 16

    "&Execute..."   , ExecMacro("dlgmcc")
    "&Load..."      , ExecMacro("dlgopen -l")
    "&Purge..."     , ExecMacro("dlgmcc")
    "&Compile"      , mCompileCurrFile()
    "&Debug..."     , mDebugCurrFile()
end

proc mSendFormFeed()
    if not PrintChar(chr(12))
        warn("Error sending formfeed")
    endif
end

proc mSendInitString()
    string s[60] = Query(PrintInit)
    integer i

    for i = 1 to Length(s)
        if not PrintChar(s[i])
            break
        endif
    endfor
end

proc mDateTimeStamp()
    InsertText(GetDateStr(), _INSERT_)
    InsertText(" ", _INSERT_)
    InsertText(GetTimeStr(), _INSERT_)
end

proc mOpenFileAndWindow()
    if EditFile()
        PrevFile()
        HWindow()
    endif
end

proc mCloseFileAndWindow()
    if QuitFile()
        CloseWindow()
    endif
end

/****************************************************************************
  Commands augmented by macros:
 ***************************************************************************/

// Augment delchar by joining lines if at or passed eol
integer proc mDelChar()
    return(iif(CurrChar() >= 0, DelChar(), JoinLine()))
end

// Augment BegFile by maintaining the current column if a column block is open
proc mBegFile()
    integer col = CurrCol(), xoff = CurrXoffset()

    BegFile()
    if Query(Marking) and isBlockInCurrFile() == _COLUMN_
        GotoColumn(col)
        GotoXoffset(xoff)
    endif
end

// Augment EndFile by maintaining the current column if a column block is open
proc mEndFile()
    integer col = CurrCol(), xoff = CurrXoffset()

    EndFile()
    if Query(Marking) and isBlockInCurrFile() == _COLUMN_
        GotoColumn(col)
        GotoXoffset(xoff)
    endif
end

constant WORDCASE  = 1, LINECASE = 2, BLOCKCASE = 3
constant UPPER_CASE = 0, LOWER_CASE = 1, FLIP_CASE = 2, CAP_CASE = 3

integer casetype

// Assume type is always one of WORDCASE, LINECASE or BLOCKCASE.
proc ChangeCase(integer type)
    PushBlock()
    if type <> BLOCKCASE
        UnMarkBlock()
        if type == LINECASE
            MarkLine()
        elseif not MarkWord()
            goto done
        endif
    elseif not isCursorInBlock()
        goto done
    endif
    case casetype
        when UPPER_CASE
            Upper()
        when LOWER_CASE
            Lower()
        when FLIP_CASE
            Flip()
        otherwise
            ExecMacro("capital")
    endcase
    done:

    PopBlock()
end

menu CaseMenu()
    Command = ChangeCase(MenuOption())

    "&Word at Cursor"   // if the order of these options is changed,
    "Current &Line"     // Change to order of the constants
    "&Block"            // WORDCASE, LINECASE, and BLOCKCASE
end

proc mUpper()
    casetype = UPPER_CASE
    CaseMenu("Upper Case")
end

proc mLower()
    casetype = LOWER_CASE
    CaseMenu("Lower Case")
end

proc mFlip()
    casetype = FLIP_CASE
    CaseMenu("Flip Case")
end

proc mCapital()
    casetype = CAP_CASE
    CaseMenu("Capitalize")
end

integer proc mSaveSettings()
    if YesNo("Overwrite existing config?") == 1
        return (iif(SaveSettings(), TRUE, Warn("Error updating executable")))
    endif
    return (FALSE)
end

proc mHelpOnWordAtCursor()
    string word[64]

    word = Trim(GetText(CurrPos(), sizeof(word)))
    PushPosition()
    if isWord() or lFind(ident_set, "xcb") or lFind(ident_set, "xc+")
        word = GetWord(TRUE)
    endif
    PopPosition()
    Help(word, TRUE)
end

integer proc misTemplateLoaded()
    return (isMacroLoaded(TEMPLATE))
end

proc mToggleTemplateExpand()
    if isMacroLoaded(TEMPLATE)
        PurgeMacro(TEMPLATE)
    else
        LoadMacro(TEMPLATE)
    endif
end

proc ToggleHexEdit()
    if HexEdit(TRUE)
        HexEdit(FALSE)
    endif
end

proc mFancyTabRight()
    if DisplayMode() == _DISPLAY_HEX_
        ToggleHexEdit()
    else
        TabRight()
    endif
end

proc mToggleAutoIndent()
    if Query(AutoIndent)
        save_autoindent = Set(AutoIndent, OFF)
    else
        if save_autoindent == OFF
            save_autoindent = ON
        endif
        Set(AutoIndent, save_autoindent)
    endif
end

proc mToggleWordWrap()
    if Query(WordWrap)
        save_wordwrap = Set(WordWrap, OFF)
    else
        if save_wordwrap == OFF
            save_wordwrap = ON
        endif
        Set(WordWrap, save_wordwrap)
    endif
end

proc AddToTop(string s, integer max_count)
    if lFind(s, "^$ig")
        KillLine()
    elseif NumLines() >= max_count
        EndFile()
        KillLine()
    endif
    BegFile()
    InsertLine(s)
end

/****************************************************************************
  TSE-called macros, including:

  WhenLoaded
  Main
  Hooked functions
 ***************************************************************************/
// This is a hooked macro
// Be careful not to add files without names!
// 04/19/96 SEM ignore case of files for WIN32
proc AfterUpdateDisplay()
    string fn[MAXPATH] = CurrFilename()
    integer cid = GetBufferId()
    Unhook(AfterUpdateDisplay)
    if Length(fn) and BufferType() == _NORMAL_
        if GotoRecentFilesBuffer()
            AddToTop(fn, Query(MaxRecentFiles))
        endif
        GotoBufferId(cid)
    endif
end

/****************************************************************************
  This macro is called everytime EditFile() or Next/PrevFile() is called.

  This is a hooked macro.

  04/19/96 SEM ignore case of files for WIN32
 ***************************************************************************/
proc OnChangingFiles()
    // For 'RecentFiles' processing, only show files that are displayed
    Hook(_AFTER_UPDATE_DISPLAY_, AFterUpdateDisplay)
    language = FALSE
    cmode = FALSE
    case Lower(CurrExt())
        when ".ui",".s", ".si", ".asm",".pas",".inc",".prg", ".bas"
            language = TRUE
        when ".c",".h",".cpp",".hpp"
            language = TRUE
            cmode = TRUE
    endcase
end

proc AsciiChart()
    PushPosition()
    ExecMacro("dlgascii -x")
    PopPosition()
    PushKeyStr(Query(MacroCmdLine))
end

keydef AdditionalKeys
    <Ctrl A>    AsciiChart()
end

// This is a hooked macro
proc OnPromptStartup()
    Enable(AdditionalKeys)
end

/****************************************************************************
  This macro is called the first time a file is loaded into the editor.

  This is a hooked macro
 ***************************************************************************/
proc OnFirstEdit()
end

// This is a hooked macro
proc MaybeAutoWrap()
    integer line

    if Query(WordWrap) > ON
        line = CurrLine()
        PushPosition()
        EndLine()
        if Abs(CurrCol() - Query(RightMargin)) > 1
            WrapPara()
        endif
        PopPosition()
        GotoXoffset(0)
        if line <> CurrLine() and CurrLine() < Query(WindowRows) / 2
            ScrollUp()
        endif
    endif
end

// called on delchar/bs/drw/dlw
// This is a hooked macro
proc OnDelChar()
    MaybeAutoWrap()
end

// Called on each char insert.
// This is a hooked macro
proc OnSelfInsert()
    if Query(WordWrap) == ON and CurrCol() > Query(RightMargin) + 1
        WrapLine()
    else
        MaybeAutoWrap()
    endif
end

// This macro is automatically called by TSE just before the _ON_ABANDON_EDITOR_
// hook is called.
proc WhenPurged()
    PushPosition()
    if Query(PersistentRecentFiles) and GotoBufferId(recent_files) and NumLines()
        SaveAs(RecentFilesStr(), _OVERWRITE_ | _DONT_PROMPT_)
    endif
    PopPosition()
end

/****************************************************************************
  This macro is automatically called by TSE just after the editor has
  initialized all necessary processes and managers.

  Minimally, this macro should call EditFile() if the command line is empty,
  or EditFile(Query(DosCmdLine)) if the command line is non-empty.

  Many additional 'startup' tasks should be performed here.

  The following are performed in this version:

  - The initial video mode is set
  - The signon screen is displayed
  - TSEStart is executed
  - The autoload macros are loaded
  - Various events are hooked
  - If the output of a command has been piped to us, load it as a file
  - Process the DOS command line, by calling EditFile
  - If the DOS command line is empty, use the StartupFlags editor variable
    to determine what to do
 ***************************************************************************/
menu StartupMenu()
    history

    "&Open...",         ExecMacro("dlgopen")
    "&New File",        NewFile()
    "&File Manager...", ExecMacro("f *.*")
    "List &Recent...",  ExecMacro("dlgrcnt "+GetRecentFilesId())
    "&Pick File...",    ExecMacro("dlgopen")
    "Restore &State",   ExecMacro("state -r -q")
    "&Where",           ExecMacro("where")
    "E&xit",            AbandonEditor()
end

proc WhenLoaded()
    string s[MAXPATH]
    integer new_handle

    Set(CurrVideoMode, Query(StartupVideoMode))
    SignOn()

    LoadStartupMacros()                         // tsestart and autoload macros

#ifdef WIN32
    if Query(TemplateExpansion) and misTemplateLoaded() == FALSE
        LoadMacro(TEMPLATE)
    endif
#endif

    // Hook the events we want to get control of
    Hook(_ON_CHANGING_FILES_,   OnChangingFiles)
    Hook(_ON_FIRST_EDIT_,       OnFirstEdit)
    Hook(_PROMPT_STARTUP_,      OnPromptStartup)
    Hook(_ON_SELFINSERT_,       OnSelfInsert)
    Hook(_ON_DELCHAR_,          OnDelChar)

    // See if input is redirected, if so, read it in as a file
    if isCharDevice(_STDIN_) == FALSE and CreateBuffer("")
        fReadFile(_STDIN_)
        BegFile()
        ChangeCurrFilename("[<stdin>]", _DONT_EXPAND_)      // call ON_FIRST_EDIT and ON_CHANGING_FILES hooks

        new_handle = fOpen(CONSOLE, _OPEN_READWRITE_)
        fDup2(new_handle, _STDIN_)
        fClose(new_handle)
    endif

    // Finally, process the command line
    s = Query(DosCmdLine)
    if Length(s)
        if FileExists(s) & _DIRECTORY_ and s <> "*.*"
            ChDir(s)
            LogDrive(s[1])
        else
            AddHistoryStr(s, _EDIT_HISTORY_)
            EditFile(s, _FROM_CMDLINE_)
        endif
    elseif NumFiles() == 0
        case Query(StartupFlags)
            when _STARTUP_RESTORESTATE_
                ExecMacro("state -r -q")
            when _STARTUP_FILEMGR_
                ExecMacro("f *.*")
            when _STARTUP_UNNAMED_
                NewFile()
            when _STARTUP_RECENTFILES_
                ExecMacro("dlgrcnt "+GetRecentFilesId())
//
// don't need this one, let it fall through
//
//              when _STARTUP_PICKLIST_
//                  EditFile("-a- *.*")
//
            when 0 //_STARTUP_MENU_
                repeat
                    Set(X1, (Query(ScreenCols) / 2) - 13)
                    Set(Y1, (Query(ScreenRows) / 2) -  5)
                    StartupMenu()
                until MenuOption() == 0 or NumFiles()
                return ()
        endcase
    endif

    // _STARTUP_PROMPT_ case and error loading specified file cases come here
    if NumFiles() == 0
        ExecMacro("dlgopen")
    endif
end

/****************************************************************************
   This macro is called just after the first file is loaded, but before the
   user is given control, and before any hook functions are called.
 ***************************************************************************/
proc Main()
end

/****************************************************************************
  TSE Pull-down Menus
 ***************************************************************************/

menu FileMenu()
    history

    "&Open..."                      ,   ExecMacro("dlgopen")
    "&Insert..."                    ,   ExecMacro("dlgopen -i")
    "&File Manager..."              ,   ExecMacro("f *.*")
    ""                              ,                       ,   Divide
    "&Next"                         ,   NextFile()
    "&Previous"                     ,   PrevFile()
    "Lis&t Open..."                 ,   ExecMacro("dlgbuff "+GetRecentFilesId())
    "List &Recent..."               ,   ExecMacro("dlgrcnt "+GetRecentFilesId())
    "Current File"                  ,                       ,   Divide
    "&Save"                         ,   SaveFile()
    "Save &As..."                   ,   ExecMacro("dlgopen -s")
    "Save && C&lose"                ,   SaveAndQuitFile()
    "&Close"                        ,   QuitFile()
/***********************************************************************
 removed DiK 10-08-95

    "Chan&ge Name..."               ,   ChangeCurrFilename()
***********************************************************************/
    "S&how File Info"               ,   ExecMacro("fileinfo")
    "All Files"                     ,                       ,   Divide
    "Sa&ve All"                     ,   SaveAllFiles()
    "Save All && &Exit"             ,   SaveAllAndExit()
    "E&xit"                         ,   Exit()
end

menu ClipMenu()
    history

    "Cu&t"              ,   Cut()
    "C&ut Append"       ,   Cut(_APPEND_)
    "&Copy"             ,   Copy()
    "Cop&y Append"      ,   Copy(_APPEND_)
    ""                  ,                       , Divide
    "&Paste"            ,   Paste()
    "Paste &Over"       ,   Paste(_OVERWRITE_)
    ""                  ,                       , Divide
    "Copy to Windows Clip&board",    CopyToWinClip()
    "P&aste from Windows Clipboard", PasteFromWinClip()
    ""                  ,                       , Divide
    "&Named ClipBoards  ", ExecMacro("nameclip"),DontClose
end

menu WindowMenu()
    history

    "&Horizontal"           ,   HWindow()
    "&Vertical"             ,   VWindow()
    "&Resize..."            ,   ResizeWindow()
    "&Go to..."             ,   GotoWindow()
    "&Zoom"                 ,   ZoomWindow()
    "&One"                  ,   OneWindow()
    "&Close..."             ,   CloseWindow()
    ""                          ,                       , Divide
    "Open &File && Window"  ,   mOpenFileAndWindow()
    "Close File && &Window" ,   mCloseFileAndWindow()
    ""                          ,                       , Divide
    "&Toggle Sync Scrolling",  ExecMacro("synchscr")
end

menu BlockMenu()
    history

    "Mark &Line"                ,   MarkLine()
    "Mark Ch&aracter"           ,   MarkStream()
    "Mar&k Column"              ,   MarkColumn()
    "Mark to &EOL"              ,   MarkToEOL()
    "Mark Para&graph"           ,   mMarkPara()
    "&UnMark"                   ,   UnMarkBlock()
    ""                          ,                       , Divide
    "&Copy"                     ,   CopyBlock()
    "&Move"                     ,   MoveBlock()
    "&Shift..."                 ,   mShift()
    "&Write to File..."         ,   ExecMacro("dlgopen -b")
    "&Fill..."                  ,   FillBlock()
    "&Delete"                   ,   DelBlock()
    ""                          ,                       , Divide
    "U&pper  "                 ,   mUpper()            , DontClose
    "Lowe&r  "                 ,   mLower()            , DontClose
    "Fl&ip   "                 ,   mFlip()             , DontClose
    "Capitali&ze  "            ,   mCapital()          , DontClose
end

menu SearchMenu()
    history

    "&Find..."                      ,   ExecMacro("dlgfind")
    "&Replace..."                   ,   ExecMacro("dlgrplc")
    "&Again"                        ,   repeatfind()
    "Find and &Do..."               ,   ExecMacro("dlgfnddo")
    ""                              ,                       , Divide
    "Find &Word at Cursor"          ,   mFindWordAtCursor('+')
    "&Incremental Search..."        ,   ExecMacro("isrch")
    "&Match"                        ,   ExecMacro("match")
    ""                              ,                       , Divide
    "Compressed &View..."           ,   ExecMacro("dlgfind -v")
    "F&unction List..."             ,   mShowFunctions()
    "R&edisplay View PickList"      ,   ViewFinds()
    ""                              ,                       , Divide
    "&Place Bookmark..."            ,   placemark()
    "&Go to Bookmark..."            ,   gotomark()
    ""                              ,                       , Divide
    "Go to &Line..."                ,   ExecMacro("dlggoto")
    "Go to &Column..."              ,   ExecMacro("dlggoto -c")
end

menu PrintMenu()
    history

    "&File"                 ,   PrintFile()
    "&Block"                ,   PrintBlock()
    "&Send Formfeed"        ,   mSendFormFeed()
    "Send &Init String"     ,   mSendInitString(), DontClose
    "Set &Options  "       ,   ExecMacro("Iconfig PrintConfig"), DontClose
end PrintMenu

menu MacroMenu()
    Title = "Keyboard Macros"
    history

    "&Record Key Macro..."          ,   RecordKeyMacro()
    "&Save Key Macro..."            ,   ExecMacro("dlgopen -v")
    "Load &Key Macro..."            ,   ExecMacro("dlgopen -k")
    "Run Scrap &Macro"              ,   ExecScrapMacro()
    "Pur&ge Key Macro"              ,   PurgeKeyMacro()
    "Compiled Macros"               ,                   ,   Divide
    "&Execute..."                   ,   ExecMacro("dlgmcc")
    "&Load..."                      ,   ExecMacro("dlgopen -l")
    "&Purge..."                     ,   ExecMacro("dlgmcc")
    "&Compile"                      ,   mCompileCurrfile()
    "&Debug..."                     ,   mDebugCurrfile()
    "&AutoLoad List"                ,   EditAutoLoadList()
end

menu TextMenu()
    history

    "&Add Line (below)"         ,   AddLine()
    "&Insert Line (above)"      ,   InsertLine()
    "D&up Line"                 ,   DupLine()
    "&Join Line"                ,   JoinLine()
    "Spli&t Line"               ,   SplitLine()
    "&Swap Lines"               ,   mSwapLines()
    ""                          ,                   ,   Divide
    "&Delete Line"              ,   DelLine()
    "Delete to &End of Line"    ,   DelToEol()
    "Delete Right &Word"        ,   DelRightWord()
    ""                          ,                   ,   Divide
    "&Global UnDelete"          ,   GlobalUnDelete()
    "&Local UnDelete"           ,   UnDelete()
    "Paste U&nDelete"           ,   PasteUnDelete()
    "&Restore Cursor Line"      ,   RestoreCursorLine()
    ""                          ,                   ,   Divide
    "Wrap &Paragraph"           ,   ExecMacro("wrappara")
    "&Center Line"              ,   ExecMacro("center")
    "&Quote/Comment Line"       ,   ExecMacro("quote comment")
end

menu UtilMenu()
    history

    "&Line Drawing" [OnOffStr(Query(LineDrawing)):3], Toggle(LineDrawing), DontClose
    "Li&ne Type  "         ,   LineTypeMenu()      ,   DontClose
    ""                          ,                   ,   Divide
    "&Sort"                 ,   ExecMacro("sort " + Str(sort_flags))
    "Sort &Order"   [ShowSortFlag() : 10], ToggleSortFlag(_DESCENDING_), DontClose
    "&Case-Sensitive Sort" [OnOffStr((sort_flags & _IGNORE_CASE_) == 0):3], ToggleSortFlag(_IGNORE_CASE_), DontClose
    ""                          ,                   ,   Divide
    "S&pell Check  "       ,   ExecMacro("SpellChk")
    "&ASCII Chart..."       ,   ExecMacro("dlgascii")
    "&Date/Time Stamp"      ,   mDateTimeStamp()
    "S&hell"                ,   Shell()
    "Captu&re OS Output"    ,   ExecMacro("Capture")
    "Potpo&urri..."         ,   ExecMacro("Potpourr")
    ""                          ,                   ,   Divide
    "Change &Video Mode..." ,   ExecMacro("dlgvideo")
    "He&x View" [OnOffStr(DisplayMode() == _DISPLAY_HEX_):3],
            DisplayMode(iif(DisplayMode() == _DISPLAY_TEXT_, _DISPLAY_HEX_, _DISPLAY_TEXT_))

    "&Template Expansion" [OnOffStr(misTemplateLoaded()):3], mToggleTemplateExpand(), DontClose
end

menu AutoIndentMenu()
    command = Set(AutoIndent, MenuOption() - 1)
    history = query(AutoIndent) + 1

    "O&ff"      ,, CloseBefore
    "O&n"       ,, CloseBefore
    "&Sticky"   ,, CloseBefore
end

menu WordWrapMenu()
    command = Set(WordWrap, MenuOption() - 1)
    history = Query(WordWrap) + 1

    "O&ff"      ,, CloseBefore
    "O&n"       ,, CloseBefore
    "&Auto"     ,, CloseBefore
end

menu SaveStateMenu()
    command = Set(SaveState, MenuOption() - 1)
    history = Query(SaveState) + 1

    "O&ff"                                  ,, CloseBefore
    "O&n    (Saved in loaddir)"             ,, CloseBefore
    "&Local (Saved in current directory)"   ,, CloseBefore
end

menu TabTypeMenu()
    history = query(tabtype) + 1
    command = Set(TabType,MenuOption()-1)

    "&Hard"     ,, CloseBefore
    "&Soft"     ,, CloseBefore
    "Smar&t"    ,, CloseBefore
    "&Variable" ,, CloseBefore
end

menu OptionsMenu()
    history

    "&AutoIndent"           [MenuStr(AutoIndentMenu,query(AutoIndent)+1) : 6],
                            AutoIndentMenu()            ,   DontClose
    "&WordWrap"             [MenuStr(WordWrapMenu,query(WordWrap)+1) : 4],
                            WordWrapMenu()            ,   DontClose
    "&Right Margin"         [query(RightMargin) : 5],
                            set(RightMargin, ReadNum(Query(RightMargin))),   DontClose
    "&Left Margin"          [query(LeftMargin) : 5],
                            set(LeftMargin, ReadNum(Query(LeftMargin))),   DontClose
    ""                          ,                   ,   Divide
    "Tab Ty&pe"             [MenuStr(TabTypeMenu,query(TabType)+1) : 8],
                            TabTypeMenu()               ,   DontClose
    "&Tab Width"            [query(TabWidth) : 5],
                            set(TabWidth, ReadNum(Query(TabWidth))),   DontClose
    ""                          ,                   ,   Divide
    "&Backups"              [OnOffStr(Query(MakeBackups)) : 3],
                            Toggle(MakeBackups)         ,   DontClose
    "Save State on &Exit"   [SubStr(MenuStr(SaveStateMenu,query(SaveState)+1), 1, 5) : 5],
                            SaveStateMenu()            ,   DontClose
    ""                          ,                   ,   Divide
    "&Full Configuration  ",          ExecMacro("iconfig"),DontClose
    "&Save Current Settings  ",       mSaveSettings()
end

proc mAbout()
    integer save_attr, cursor

    cursor = Set(Cursor, OFF)
    save_attr = Query(TextAttr)
    Set(TextAttr, ((save_attr & 0x70) shr 4) | ((save_attr & 0x07) shl 4))
    SignOn()
    GetKey()
    Set(TextAttr, save_attr)
    Set(Cursor, cursor)
    UpdateDisplay(_ALL_WINDOWS_REFRESH_)
end

menu HelpMenu()
    history

    "Table of &Contents" ,   Help()
    "&Key Assignments"   ,   Help("Key Assignments")
    "&Index"             ,   Help("Index")
    "&Word at Cursor"    ,   mHelpOnWordAtCursor()
    "&Previous Topic"    ,   PrevHelp()
    "&Search"            ,   SearchHelp()
    "&About..."          ,   mAbout()
end

menubar MainMenu()
    history

    "&File"    ,    FileMenu()
    "&Block"   ,    BlockMenu()
    "&Text"    ,    TextMenu()
    "&Search"  ,    SearchMenu()
    "&Window"  ,    WindowMenu()
    "&Clip"    ,    ClipMenu()
    "&Macro"   ,    MacroMenu()
    "&Print"   ,    PrintMenu()
    "&Util"    ,    UtilMenu()
    "&Options" ,    OptionsMenu()
    "&Help"    ,    HelpMenu()
end

// Mouse functions:

menu MouseMenu()
   Title="Mouse Menu"
   "Cu&t",                           Cut()
   "&Copy",                          Copy()
   "&Paste",                         Paste()
   "Paste &Over",                    Paste(_OVERWRITE_)
   "&UnMark",                        UnmarkBlock()
      ""                          ,                   ,   Divide
   "Copy to Windows Clip&board",     CopyToWinClip()
   "P&aste from Windows Clipboard",  PasteFromWinClip()
      ""                          ,                   ,   Divide
   "Cop&y Block",                    CopyBlock()
   "Copy O&ver Block",               CopyBlock(_OVERWRITE_)
   "&Move Block",                    MoveBlock()
   "&Delete Block",                  DelBlock()
      ""                          ,                   ,   Divide
   "&Fill Block",                    FillBlock()
   "&Sort",                          ExecMacro("sort " + Str(sort_flags))
      ""                          ,                   ,   Divide
   "Uppe&r   ",                     mUpper()
   "&Lower   ",                     mLower()
   "Fl&ip    ",                     mFlip()
   "Capitali&ze"              ,   mCapital()          , DontClose
end

proc mLeftBtn()
    if not ProcessHotSpot()
       MainMenu()
    endif
end

proc mTrackMouseCursor()
    if GotoMouseCursor()
        TrackMouseCursor()
    endif
end

//*** Key-assignment Help screen ********************************************
helpdef KeyAssignments
    title = "Key Assignments"
    x = 10

    "Begin/End Line                        Home/End"
    "Begin/End Window                      Ctrl Home/End"
    "Begin/End File                        Ctrl PgUp/Dn"
    ""
    "Word Right/Left                       Ctrl CursorRight/Left"
    "Roll Up/Down                          Ctrl CursorUp/Down"
    ""
    "Scroll Up/Down                        Ctrl W/Z"
    ""
    "Previous Position                     Ctrl QP"
    ""
    "Go to Begin/End Block                 Ctrl [ / Ctrl ]"
    ""
    "Place Bookmark 1..0                   Ctrl K1..K0"
    "Go to Bookmark 1..0                   Ctrl Q1..Q0"
    ""
    "Go to Window 1..9                     Alt 1..9"
    ""
    "Find Word at Cursor - Backward        Ctrl ="
    "Find Word at Cursor - Global          Ctrl \"
    ""
    "File SubMenu                          Alt F"
    "Text SubMenu                          Alt T"
    ""
    "MarkWord                              Ctrl KT"
    "MarkChar (exclude cursor position)    Alt I"
    ""
    "Toggle LineDraw                       Ctrl V"
    "Toggle AutoIndent                     Ctrl QI"
    "Toggle WordWrap                       Ctrl OW"
    ""
    "Copy Char Above                       Ctrl -"
    "Copy Char Above To EOL                Alt -"
    "Insert Next Char Literally            Ctrl P"
    "Delete Left Word                      Ctrl Backspace"
    "Overlay Column Block                  Alt Z"
    ""
    "Repeat Command                        Ctrl QQ"
    ""
    "Erase Current File from Disk          Ctrl KZ"
    ""
    "Named ClipBoard Menu                  Ctrl B"
end

//
// Keyboard bindings...
//

keydef PromptKeys
end

/****************************************************************************
  Available keys include:

    Alt Escape, Alt Enter
    Alt BackSpace
    Ctrl Ins
    Alt Tab, Ctrl Tab
    Alt [, Alt ]
    Alt h, Alt q, Alt y
    Ctrl e, Ctrl s, Ctrl h
    F3, F7, F8
    Ctrl-F3, Ctrl-F4, Ctrl-F5, Ctrl-F6, Ctrl-F8
    Alt F7, Alt F8
    Shift F2, Shift F6, Shift F9
 ***************************************************************************/

//*** HelpLine assignments **************************************************

<HelpLine>        "{F1}-Help {F2}-AddLn {F4}-DupLn {F5}-ScrollTop {F6}-DelToEol {F9}-Shell {F10}-Menu"
<Alt HelpLine>    "{Alt: F2}-InsLn {F3}-Match {F4}-Lower {F5}-RollLt {F6}-RollRt {F9}-Dos {F10}-ShowEntry"
<Ctrl HelpLine>   "{Ctrl: F1}-HelpWord {F2}-SwapLns {F7}-Shift {F9}-Compile {F10}-MacroMenu"
<Shift HelpLine>  "{Shift: F1}-Keys {F3}-Sort {F4}-Upper {F5}-ScrollCtr {F7}-ShiftLt {F8}-ShiftRt {F10}-Potpourri"

//*** Cursor Movement commands **********************************************

<CursorUp>              Up()
<CursorDown>            Down()
<Ctrl CursorUp>         RollUp()
<Ctrl CursorDown>       RollDown()

<CursorLeft>            Left()
<CursorRight>           Right()
<Ctrl CursorLeft>       Wordleft()
<Ctrl CursorRight>      Wordright()

<Home>                  BegLine()
<End>                   EndLine()
<Ctrl Home>             BegWindow()
<Ctrl End>              EndWindow()

<PgUp>                  PageUp()
<PgDn>                  PageDown()
<Ctrl PgUp>             mBegFile()
<Ctrl PgDn>             mEndFile()

<Shift PgUp>            mPrevPara()
<Shift PgDn>            mNextPara()

<Shift F5>              ScrollToCenter()
<F5>                    ScrollToTop()
<Ctrl z>                Scrolldown()
<Ctrl w>                Scrollup()

<Alt F5>                RollLeft()
<Alt F6>                RollRight()

<Ctrl q><p>             PrevPosition()

//*** Text editing commands *************************************************

<Alt t>                 MainMenu('T')      // Bring up Text SubMenu

<F2>                    AddLine()
<Alt F2>                InsertLine()
<Ctrl n>                InsertLine()
<F4>                    DupLine()

<Ctrl p>                Literal()
<Ctrl ->                mCopyCharAbove()
<Alt ->                 mCopyCharAboveToEol()

<BackSpace>             mBackSpace()
<Del>                   mDelChar()
<Ctrl BackSpace>        DelLeftWord()
<Ctrl Del>              DelRightWord()
<Ctrl t>                DelRightWord()
<Alt Del>               DelToEol()
<F6>                    DelToEol()
<Alt d>                 DelLine()
<Ctrl d>                DelLine()
<Ctrl y>                DelLine()

<Enter>                 mCreturn()
<Alt s>                 SplitLine()
<Alt j>                 JoinLine()

<Shift Tab>             TabLeft()
<Tab>                   mFancyTabRight()

<Shift F7>              mShiftBlock(SHIFTLEFT)
<Shift F8>              mShiftBlock(SHIFTRIGHT)

<Shift F3>              ExecMacro("sort " + Str(sort_flags))
<Ctrl F2>               mSwapLines()

<Alt F4>                mLower()
<Shift F4>              mUpper()

<Ctrl o><t>             ExecMacro("center")
<Alt b>                 ExecMacro("wrappara")

<Ctrl q><l>             RestoreCursorLine()
<Ctrl u>                GlobalunDelete()

<Ctrl 8>                ExecMacro("quote comment")

//*** Block commands ********************************************************

<Grey+>                 Copy()
<CtrlShift Grey+>       CopyToWinClip()

<Grey->                 Cut()

#ifdef WIN32
<Ctrl Grey+>            CopyAppend()
<Ctrl Grey->            CutAppend()
#else
<Ctrl Grey+>            Copy(_APPEND_)
<Ctrl Grey->            Cut(_APPEND_)
#endif

<Grey*>                 Paste()
<Ctrl Grey*>            Paste(_OVERWRITE_)
<Ctrl PrtSc>            Paste(_OVERWRITE_)
<CtrlShift Grey*>       PasteFromWinClip()

<Ctrl [>                Gotoblockbegin()
<Ctrl ]>                Gotoblockend()

<Alt a>                 MarkStream()
<Alt i>                 MarkChar()
<Alt k>                 MarkColumn()
<Alt l>                 MarkLine()
<Ctrl k><t>             MarkWord()
<Alt y>                 MarkToEOL()
<Alt u>                 UnmarkBlock()

<Alt c>                 CopyBlock()
<Alt z>                 CopyBlock(_OVERWRITE_)
<Alt m>                 MoveBlock()
<Alt g>                 DelBlock()

<Alt w>                 ExecMacro("dlgopen -b")
<Ctrl k><l>             FillBlock()
<Ctrl F7>               mShift()        // Block/Text shifting

<Ctrl b>                ExecMacro("nameclip Named ClipBoards")

//*** Window commands *******************************************************

// Alt 1..9 goto the numbered window

<Alt 1>                 GotoWindow(1)
<Alt 2>                 GotoWindow(2)
<Alt 3>                 GotoWindow(3)
<Alt 4>                 GotoWindow(4)
<Alt 5>                 GotoWindow(5)
<Alt 6>                 GotoWindow(6)
<Alt 7>                 GotoWindow(7)
<Alt 8>                 GotoWindow(8)
<Alt 9>                 GotoWindow(9)

<Ctrl o><c>             CloseWindow()
<Ctrl o><d>             DelWindow()
<Ctrl o><g>             GotoWindow()
<Ctrl o><h>             HWindow()
<Ctrl o><n>             NextWindow()
<Ctrl o><o>             OneWindow()
<Ctrl o><p>             PrevWindow()
<Ctrl o><r>             ResizeWindow()
<Ctrl o><v>             VWindow()
<Ctrl o><z>             ZoomWindow()
<Ctrl o><y>             ExecMacro("synchscr")

//*** BookMark commands *****************************************************

<Ctrl 6>                GotoMark()
<Ctrl 2>                PlaceMark()

<Ctrl q><0>             GotoMark("q")
<Ctrl q><1>             GotoMark("r")
<Ctrl q><2>             GotoMark("s")
<Ctrl q><3>             GotoMark("t")
<Ctrl q><4>             GotoMark("u")
<Ctrl q><5>             GotoMark("v")
<Ctrl q><6>             GotoMark("w")
<Ctrl q><7>             GotoMark("x")
<Ctrl q><8>             GotoMark("y")
<Ctrl q><9>             GotoMark("z")

<Ctrl k><0>             PlaceMark("q")
<Ctrl k><1>             PlaceMark("r")
<Ctrl k><2>             PlaceMark("s")
<Ctrl k><3>             PlaceMark("t")
<Ctrl k><4>             PlaceMark("u")
<Ctrl k><5>             PlaceMark("v")
<Ctrl k><6>             PlaceMark("w")
<Ctrl k><7>             PlaceMark("x")
<Ctrl k><8>             PlaceMark("y")
<Ctrl k><9>             PlaceMark("z")

//*** Find/Replace commands *************************************************

<Ctrl f>                ExecMacro("dlgfind")
<CtrlShift f>           Find()
<Ctrl i>                ExecMacro("isrch")
<Ctrl l>                Repeatfind()
<CtrlShift l>           RepeatFind(_REVERSE_)
<Ctrl r>                ExecMacro("dlgrplc")
<CtrlShift r>           Replace()

<Alt =>                 mFindWordAtCursor('+')
<Ctrl =>                mFindWordAtCursor('b')
<Ctrl \>                mFindWordAtCursor('g')

<Alt v>                 ExecMacro("dlgfind -v")
<AltShift v>            ViewFinds()
<Ctrl g>                mShowFunctions()
<Ctrl c>                ExecMacro("dlggoto -c")
<Ctrl j>                ExecMacro("dlggoto")
<CtrlShift c>           GotoColumn()
<CtrlShift j>           GotoLine()

<Alt F3>                ExecMacro("match")

//*** Macro commands ********************************************************

<Ctrl Enter>            ExecScrapMacro()
<Ctrl m>                RecordKeyMacro()

<Ctrl x>                ExecMacro("dlgmcc")     // Execute SAL macro
<CtrlShift x>           ExecMacro()             // Execute SAL macro
<Ctrl F10>              ExecLoadPurge() // Macro (SAL) manipulation

<Ctrl F9>               ExecMacro("Compile " + CurrFilename())
<Shift F9>              ExecMacro("Compile -m")

//*** File commands *********************************************************

<Alt f>                 MainMenu('F')  // Bring up the FileMenu

<Alt e>                 ExecMacro("dlgopen")

<Alt n>                 Nextfile()
<Alt p>                 Prevfile()

<Alt 0>                 ExecMacro("dlgbuff "+GetRecentFilesId())
<Ctrl 0>                ExecMacro("dlgrcnt "+GetRecentFilesId())

<Alt r>                 ExecMacro("dlgopen -i")
<Alt o>                 ChangeCurrFilename()
<Ctrl k><z>             Killfile()

<Ctrl k><q>             QuitFile()
<Ctrl k><s>             SaveFile()
<Ctrl k><x>             SaveAndQuitFile()

<Alt x>                 Exit()

//*** Other commands ********************************************************

<F10>                   MainMenu()
<Escape>                MainMenu()

<F1>                    Help()
<Ctrl F1>               mHelpOnWordAtCursor()
<Alt F1>                PrevHelp()
<Shift F1>              Help("Key Assignments")

<Ctrl a>                ExecMacro("dlgascii")
<Alt F10>               ShowEntryScreen()

<Ins>                   Toggleinsert()
<Ctrl o><w>             mToggleWordWrap()
<Ctrl q><i>             mToggleAutoIndent()
<Ctrl v>                Toggle(LineDrawing)

#ifdef WIN32
<}>                     mCloseBrace()
#else
<Shift ]>               mCloseBrace()
#endif

<Ctrl q><Ctrl q>        RepeatCmd()

<AltShift F9>           ExecMacro("Capture")
<Alt F9>                Dos()
<F9>                    Shell()
<F12>                   ExecMacro("SpellChk")

<Shift F10>             ExecMacro("Potpourr")

<CtrlAlt SpaceBar>      lVersion()

//*** Mouse keys ************************************************************

<LeftBtn>               mLeftBtn()
<Ctrl LeftBtn>          MouseMarking(_COLUMN_)
<Alt LeftBtn>           MouseMarking(_LINE_)
<Shift LeftBtn>         mTrackMouseCursor()
<RightBtn>              MouseMenu()

