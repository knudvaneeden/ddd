/****************************************************************************\

    DlgOp16W.SI

    Enhanced OpenFile command (16-bit).

    Overview:

    This macro implements EditFile as a Windows 95 style dialog box. It
    allows you to load and save files using long names while running TSE
    in a DOS session in Windows 95. See on-line help for a more detailed
    description.

    Keys:
            <none>

    Command Line Format:

    DlgOpen [-s|-i|-b] [-f] [-n]

    where:

        none    EditFile
        -s      SaveFileAs
        -i      InsertBlock
        -b      SaveBlock
        -f      list only files (don't list folders)
        -n      list only names (don't list file date/time and file size)

    Version         v2.10/30.11.00
    Copyright       (c) 1996-2000 by DiK

    History

    v2.10/30.11.00  adaption to TSE32 v3.0
                    þ centered dialogs and help
                    þ use DlgMsgText variable
                    þ fixed handling of context menu
                    þ fixed handling BackSpace in file list
                    þ fixed size of files history
                    þ fixed size of types list
                    þ fixed "files only" flag
                    þ fixed error messages
                    þ fixed help screens
    v2.02/07.01.99  optimization
                    þ optimized usage of macro stack
    v2.01/02.04.97  adaption to TSE32
                    þ use FixedList message
    v2.00/24.10.96  adaption to TSE32
                    þ used to be DlgWOpen
    v1.01/29.05.96  maintenance
                    þ adaption to version 1.21 of dialogs
                    þ fixed: return to current dir, if canceled
    v1.00/08.05.96  first release

    Limitations

    DlgOpW95 uses SAL strings to store path names, e.g. the longest path it
    can handle is 254 characters long. On the other hand, Windows 95 allows
    path names which are up to 260 characters long. This means you MUST NOT
    use path names which exceed the limit imposed by DlgOpW95 or the macro
    will fail utterly most probably hanging TSE. The dialog library imposes
    another limit yet. The maximum length of the text within an edit control
    is 128 characters which limits the size of filenames.

    Using DlgOpW95 as "Save File As" closes the current file and re-opens
    it with its new name. The reason for this is that ChangeCurrFilename()
    doesn't work properly within the context of long filenames.

\****************************************************************************/

/****************************************************************************\
    use global variable DlgMsgText
\****************************************************************************/

#define INC_MSGTEXT 1

/****************************************************************************\
    mode constants
\****************************************************************************/

constant MODE_OPEN      =  0
constant MODE_SAVEAS    =  1
constant MODE_INSERT    =  2
constant MODE_SAVEBLOCK =  3

/****************************************************************************\
    event constants
\****************************************************************************/

constant KEY_HELP       =  0xFFE0
constant KEY_OPTS       =  0xFFE1
constant KEY_DIRUP      =  0xFFE2
constant KEY_DIRNEW     =  0xFFE3
constant KEY_DEL        =  0xFFE4
constant KEY_REN        =  0xFFE5

/****************************************************************************\
    global constants
\****************************************************************************/

#include "dialog.si"
#include "msgbox.si"
#include "dlgop32a.si"
#include "dlgop32b.si"

/****************************************************************************\
    dialog resource
\****************************************************************************/

#include "dlgop32a.dlg"
#include "dlgop32b.dlg"

/****************************************************************************\
    shared code
\****************************************************************************/

#include "scver.si"
#include "scrun.si"
#include "schelp.si"

/****************************************************************************\
    predefined file types
\****************************************************************************/

#include "scoptyp1.si"

/****************************************************************************\
    global varibales
\****************************************************************************/

integer resource                        // buffer id (dialog resource)
integer filebuff                        // ditto (name list)
integer dirsbuff                        // ditto (dir list)
integer typebuff                        // ditto (ext list)
integer tempbuff                        // ditto (temp storage)

integer dirty                           // ditto (options changed)
integer mode = MODE_OPEN                // ditto (mode of operation)

integer chk_bin                         // check (load binary)
integer chk_hex                         // ditto (display as hex list)
integer chk_chdir                       // ditto (change dir after load)
integer chk_wild                        // ditto (load wild from inside)

integer chk_noinfo                      // check (don't list additional info)
integer chk_nodirs                      // ditto (don't list directories)

string dir[255]                         // saved directory (global)
string dir1[255]                        // saved directory (folder combo)
string file[255] = "*.*"                // file name

/****************************************************************************\
    forward definitions
\****************************************************************************/

forward proc IdCmbTypes( integer paint )

/****************************************************************************\
    help screens
\****************************************************************************/

constant HLP_WIDTH = 80

helpdef DlgOpenHelp
    title = "Help on Open File Dialog"
    width = HLP_WIDTH
    height = 23
    y = 1

    ""
    " This dialog is used to load and save files."
    ""
    " Summary of commands:"
    ""
    " Ok          load or save the specified file"
    " Cancel      close the dialog box"
    ""
    "            go to parent directory (BackSpace)"
    "            insert a new folder (Ins)"
    " +           open options dialog (Ctrl Tab)"
    ""
    " To quickly load a file enter its name and press <Enter>. Alternatively, you"
    " can back-tab to the file list and select a file to be opened. If you enter"
    " an incomplete filename (a name that contains * and ?), the file list will be"
    " rescanned and will thereafter display only those entries in the current"
    " directory which match your wildcard specification. You can also use the"
    " Types drop down list to choose from some predefined file types to narrow"
    " your search. Names entered into the filename field can include full or"
    " partial paths and a drive letter."
    ""
    " Changing directories and drives:"
    ""
    " On default the dialog displays the contents of the current folder. If you"
    " want to open a file in some other folder, enter its name and press <Enter>."
    " The dialog will then display the contents of the specified folder."
    " Alternatively, you can tab to the folder drop down list and choose one of"
    " the listed folders. To expand the tree at a different branch right click"
    " the respective folder or type <enter>. Use <ctrl enter> to close the list"
    " and go to the chosen folder."
    ""
    " File management:"
    ""
    " The files list allows for a limited amount of file management. You can"
    " delete and rename files and insert new folders. To access the file"
    " management commands right click an item within the list box or press"
    " Shift-F10."
    " "
    " Open      edit file (same as Ok)"
    " View      view file without loading it"
    " Load      load file without closing dialog"
    " Sort      sort file list (name, type, date or size)"
    " Delete    delete current file (Del)"
    " Rename    rename current file"
    ""
end

helpdef DlgOpenOptsHelp
    title = "Help on Open File Dialog Options"
    width = HLP_WIDTH
    height = 23
    y = 1

    ""
    " This dialog is used to set additional options while loading or saving files."
    ""
    " Summary of commands:"
    ""
    " Ok          accept options"
    " Cancel      cancel changes"
    " List Drive  re-scan available drives (cancels changes)"
    " Curr Dir    return to the current directory (cancels changes)"
    " "
    " Display Format:"
    " "
    " These check boxes determine the kind of information displayed within the"
    " files list box. You can use the command line arguments -n and/or -f to check"
    " these switches at startup."
    " "
    " Names Only      do not display file creation date/time and file size"
    " Files Only      do not display folders, display files only"
    " "
    " File Loading Option:"
    " "
    " Some or all of the additional check boxes may be greyed. This means that"
    " these options are meaningless within the current context and thus not"
    " available."
    " "
    " Binary          load file in binary mode"
    " Hex Edit        switch to hex display after file is loaded"
    " Change Folder   make the directory which contains the file the current one"
    " Load Wild       do not narrow down file list, but load all matching files"
    ""
end

/****************************************************************************\
  ú binary module
\****************************************************************************/

binary "listfile.bin"
    integer proc NewFindFirst(
        string wild: cstrval,
        integer attr: word, string dta, string name )           : 0
    integer proc NewFindNext( string dta, string name )         : 3
    proc NewFindClose()                                         : 6
end

/****************************************************************************\
    list contents of current directory
\****************************************************************************/

proc ListFiles()
    integer bid
    integer attr
    string buff[23] = " "
    string info[50]
    string name[254] = ""

    // determine attributes

    bid = GotoBufferId(filebuff)
    attr = _READONLY_
    if not chk_nodirs
        attr = attr | _DIRECTORY_
    endif

    // find file names

    EmptyBuffer()
    if NewFindFirst(file,attr,buff,name)
        repeat
            if name <> "."
                AddLine(buff)
                GotoPos(24)
                if CurrChar(2) & _DIRECTORY_
                    InsertText(Chr(0))
                else
                    InsertText(Chr(1))
                endif
                InsertText(name)
            endif
        until not NewFindNext(buff,name)
    else
        return()
    endif
    NewFindClose()

    // sort pick buffer (_PICKSORT_ doesn't sort long filename field)

    MarkColumn(1,25,NumLines(),104)
    Sort(_IGNORE_CASE_)
    MarkColumn(1,24,NumLines(),24)
    Sort()

    // format list of filenames

    EndFile()
    repeat
        BegLine()
        info = DecodePickBuffer(GetText(1,23))
        info = Format(
            info[26:8],
            "  ",
            info[35:5],
            "  ",
            info[16:9],
            "  "
        )
        name = GetText(25,CurrLineLen()-24)
        KillToEol()
        if not chk_noinfo
            InsertText(info)
        endif
        InsertText(name)
    until not Up()

    // return to resource buffer

    GotoBufferId(bid)
end

/****************************************************************************\
    directory functions

    REMARK:
    this is sound, since maximum path size (minus name) is 246
\****************************************************************************/

string proc GetDirEx()
    register r
    integer len
    integer pntr
    string _name[255]

    _name = GetDrive() + ":\"
    pntr = Addr(_name)

    r.ax = 0x7147
    r.dx = 0
    r.si = LoWord(pntr+5)
    r.ds = HiWord(pntr)
    Intr(0x21,r)

    PokeByte(pntr,255)
    len = Pos(Chr(0),_name)
    PokeByte(pntr,len-1)

    return(_name)
end

integer proc SetDirEx( string name )
    register r
    integer pntr
    string _name[255]

    _name = name + Chr(0)
    pntr = Addr(_name)

    r.ax = 0x713B
    r.dx = LoWord(pntr+2)
    r.ds = HiWord(pntr)
    Intr(0x21,r)

    return (not (r.flags & _flCARRY_))
end

integer proc MakeDirEx( string name )
    register r
    integer pntr
    string _name[255]

    _name = name + Chr(0)
    pntr = Addr(_name)

    r.ax = 0x7139
    r.dx = LoWord(pntr+2)
    r.ds = HiWord(pntr)
    Intr(0x21,r)

    return (not (r.flags & _flCARRY_))
end

integer proc RemoveDirEx( string name )
    register r
    integer pntr
    string _name[255]

    _name = name + Chr(0)
    pntr = Addr(_name)

    r.ax = 0x713A
    r.dx = LoWord(pntr+2)
    r.ds = HiWord(pntr)
    Intr(0x21,r)

    return (not (r.flags & _flCARRY_))
end

/****************************************************************************\
    file management functions

    REMARK:
    these functions will fail, if the long name is 255 characters plus
\****************************************************************************/

integer proc fOpenEx( string name )
    register r
    integer pntr
    string _name[255]

    _name = name + Chr(0)
    pntr = Addr(_name)

    r.ax = 0x716C                       // Extended Create or Open File
    r.bx = _OPEN_WRITEONLY_
    r.cx = _ARCHIVE_
    r.dx = 0x0012                       // truncate or create file
    r.si = LoWord(pntr+2)
    r.ds = HiWord(pntr)
    Intr(0x21,r)

    return(iif((r.flags & _flCARRY_),0,r.ax))
end

integer proc FileExistsEx( string name )
    register r
    integer pntr
    string _name[255]

    _name = name + Chr(0)
    pntr = Addr(_name)

    r.ax = 0x7143                       // Get or Set File Attributes
    r.bx = 0                            // GetFileAttributes
    r.dx = LoWord(pntr+2)
    r.ds = HiWord(pntr)
    Intr(0x21,r)

    if r.flags & _flCARRY_
        if r.ax == 5
            return(-2)
        else
            return(-1)
        endif
    endif
    return(r.cx)
end

string proc GetPathName( string name, integer sub )
    register r
    integer len
    integer pntr_name, pntr_full
    string _name[255], _full[255] = ""

    _name = name + Chr(0)
    pntr_name = Addr(_name)
    pntr_full = Addr(_full)

    r.ax = 0x7160                       // Get Path Name
    r.cx = sub                          // sub function: long or short names
    r.si = LoWord(pntr_name+2)
    r.ds = HiWord(pntr_name)
    r.di = LoWord(pntr_full+2)
    r.es = HiWord(pntr_full)
    Intr(0x21,r)

    if r.flags & _flCARRY_
        _full = ""
    else
        PokeByte(pntr_full,255)
        len = Pos(Chr(0),_full)
        PokeByte(pntr_full,len-1)
    endif

    return(_full)
end

string proc GetShortPathName( string name )
    return(GetPathName(name,0x8001))       // subst'ed short path names
end

string proc GetLongPathName( string name )
    return(GetPathName(name,0x8002))       // subst'ed long path names
end

integer proc DeleteFileEx( string name )
    register r
    integer pntr
    string _name[255]

    _name = name + Chr(0)
    pntr = Addr(_name)

    r.ax = 0x7141                       // Delete File
    r.cx = 0
    r.si = 0                            // no wildcards
    r.dx = LoWord(pntr+2)
    r.ds = HiWord(pntr)
    Intr(0x21,r)

    return (not (r.flags & _flCARRY_))
end

integer proc RenameFileEx( string new_name )
    register r
    integer old_pntr
    integer new_pntr
    string _old_name[255]
    string _new_name[255]

    _old_name = file + Chr(0)
    _new_name = new_name + Chr(0)
    old_pntr = Addr(_old_name)
    new_pntr = Addr(_new_name)

    r.ax = 0x7156                       // Rename File
    r.dx = LoWord(old_pntr+2)
    r.ds = HiWord(old_pntr)
    r.di = LoWord(new_pntr+2)
    r.es = HiWord(new_pntr)
    Intr(0x21,r)

    return (not (r.flags & _flCARRY_))
end

/****************************************************************************\
    helper functions
\****************************************************************************/

proc GetCurrFilename()
    if chk_noinfo
        file = GetText(1,CurrLineLen())
    else
        file = GetText(29,CurrLineLen()-28)
    endif
end

proc DisplayCurrFilename( integer paint_list )
    SetGlobalStr(DlgMsgText,file)
    ExecMacro(Format("DlgSetTitleEx ",ID_EDT_NAME))
    if paint_list
        ExecMacro(Format("DlgPaintCntrl ",ID_LST_FILES))
    endif
end

integer proc IsRoot()
    return(Length(GetDirEx()) == 3)
end

proc SetFolder()
    integer bid
    string dir[255]

    bid = GotoBufferId(dirsbuff)
    EmptyBuffer()
    dir = GetDirEx()
    if dir[Length(dir)] <> "\"
        dir = GetToken(dir,"\",NumTokens(dir,"\"))
    endif
    AddLine(dir)
    GotoBufferId(bid)
    ExecMacro(Format("DlgPaintCntrl ",ID_CMB_FOLDER))
end

integer proc SetDir( string name )
    if SetDirEx(name)
        if Length(name) > 1 and name[2] == ":"
            LogDrive(name[1])
        endif
        return(TRUE)
    endif
    return(FALSE)
end

integer proc GoDir( string name )
    if SetDir(name)
        SetFolder()
        IdCmbTypes(TRUE)
        ExecMacro(Format("DlgSetEnable ",ID_BTN_DIRUP," ",not IsRoot()))
        return(TRUE)
    endif
    ExecDialog(Format(
        "MsgBox ",
        Chr(MB_OK),
        Chr(MB_ERROR),
        Chr(CNTRL_CTEXT),"Directory does not exist!"
    ))
    return(FALSE)
end

integer proc WriteFile( integer save_buffer )
    integer rc, handle

    handle = fOpenEx(file)
    rc = handle > 0
    if rc
        if save_buffer
            rc = fWriteFile(handle,_OVERWRITE_)
        endif
        fClose(handle)
    endif
    if rc
        Message("Creating new file...")
    else
        Alarm()
        ExecDialog(Format(
            "MsgBox ",
            Chr(MB_OK),
            Chr(MB_ERROR),
            Chr(CNTRL_CTEXT),"Cannot create new file!"
        ))
    endif
    return(rc)
end

/****************************************************************************\
    load file(s)
\****************************************************************************/

integer proc LoadFile()
    integer rc = TRUE
    integer attr
    string opts[16] = ""

    if chk_bin
        opts = Format("-b",iif(chk_hex,16,64)," ")
    endif

    // load existing files

    attr = FileExistsEx(file)
    if attr == 0 or attr > 0 and (attr & ~_DIRECTORY_)
        EditFile(opts+GetShortPathName(file))
        goto common_exit
    endif

    // check name of new file

    if Length(GetToken(file," +,;=[]",1)) == Length(file)
    and Length(GetToken(file,".",1)) <= 8
    and Length(GetToken(file,".",2)) <= 3
    and Length(GetToken(file,".",3)) == 0
        EditFile(opts+file)
        goto common_exit
    endif

    // this is a new, long filename, e.g. create file

    if WriteFile(FALSE)
        EditFile(opts+GetShortPathName(file))
        goto common_exit
    endif

    rc = FALSE

common_exit:

    if rc and chk_hex
        DisplayMode(_DISPLAY_HEX_)
    endif

    return(rc)
end

proc LoadWild()
    integer bid

    if chk_wild
        bid = GotoBufferId(filebuff)
        chk_nodirs = TRUE
        ListFiles()
        BegFile()
        repeat
            GetCurrFilename()
            GotoBufferId(bid)
            LoadFile()
            bid = GotoBufferId(filebuff)
        until not Down()
        GotoBufferId(bid)
    else
        LoadFile()
    endif
end

/****************************************************************************\
    save file or block
\****************************************************************************/

proc SaveFileAs()
    integer rc = TRUE
    integer attr
    integer line, col, row, xofs

    attr = FileExistsEx(file)
    if attr == 0 or attr > 0 and (attr & ~_DIRECTORY_)
        rc = YesNo("Overwrite existing file?") == 1
    endif
    if rc
        if WriteFile(TRUE)
            line = CurrLine()
            col  = CurrCol()
            row  = CurrRow()
            xofs = CurrXOffset()
            AbandonFile()
            EditFile(GetShortPathName(file))
            GotoLine(line)
            GotoColumn(col)
            ScrollToRow(row)
            GotoXOffset(xofs)
        endif
    endif
end

proc SaveBlockAs()
    integer attr

    attr = FileExistsEx(file)
    if attr == 0 or attr > 0 and (attr & ~_DIRECTORY_)
        SaveBlock(GetShortPathName(file))
    else
        if WriteFile(FALSE)
            SaveBlock(GetShortPathName(file),_OVERWRITE_)
        endif
    endif
end

/****************************************************************************\
    sub-class folder drop down list
    þ   GetSub              split directory string
    þ   GetListDir          compute chosen directory
    þ   AddSubDirs          insert sub-dirs into drop down list
    þ   ExpandThis          change current dir within drop down list
    þ   FolderKeys          additional hot keys
    þ   FolderHook          ditto
    þ   FolderComboInit     setup sub-class
    þ   FolderComboDone     cleanup (selection changed)
    þ   FolderComboClose    ditto (selection NOT changed)

    Remark: empty lines are inserted (and removed) only to prevent
            dialogs from reducing the length of the drop down list.
\****************************************************************************/

proc GetSub( var string sub, var string dir )
    integer p

    p = Pos("\",dir)
    if p == 0
        p = Length(dir) + 1
    endif
    sub = dir[1..p-1]
    dir = dir[p+1..Length(dir)]
end

string proc GetListDir()
    integer bid
    integer p
    integer level = 256
    string dir[255] = ""

    bid = GotoBufferId(dirsbuff)
    PushPosition()
    loop
        p = PosFirstNonWhite()
        if p == 1
            dir = GetText(1,2) + dir
            break
        endif
        if p < level
            level = p
            dir = "\" + GetText(p,CurrLineLen()-p+1) + dir
        endif
        Up()
    endloop
    if Length(dir) == 2
        dir = dir + "\"
    endif
    PopPosition()
    GotoBufferId(bid)
    return(dir)
end

proc AddSubDirs()
    integer rc = FALSE
    integer ilba
    integer first
    string lead[255]
    string buff[23] = " ", name[255] = ""

    first = PosFirstNonWhite()+1
    lead = Format("":first)

    GotoBufferId(tempbuff)
    EmptyBuffer()
    if NewFindFirst("*.*",_DIRECTORY_,buff,name)
        repeat
            if name[1] <> "." and (Asc(buff[2]) & _DIRECTORY_)
                rc = TRUE
                AddLine(Format(lead,name))
            endif
        until not NewFindNext(buff,name)
    endif
    NewFindClose()

    MarkColumn(1,first+1,NumLines(),first+80)
    Sort()
    MarkLine(1,NumLines())
    GotoBufferId(dirsbuff)

    if rc
        ilba = Set(InsertLineBlocksAbove,FALSE)
        MoveBlock()
        UnmarkBlock()
        Set(InsertLineBlocksAbove,ilba)
    endif
end

proc ExpandThis( integer mouse )
    integer level
    string dir[255]
    string curr[255]

    // get current dir

    if mouse
        GotoMouseCursor()
    endif
    dir = GetListDir()
    curr = GetText(1,CurrLineLen())

    // remove sub-tree and siblings

    level = PosFirstNonWhite()
    PushPosition()
    EndFile()
    repeat
        if level < PosFirstNonWhite()
        or level > 1 and level == PosFirstNonWhite()
            KillLine()
        endif
    until not Up()
    PopPosition()
    if level > 1
        InsertLine(curr)
    endif

    // add sub dirs

    if SetDir(dir)
        PushPosition()
        AddSubDirs()
        PopPosition()
    endif
end

keydef FolderKeys
    <RightBtn>      ExpandThis(TRUE)
    <Enter>         ExpandThis(FALSE)
    <Ctrl Enter>    EndProcess(TRUE)
end

proc FolderHook()
    Enable(FolderKeys)
    Unhook(FolderHook)
end

proc FolderComboInit()
    integer bid
    integer level
    string dir[255], sub[255] = ""

    // copy drive list

    ExecDialog("DriveLst")
    bid = GotoBufferId(Val(Query(MacroCmdLine)))
    MarkLine(1,NumLines())
    GotoBufferId(dirsbuff)
    EmptyBuffer()
    CopyBlock()
    UnmarkBlock()

    // add directory tree of current drive

    dir1 = GetDirEx()
    dir = dir1
    lFind(dir[1],"gi^")
    level = 0
    GetSub(sub,dir)
    while Length(dir)
        GetSub(sub,dir)
        level = level + 2
        AddLine(Format("":level,sub))
    endwhile
    AddSubDirs()

    // clean up

    GotoBufferId(bid)

    // add custom keys to drop down list

    Hook(_LIST_STARTUP_,FolderHook)
end

proc FolderComboDone()
    if GoDir(GetListDir())
        dir1 = ""
    endif
end

proc FolderComboClose()
    if Length(dir1)
        GoDir(dir1)
    endif
end

/****************************************************************************\
    sub-class files list box
    þ   ViewFile            pre-view a file
    þ   DeleteFile          delete current file
    þ   RenameFile          rename current file
    þ   ListMenu            local list menu
    þ   IdListMenu          pop up local list menu
    þ   CheckListBoxKeys    check for additional list box keys
    þ   ExecListBoxKeys     execute additional list box keys
\****************************************************************************/

proc ViewFile()
    integer fileid
    integer attr
    integer rc = TRUE
    integer bid = GetBufferId()

    fileid = GetBufferId(GetShortPathName(file))
    if fileid
        GotoBufferId(fileid)
    else
        attr = FileExistsEx(file)
        rc = attr == 0 or attr > 0 and (attr & ~_DIRECTORY_)
        rc = rc and LoadFile()
    endif

    if rc
        PushPosition()
        lList(CurrFilename(),Query(ScreenCols),
            Query(ScreenRows),_ENABLE_SEARCH_|_ENABLE_HSCROLL_)
        PopPosition()
        if fileid == 0
            AbandonFile()
        endif
    else
        Alarm()
        ExecDialog(Format(
            "MsgBox ",
            Chr(MB_OK),
            Chr(MB_ERROR),
            Chr(CNTRL_CTEXT),"Cannot load file!"
        ))
    endif

    GotoBufferId(bid)
end

proc DeleteFile()
    integer rc, bid
    integer line, row
    integer isdir

    bid = GotoBufferId(filebuff)
    row = CurrRow()
    line = CurrLine()
    isdir = FileExists(file) & _DIRECTORY_
    GotoBufferId(bid)

    ExecDialog(Format(
        "MsgBox ",
        Chr(MB_YESNO),
        Chr(MB_PROMPT),
        Chr(CNTRL_CTEXT),
        "Do you really want to ",
        iif( isdir, "remove the folder?", "delete the file?")
    ))
    if Val(Query(MacroCmdLine)) == ID_YES
        if isdir
            rc = RemoveDirEx(file)
        else
            rc = DeleteFileEx(file)
        endif
        if not rc
            Alarm()
            ExecDialog(Format(
                "MsgBox ",
                Chr(MB_OK),
                Chr(MB_ERROR),
                Chr(CNTRL_CTEXT),
                "Cannot ",
                iif( isdir, "remove folder!", "delete file!")
            ))
        endif
    endif

    IdCmbTypes(FALSE)
    bid = GotoBufferId(filebuff)
    if line > NumLines()
        line = NumLines()
    endif
    GotoLine(line)
    ScrollToRow(row)
    GetCurrFilename()
    GotoBufferId(bid)
    DisplayCurrFilename(TRUE)
end

proc RenameFile()
    integer bid, ok
    string name[255] = file

    ExecDialog(Format(
        "InpBox ",
        0,Chr(13),
        "Rename File",Chr(13),
        "Enter new filename:",Chr(13),
        name,Chr(13)
    ))
    name = Query(MacroCmdLine)
    ok = name[1] == Chr(ID_OK)
    if ok
        name = name[2..Length(name)]
        if not RenameFileEx(name)
            Alarm()
            ExecDialog(Format(
                "MsgBox ",
                Chr(MB_OK),
                Chr(MB_ERROR),
                Chr(CNTRL_CTEXT),"Cannot rename file!"
            ))
            return()
        endif
    else
        return()
    endif

    IdCmbTypes(FALSE)
    bid = GotoBufferId(filebuff)
    if lFind("  "+name+"$","gx")
        ScrollToRow(5)
    endif
    GetCurrFilename()
    GotoBufferId(bid)
    DisplayCurrFilename(TRUE)
end

menu ListMenu()
    "&Open   <Enter>",      PushKey(<Enter>)
    "",, divide
    "&Load",                LoadFile()
    "&View",                ViewFile()
    "",, divide
    "&Delete",              DeleteFile()
    "&Rename",              RenameFile()
end

proc IdListMenu( integer mouse )
    integer bid = GetBufferId()

    if Query(Key) == <RightBtn>
        Set(X1, Query(MouseX))
        Set(Y1, Query(MouseY))
    else
        Set(X1, Query(PopWinX1) + CurrChar(POS_X1))
        Set(Y1, Query(PopWinY1) + CurrChar(POS_Y1))
    endif
    ListMenu()
    GotoBufferId(bid)
    Set(Key,KEY_NOTHING)
end

integer proc CheckListBoxKeys()
    integer next_key

    case Query(Key)
        when <Del>          next_key = KEY_DEL
        when <F2>           next_key = KEY_REN
        otherwise           next_key = 0
    endcase

    if next_key
        Set(Key,KEY_BREAK)
        PushKey(next_key)
        return(FALSE)
    endif

    return(TRUE)
end

integer proc ExecListBoxKeys()
    case Query(Key)
        when KEY_DEL            DeleteFile()
        when KEY_REN            RenameFile()
        otherwise               return(TRUE)
    endcase
    return(FALSE)
end

/****************************************************************************\
    options dialog
\****************************************************************************/

public proc Op16WOptsDataInit()
    ExecMacro(Format("DlgSetData ",ID_CHK_NOINFO," ",chk_noinfo))
    ExecMacro(Format("DlgSetData ",ID_CHK_NODIRS," ",chk_nodirs))
    ExecMacro(Format("DlgSetData ",ID_CHK_BIN," ",chk_bin))
    ExecMacro(Format("DlgSetData ",ID_CHK_HEX," ",chk_hex))
    ExecMacro(Format("DlgSetData ",ID_CHK_CHDIR," ",chk_chdir))
    ExecMacro(Format("DlgSetData ",ID_CHK_LDWILD," ",chk_wild))

    if mode <> MODE_OPEN
        ExecMacro(Format("DlgSetEnable ",ID_CHK_BIN," ",0))
        ExecMacro(Format("DlgSetEnable ",ID_CHK_HEX," ",0))
        ExecMacro(Format("DlgSetEnable ",ID_CHK_LDWILD," ",0))
        if mode <> MODE_SAVEAS
            ExecMacro(Format("DlgSetEnable ",ID_CHK_CHDIR," ",0))
        endif
    endif
end

integer proc GetOpt( integer id )
    ExecMacro(Format("DlgGetData ",id))
    return(Val(Query(MacroCmdLine)))
end

public proc Op16WOptsDataDone()
    integer new_noinfo
    integer new_nodirs

    if CurrChar(POS_ID) == ID_OK
        new_noinfo = GetOpt(ID_CHK_NOINFO)
        new_nodirs = GetOpt(ID_CHK_NODIRS)
        chk_bin    = GetOpt(ID_CHK_BIN)
        chk_hex    = GetOpt(ID_CHK_HEX)
        chk_chdir  = GetOpt(ID_CHK_CHDIR)
        chk_wild   = GetOpt(ID_CHK_LDWILD)
        dirty = new_noinfo <> chk_noinfo or new_nodirs <> chk_nodirs
        chk_noinfo = new_noinfo
        chk_nodirs = new_nodirs
    endif
end

proc IdBtnDrives()
    ExecDialog("ScanDrives")
    ExecMacro("DlgTerminate")
end

public proc Op16WOptsBtnDown()
    case CurrChar(POS_ID)
        when ID_OK              ExecMacro("DlgTerminate")
        when ID_BTN_DRIVES      IdBtnDrives()
        when ID_HELP            InitHelp(HLP_WIDTH) QuickHelp(DlgOpenOptsHelp)
    endcase
end

proc IdOpts()
    integer resource
    integer rc
    integer bid
    integer line, row

    bid = GotoBufferId(filebuff)
    row = CurrRow()
    line = CurrLine()
    GotoBufferId(bid)

    dirty = FALSE
    resource = CreateTempBuffer()
    rc = resource and InsertData(dlgop32b) and ExecDialog("dialog Op16WOpts")
    GotoBufferId(bid)
    AbandonFile(resource)

    if rc
        if dirty
            SetFolder()
            IdCmbTypes(FALSE)
            bid = GotoBufferId(filebuff)
            if line > NumLines()
                line = NumLines()
            endif
            GotoLine(line)
            ScrollToRow(row)
            GetCurrFilename()
            GotoBufferId(bid)
            DisplayCurrFilename(TRUE)
        endif
    else
        Warn("DlgOpen: Error executing options dialog")
    endif
end

/****************************************************************************\
    control response functions
    þ   IdCmbTypes      set wildcard according to file type
    þ   IdLstFiles      update edit control with current filename
    þ   IdDirUp         go to parent folder
    þ   IdDirNew        make a new folder
\****************************************************************************/

proc IdCmbTypes( integer paint )
    integer bid

    bid = GotoBufferId(typebuff)
    file = "*." + RTrim(GetText(1,3))
    GotoBufferId(bid)
    ListFiles()
    if paint
        DisplayCurrFilename(TRUE)
    endif
end

proc IdLstFiles()
    integer bid

    bid = GotoBufferId(filebuff)
    GetCurrFilename()
    GotoBufferId(bid)
    DisplayCurrFilename(FALSE)
end

proc IdDirUp()
    GoDir("..")
    if IsRoot()
        ExecMacro(Format("DlgExecCntrl ",ID_LST_FILES))
    endif
end

proc IdDirNew()
    integer ok
    string dir[255] = ""

    ExecDialog(Format(
        "InpBox ",
        0,Chr(13),
        "New Folder",Chr(13),
        "Enter name of new folder:",Chr(13),
        Chr(13)
    ))
    dir = Query(MacroCmdLine)
    ok = dir[1] == Chr(ID_OK)
    if ok
        dir = dir[2..Length(dir)]
        if MakeDirEx(dir)
            GoDir(dir)
        else
            Alarm()
            ExecDialog(Format(
                "MsgBox ",
                Chr(MB_OK),
                Chr(MB_ERROR),
                Chr(CNTRL_CTEXT),"Cannot create new folder!"
            ))
        endif
    endif
end

/****************************************************************************\
    ok button
\****************************************************************************/

proc IdOk()
    integer attr
    integer tokens
    string dir[255], name[255]

    // get the specified file name

    ExecMacro(Format("DlgGetTitle ",ID_EDT_NAME))
    file = GetGlobalStr(DlgMsgText)

    // check for an empty line

    if Length(file) == 0
        ExecMacro(Format("DlgExecCntrl ",ID_EDT_NAME))
        Alarm()
        return()
    endif

    // check for wildcards and narrow down file list

    if Pos("*",file) or Pos("?",file)
        if Pos(":",file) or Pos("\",file)
            tokens = NumTokens(file,"\")
            if tokens > 1
                name = GetToken(file,"\",tokens)
                dir = SubStr(file,1,Pos(name,file)-1)
            else
                name = GetToken(file,":",2)
                dir = GetToken(file,":",1) + ":"
            endif
            file = name
            if GoDir(dir)
                file = name
                DisplayCurrFilename(FALSE)
            else
                ExecMacro(Format("DlgExecCntrl ",ID_EDT_NAME))
                return()
            endif
        endif
        if chk_wild
            ExecMacro(Format("DlgTerminate ",ID_OK))
        else
            ListFiles()
            ExecMacro(Format("DlgPaintCntrl ",ID_LST_FILES))
            ExecMacro(Format("DlgExecCntrl ",ID_EDT_NAME))
        endif
        return()
    endif

    // if the file name is a directory, let's go there

    if Length(file) == 2 and file[2] == ":"
        file = file + "."
    endif

    attr = FileExistsEx(file)
    if attr == -2 or attr > 0 and (attr & _DIRECTORY_)
        if GoDir(file)
            ExecMacro(Format("DlgExecCntrl ",ID_LST_FILES))
        else
            ExecMacro(Format("DlgExecCntrl ",ID_EDT_NAME))
        endif
        return()
    endif

    // otherwise, say bye and go home

    ExecMacro(Format("DlgTerminate ",ID_OK))
end

/****************************************************************************\
    custom hot keys
    þ   CheckHotKeys    check for custom hot key and exit secondary loops
    þ   ExecHotKeys     execute actions of custom hot keys
\****************************************************************************/

integer proc CheckHotKeys()
    integer next_key

    if LoByte(Query(Key)) == Asc("?")
        Set(Key,<Shift />)
    endif

    case Query(Key)
        when <Shift />          next_key = KEY_HELP
        when <Ctrl Tab>         next_key = KEY_OPTS
        when <Backspace>        next_key = KEY_DIRUP
        when <Ins>,<GreyIns>    next_key = KEY_DIRNEW
        otherwise               next_key = 0
    endcase

    if next_key
        if next_key <> KEY_OPTS and CurrChar(POS_ID) == ID_EDT_NAME
            return(FALSE)
        endif
        Set(Key,KEY_BREAK)
        PushKey(next_key)
        return(FALSE)
    endif

    return(TRUE)
end

integer proc ExecHotKeys()
    integer cntrl = 0

    case Query(Key)
        when KEY_OPTS       IdOpts()
        when KEY_HELP       cntrl = ID_HELP
        when KEY_DIRUP      if not IsRoot()  cntrl = ID_BTN_DIRUP  endif
        when KEY_DIRNEW     cntrl = ID_BTN_DIRNEW
        otherwise           return(TRUE)
    endcase

    if cntrl
        ExecMacro(Format("DlgExecCntrl ",cntrl))
        PushKey(<Enter>)
    endif

    return(FALSE)
end

/****************************************************************************\
    message response functions
    þ   Event           custom hot keys
    þ   AnchorList      anchor search in type and drive lists
    þ   DropDown        fill folder drop down list
    þ   CloseUp         reset folder drop down list
    þ   RightClk        activate context menu of file list
    þ   ListMenu        display context menu of file list
    þ   SetFocus        ok in dir list and open type drive lists
    þ   SelChanged      handle selection changes in file list
    þ   DblClick        double clicks within list boxes
    þ   BtnDown         push button actions
\****************************************************************************/

public proc Op16WEvent()
    integer level = Val(Query(MacroCmdLine))

    if level <= 1 and CheckHotKeys()
        if ExecHotKeys()
            if CurrChar(POS_ID) == ID_LST_FILES
                if CheckListBoxKeys()
                    ExecListBoxKeys()
                endif
            endif
        endif
    endif
end

public proc Op16WFixedList()
    if CurrChar(POS_ID) == ID_CMB_FOLDER
        Set(MacroCmdLine,"1")
    endif
end

public proc Op16WAnchorList()
    if CurrChar(POS_ID) == ID_CMB_TYPES
        Set(MacroCmdLine,"1")
    endif
end

public proc Op16WDropDown()
    string cmd[64]
    integer top, lft, wdt, hgt

    cmd = Query(MacroCmdLine)
    lft = Val(GetToken(cmd," ",1))
    top = Val(GetToken(cmd," ",2))
    wdt = Val(GetToken(cmd," ",3))
    hgt = Val(GetToken(cmd," ",4))

    case CurrChar(POS_ID)
        when ID_CMB_FOLDER
            lft = lft - 9
            wdt = wdt + 9
            hgt = Query(PopWinRows) - 9
            FolderComboInit()
        when ID_EDT_NAME
            hgt = Min(Query(PopWinRows)-9, NumHistoryItems(_EDIT_HISTORY_))
            top = top - hgt - 3
            lft = Query(PopWinX1) + 3
            wdt = Query(PopWinCols) - 8
        when ID_CMB_TYPES
            top = CurrChar(POS_Y1)
            GotoBufferId(typebuff)
            hgt = Min(12, NumLines())
            top = Query(PopWinY1) + top - hgt - 3
    endcase

    Set(MacroCmdLine, Format(lft:4, top:4, wdt:4, hgt:4))
end

public proc Op16WCloseUp()
    if CurrChar(POS_ID) == ID_CMB_FOLDER
        FolderComboClose()
    endif
end

public proc Op16WRightClk()
    if CurrChar(POS_ID) == ID_LST_FILES
        Set(MacroCmdLine,"1")
    endif
end

public proc Op16WContext()
    if CurrChar(POS_ID) == ID_LST_FILES
        IdListMenu(TRUE)
    endif
end

public proc Op16WSetFocus()
    if CurrChar(POS_ID) == ID_LST_FILES
        IdLstFiles()
    endif
end

public proc Op16WSelChanged()
    case CurrChar(POS_ID)
        when ID_LST_FILES   IdLstFiles()
        when ID_CMB_TYPES   IdCmbTypes(TRUE)
        when ID_CMB_FOLDER  FolderComboDone()
    endcase
end

public proc Op16WDblClick()
    if CurrChar(POS_ID) == ID_LST_FILES
        IdOk()
    endif
end

public proc Op16WBtnDown()
    case CurrChar(POS_ID)
        when ID_OK              IdOk()
        when ID_BTN_DIRUP       IdDirUp()
        when ID_BTN_DIRNEW      IdDirNew()
        when ID_BTN_OPTS        IdOpts()
        when ID_HELP            InitHelp(HLP_WIDTH) QuickHelp(DlgOpenHelp)
    endcase
end

/****************************************************************************\
    initialize dialog data
\****************************************************************************/

proc MoveCntrl( integer dx1, integer dy1, integer dx2, integer dy2 )
    integer x1 = CurrChar(POS_X1) + dx1
    integer y1 = CurrChar(POS_Y1) + dy1
    integer x2 = CurrChar(POS_X2) + dx2
    integer y2 = CurrChar(POS_Y2) + dy2

    ExecMacro(Format("DlgMoveCntrl",x1:4,y1:4,x2:4,y2:4))
end

proc TweakSize()
    integer delta

    delta = Query(ScreenRows) - 25
    if delta == 0
        return()
    endif

    PushPosition()
    BegFile()                           // dialog window
    MoveCntrl(0,0,0,delta)
    repeat                              // manually, b/o stack usage
        Down()
    until CurrChar(POS_ID) == ID_LST_FILES
    MoveCntrl(0,0,0,delta)
    Down()
    MoveCntrl(0,0,0,delta)
    while Down()
        MoveCntrl(0,delta,0,delta)
    endwhile
    PopPosition()
end

public proc Op16WDataInit()
    string name[255] = file

    if CheckVersion("DlgOpen",2,3)
        ExecMacro("DlgTerminate")
        return()
    endif

    if not (ExecDialog("DriveLst") and Val(Query(MacroCmdLine)))
        ExecMacro("DlgTerminate")
        return()
    endif

    TweakSize()

    file = "*.*"
    ListFiles()
    SetFolder()
    file = name

    DisplayCurrFilename(FALSE)
    ExecMacro(Format("DlgSetData ",ID_EDT_NAME," ",_EDIT_HISTORY_))
    ExecMacro(Format("DlgSetData ",ID_LST_FILES," ",filebuff))
    ExecMacro(Format("DlgSetData ",ID_CMB_TYPES," ",typebuff))
    ExecMacro(Format("DlgSetData ",ID_CMB_FOLDER," ",dirsbuff))
    ExecMacro(Format("DlgSetEnable ",ID_BTN_DIRUP," ",not IsRoot()))

    if mode <> MODE_OPEN
        case mode
            when MODE_SAVEAS
                ExecMacro("DlgSetTitle 0 Save File As")
            when MODE_INSERT
                ExecMacro("DlgSetTitle 0 Insert File As Block")
            when MODE_SAVEBLOCK
                ExecMacro("DlgSetTitle 0 Save Block To File")
        endcase
    endif

    ExecMacro(Format("DlgExecCntrl ",ID_EDT_NAME))
end

/****************************************************************************\
    retrieve dialog data
\****************************************************************************/

//  public proc Op16WDataDone()
//  end

/****************************************************************************\
    main program
\****************************************************************************/

proc Main()
    register r
    integer i, n, rc
    integer bid = GetBufferId()
    string cmd[16] = Query(MacroCmdLine)

    // check dos version

    r.ax = 0x3000                           // get dos version
    Intr(0x21,r)
    rc = LoByte(r.ax) >= 7
    if rc
        r.ax = 0x4A33                       // check for ms-dos
        Intr(0x2F,r)
        rc = r.ax == 0
        if rc
            r.ax = 0x1600                   // get windows version
            Intr(0x2F,r)
            rc = r.ax <> 0x1600 and LoByte(r.ax) < 0x80 and LoByte(r.ax) >= 4
        endif
    endif

    // check command line

    i = 1
    n = NumTokens(cmd," ")

    while rc and i <= n
        case GetToken(cmd," ",i)
            when "-s"   mode = MODE_SAVEAS
            when "-i"   mode = MODE_INSERT
            when "-b"   mode = MODE_SAVEBLOCK
            when "-n"   chk_noinfo = TRUE
            when "-f"   chk_nodirs = TRUE
            otherwise   rc = FALSE
        endcase
        i = i + 1
    endwhile

    // call old dialog, if old dos, dos mode or unknown option

    if not rc
        ExecDialog("dlgop16d "+Query(MacroCmdLine))
        PurgeMacro(CurrMacroFilename())
        return()
    endif

    // init global vars

    PushBlock()
    dir = GetDirEx()
    chk_wild = Query(LoadWildFromInside)
    chk_chdir = Query(PickFileChangesDir)
    file = GetLongPathName(CurrFilename())
    file = GetToken(file,"\",NumTokens(file,"\"))

    // allocate work space and exec dialog

    filebuff = CreateTempBuffer()
    dirsbuff = CreateTempBuffer()
    tempbuff = CreateTempBuffer()
    typebuff = CreateTempBuffer()

    if filebuff and dirsbuff and tempbuff and typebuff
        rc = InsertData(FileTypes)
        if rc
            resource = CreateTempBuffer()
            rc = resource
                and InsertData(dlgop32a) and ExecDialog("dialog Op16W")
        endif
    endif

    GotoBufferId(bid)
    PopBlock()

    // check return code and open/save file

    if rc
        rc = Val(Query(MacroCmdLine)) == ID_OK
    else
        Warn("DlgOpW95: Error executing open dialog")
    endif

    if rc
        AddHistoryStr(file,_EDIT_HISTORY_)
        case mode
            when MODE_OPEN          LoadWild()
            when MODE_SAVEAS        SaveFileAs()
            when MODE_INSERT        InsertFile(GetShortPathName(file))
            when MODE_SAVEBLOCK     SaveBlockAs()
        endcase
    endif

    if not (rc and chk_chdir)
        SetDir(dir)
    endif

    // clear work space

    AbandonFile(resource)
    AbandonFile(typebuff)
    AbandonFile(tempbuff)
    AbandonFile(dirsbuff)
    AbandonFile(filebuff)

    // purge self

    PurgeMacro(CurrMacroFilename())
    UpdateDisplay(_HELPLINE_REFRESH_)
end

