/****************************************************************************\

    DlgOp32W.SI

    Enhanced OpenFile command (32-bit).

    Overview:

    This macro implements EditFile as a Windows 95 style dialog box. It
    allows you to load and save files using long names while running TSE
    in a DOS session in Windows 95. See on-line help for a more detailed
    description.

    Keys:
            <none>

    Command Line Format:

    DlgOpen  [-s|-i|-b|-e|-l|-k|-v|-d|-r|-c|-y|-p|-j]
             [-o[n|e|d|s]   [-f] [-n] [-t] [-x]

    where:

        none    EditFile
        -s      SaveFileAs
        -i      InsertBlock
        -b      SaveBlock
        -e      ExecMacro
        -l      LoadMacro
        -k      LoadKeyMacro
        -v      SaveKeyMacro
        -d      DeCompKeyMacro
        -r      ReCompKeyMacro
        -c      CompileDialog
        -y      DisplayResource
        -p      LoadProject
        -j      SaveProject
        -o      sort order: Name, Extension, Date, Size
        -f      list only files (don't list folders)
        -n      list only names (don't list file date/time and file size)
        -t      file must exist
        -x      do nothing, but return result

    Version         v2.21/19.11.03
    Copyright       (c) 1995-2003 by DiK

    History

    v2.21/19.11.03  adaption to TSE32 v4.2
                    + fixed painting oem characters
    v2.20/25.02.02  adaption to TSE32 v4.0
                    + fixed oem characters in resource
    v2.10/12.03.01  adaption to TSE32 v3.0
                    + centered dialogs and help
                    + added DlgMsgText variable
                    + added refresh command
                    + added goto desktop command
                    + added goto desktop from root folder
                    + added datatype for TSE session
                    + fixed handling of context menu
                    + fixed handling BackSpace in file list
                    + fixed adding history entries
                    + fixed case of filenames
                    + fixed handling of unc paths
                    + fixed sorting (hilite position)
                    + fixed size of files history
                    + fixed size of types list
                    + fixed "files only" flag
                    + fixed main program logic
    v2.02/07.01.99  optimization
                    + optimized usage of macro stack
    v2.01/16.12.97  adaption to TSE32
                    + use FixedList message
                    + fixed syntax hilighting in view
    v2.00/24.10.96  adaption to TSE32
                    + used to be DlgWOpen
                    + added missing functionality
                    + fixed quoting long filenames
                    + re-write using sal and kernel32 functions
    v1.01/17.05.96  maintenance
                    + adaption to version 1.21 of dialogs
    v1.00/08.05.96  first release

\****************************************************************************/

/****************************************************************************\
    use global variable DlgMsgText
\****************************************************************************/

#define INC_MSGTEXT 1

/****************************************************************************\
    mode constants
\****************************************************************************/

constant MODE_OPEN      =  0
constant MODE_SAVEAS    =  1
constant MODE_INSERT    =  2
constant MODE_SAVEBLOCK =  3
constant MODE_EXECMACRO =  4
constant MODE_LOADMACRO =  5
constant MODE_LOADKEY   =  6
constant MODE_SAVEKEY   =  7
constant MODE_DECOMP    =  8
constant MODE_RECOMP    =  9
constant MODE_DIALOG    = 10
constant MODE_RESOURCE  = 11
constant MODE_LOADPROJ  = 12
constant MODE_SAVEPROJ  = 13

/****************************************************************************\
    event constants
\****************************************************************************/

constant KEY_HELP       =  0xFFE0
constant KEY_OPTS       =  0xFFE1
constant KEY_DIRUP      =  0xFFE2
constant KEY_DIRNEW     =  0xFFE3
constant KEY_DEL        =  0xFFE4
constant KEY_REN        =  0xFFE5
constant KEY_REFRESH    =  0xFFE6

/****************************************************************************\
    global constants
\****************************************************************************/

#include "dialog.si"
#include "msgbox.si"
#include "dlgop32a.si"
#include "dlgop32b.si"

/****************************************************************************\
    dialog resource
\****************************************************************************/

#include "dlgop32a.dlg"
#include "dlgop32b.dlg"

/****************************************************************************\
    shared code
\****************************************************************************/

#include "scver.si"
#include "scrun.si"
#include "sctoken.si"
#include "schelp.si"
#include "scgtfldr.si"

/****************************************************************************\
    predefined file types
\****************************************************************************/

#include "scoptyp1.si"
#include "scoptyp2.si"

/****************************************************************************\
    global varibales
\****************************************************************************/

integer resource                        // buffer id (dialog resource)
integer filebuff                        // ditto (name list)
integer dirsbuff                        // ditto (dir list)
integer typebuff                        // ditto (ext list)
integer tempbuff                        // ditto (temp storage)

integer dirty                           // flag (options changed)
integer must_exist                      // ditto (file must exist)
integer mode = MODE_OPEN                // ditto (mode of operation)

integer hist = _EDIT_HISTORY_           // history used in name field

integer chk_bin                         // check (load binary)
integer chk_hex                         // ditto (display as hex list)
integer chk_chdir                       // ditto (change dir after load)
integer chk_wild                        // ditto (load wild from inside)

integer chk_noinfo                      // check (don't list additional info)
integer chk_nodirs                      // ditto (don't list directories)

integer sort_desc                       // sort descending
string sort_order[4] = "f"              // pick buffer sort order

string dir[255]                         // saved directory (global)
string dir1[255]                        // saved directory (folder combo)
string file[255] = "*.*"                // file name

/****************************************************************************\
    external definitions
\****************************************************************************/

DLL "<kernel32.dll>"

    integer proc CreateDirectory(
        string  lpPathName : CStrVal,
        integer dont_use_it
    )                                           : "CreateDirectoryA"

    integer proc RemoveDirectory(
        string  lpszDir : CStrVal
    )                                           : "RemoveDirectoryA"

end

/****************************************************************************\
    forward definitions
\****************************************************************************/

forward proc IdCmbTypes( integer paint )

/****************************************************************************\
    help screens
\****************************************************************************/

constant HLP_WIDTH = 80

helpdef DlgOpenHelp
    title = "Help on Open File Dialog"
    width = HLP_WIDTH
    height = 23
    y = 1

    ""
    " This dialog is used to load and save files."
    ""
    " Summary of commands:"
    ""
    " Ok          load or save the specified file"
    " Cancel      close the dialog box"
    ""
    " <           go to parent directory (BackSpace)"
    " *           insert a new folder (Ins)"
    " +           open options dialog (Ctrl Tab)"
    ""
    " To quickly load a file enter its name and press <Enter>. Alternatively, you"
    " can back-tab to the file list and select a file to be opened. If you enter"
    " an incomplete filename (a name that contains * and ?), the file list will be"
    " rescanned and will thereafter display only those entries in the current"
    " directory which match your wildcard specification. You can also use the"
    " Types drop down list to choose from some predefined file types to narrow"
    " your search. Names entered into the filename field can include full or"
    " partial paths and a drive letter."
    ""
    " Changing directories and drives:"
    ""
    " On default the dialog displays the contents of the current folder. If you"
    " want to open a file in some other folder, enter its name and press <Enter>."
    " The dialog will then display the contents of the specified folder."
    " Alternatively, you can tab to the folder drop down list and choose one of"
    " the listed folders. To expand the tree at a different branch right click"
    " the respective folder or type <enter>. Use <ctrl enter> to close the list"
    " and go to the chosen folder."
    ""
    " File management:"
    ""
    " The files list allows for a limited amount of file management. You can"
    " delete and rename files and insert new folders. To access the file"
    " management commands right click an item within the list box or press"
    " Shift-F10."
    " "
    " Open        edit file (same as Ok)"
    " View        view file without loading it"
    " Load        load file without closing dialog"
    " Delete      delete current file (Del)"
    " Rename      rename current file (F2)"
    " Refresh     refresh the file list (F5)"
    " Desktop     display the windows desktop"
    " Documents   display the My Documents folder"
    " Current     display the current folder"
    " Sort        sort file list (name, type, date or size)"
    ""
end

helpdef DlgOpenOptsHelp
    title = "Help on Open File Dialog Options"
    width = HLP_WIDTH
    height = 23
    y = 1

    ""
    " This dialog is used to set additional options while loading or saving files."
    ""
    " Summary of commands:"
    ""
    " Ok          accept options"
    " Cancel      cancel changes"
    " List Drive  re-scan available drives (cancels changes)"
    " "
    " Display Format:"
    " "
    " These check boxes determine the kind of information displayed within the"
    " files list box. You can use the command line arguments -n and/or -f to check"
    " these switches at startup."
    " "
    " Names Only      do not display file creation date/time and file size"
    " Files Only      do not display folders, display files only"
    " "
    " File Loading Option:"
    " "
    " Some or all of the additional check boxes may be greyed. This means that"
    " these options are meaningless within the current context and thus not"
    " available."
    " "
    " Binary          load file in binary mode"
    " Hex Edit        switch to hex display after file is loaded"
    " Change Folder   make the directory which contains the file the current one"
    " Load Wild       do not narrow down file list, but load all matching files"
    ""
end

/****************************************************************************\
    helper functions
\****************************************************************************/

proc GetCurrFilename()
    if chk_noinfo
        file = GetText(1,CurrLineLen())
    else
        file = GetText(29,CurrLineLen()-28)
    endif
end

proc DisplayCurrFilename( integer paint_list )
    SetGlobalStr(DlgMsgText,file)
    ExecMacro(Format("DlgSetTitleEx ",ID_EDT_NAME))
    if paint_list
        ExecMacro(Format("DlgPaintCntrl ",ID_LST_FILES))
    endif
end

integer proc IsRoot()
    return(Length(CurrDir()) == 3)
end

proc SetFolder()
    integer bid
    string dir[255]

    bid = GotoBufferId(dirsbuff)
    EmptyBuffer()
    dir = CurrDir()
    dir = GetToken(dir,"\",NumTokens(dir,"\"))
    AddLine(dir)
    GotoBufferId(bid)
    ExecMacro(Format("DlgPaintCntrl ",ID_CMB_FOLDER))
end

integer proc GoDir( string name )
    if ChDir(name)
        SetFolder()
        IdCmbTypes(TRUE)
        return(TRUE)
    endif
    ExecDialog(Format(
        "MsgBox ",
        Chr(MB_OK),
        Chr(MB_ERROR),
        Chr(CNTRL_CTEXT),"Directory does not exist!"
    ))
    return(FALSE)
end

proc GoMacDir( string ext )
    string name[255]

    name = SearchPath(ext,".")
    if Length(name) == 0
        name = SearchPath("*.mac",LoadDir()+"mac;"+Query(TsePath))
        if Length(name)
            ChDir(SplitPath(name,_DRIVE_|_PATH_))
        endif
    endif
end

proc GoKbdDir( string ext )
    string name[255]

    name = SearchPath(ext,".")
    if Length(name) == 0
        name = SearchPath("*.kbd",Query(KbdPath))
        if Length(name)
            ChDir(SplitPath(name,_DRIVE_|_PATH_))
        endif
    endif
end

/****************************************************************************\
    list contents of current directory
\****************************************************************************/

proc MakePickBuffer( string name, integer force_dirs )
    string pfso[6]
    integer pff
    integer attr

    if chk_nodirs and not force_dirs
        pff = _NONE_
        attr = _READONLY_
    else
        pff = _ADD_DIRS_|_DIRS_AT_TOP_
        attr = _READONLY_|_DIRECTORY_
    endif

    pfso = Set(PickFileSortOrder,sort_order)
    pff = Set(PickFileFlags,pff)
    EmptyBuffer()
    BuildPickBufferEx(name,attr)
    Sort(_PICKSORT_)
    Set(PickFileSortOrder,pfso)
    Set(PickFileFlags,pff)
end

proc ListFiles()
    integer bid
    string info[32]
    string name[255]

    // scan current directory

    bid = GotoBufferId(filebuff)
    EmptyBuffer()
    MakePickBuffer(file,FALSE)

    // format the pick list

    info = ""
    if NumLines()
        EndFile()
        repeat
            name = PBName()
            if not chk_noinfo
                info = Format(
                    PBDateStr(), "  ",
                    SubStr(PBTimeStr(),1,5), "  ",
                    iif( PBAttribute() & _DIRECTORY_,
                        "<DIR>",
                        Str(PBSize()) ):9, "  "
                )
            endif
            BegLine()
            KillToEol()
            InsertText(info)
            InsertText(name)
        until not Up()
    endif

    // return to resource buffer

    GotoBufferId(bid)
end

/****************************************************************************\
    sub-class folder drop down list
    +   GetSub              split directory string
    +   GetListDir          compute chosen directory
    +   AddSubDirs          insert sub-dirs into drop down list
    +   ExpandThis          change current dir within drop down list
    +   FolderKeys          additional hot keys
    +   FolderHook          ditto
    +   FolderComboInit     setup sub-class
    +   FolderComboDone     cleanup (selection changed)
    +   FolderComboClose    ditto (selection NOT changed)

    Remark: empty lines are inserted (and removed) only to prevent
            dialogs from reducing the length of the drop down list.
\****************************************************************************/

proc GetSub( var string sub, var string dir )
    integer p

    p = Pos("\",dir)
    if p == 0
        p = Length(dir) + 1
    endif
    sub = dir[1..p-1]
    dir = dir[p+1..Length(dir)]
end

string proc GetListDir()
    integer bid
    integer p
    integer level = 256
    string dir[255] = ""

    bid = GotoBufferId(dirsbuff)
    PushPosition()
    loop
        p = PosFirstNonWhite()
        if p == 1
            if CurrChar(1) == Asc("\")
                dir = GetText(1,CurrLineLen()) + dir
            else
                dir = GetText(1,2) + dir
            endif
            break
        endif
        if p < level
            level = p
            dir = "\" + GetText(p,CurrLineLen()-p+1) + dir
        endif
        Up()
    endloop
    if Length(dir) == 2
        dir = dir + "\"
    endif
    PopPosition()
    GotoBufferId(bid)
    return(dir)
end

proc AddSubDirs()
    integer rc = FALSE
    integer ilba
    string lead[255]
    string name[255]

    lead = Format("":PosFirstNonWhite()+1)

    GotoBufferId(tempbuff)
    MakePickBuffer("*.*",TRUE)

    BegFile()
    while CurrLine() <= NumLines()
        name = PBName()
        if name[1] <> "." and (PBAttribute() & _DIRECTORY_)
            rc = TRUE
            InsertLine(Format(lead,name))
            Down()
        endif
        KillLine()
    endwhile

    MarkLine(1,NumLines())
    GotoBufferId(dirsbuff)

    if rc
        ilba = Set(InsertLineBlocksAbove,FALSE)
        MoveBlock()
        UnmarkBlock()
        Set(InsertLineBlocksAbove,ilba)
    endif
end

proc ExpandThis( integer mouse )
    integer level
    string dir[255]
    string curr[255]

    // get current dir

    if mouse
        GotoMouseCursor()
    endif
    dir = GetListDir()
    curr = GetText(1,CurrLineLen())

    // remove sub-tree and siblings

    level = PosFirstNonWhite()
    PushPosition()
    EndFile()
    repeat
        if level < PosFirstNonWhite()
        or level > 1 and level == PosFirstNonWhite()
            KillLine()
        endif
    until not Up()
    PopPosition()
    if level > 1
        InsertLine(curr)
    endif

    // add sub dirs

    if ChDir(dir)
        PushPosition()
        AddSubDirs()
        PopPosition()
    endif
end

keydef FolderKeys
    <RightBtn>      ExpandThis(TRUE)
    <Enter>         ExpandThis(FALSE)
    <Ctrl Enter>    EndProcess(TRUE)
end

proc FolderHook()
    Enable(FolderKeys)
    Unhook(FolderHook)
end

proc FolderComboInit()
    integer bid
    integer level
    string dir[255], sub[255] = ""

    // copy drive list

    ExecDialog("DriveLst")
    bid = GotoBufferId(Val(Query(MacroCmdLine)))
    MarkLine(1,NumLines())
    GotoBufferId(dirsbuff)
    EmptyBuffer()
    CopyBlock()
    UnmarkBlock()

    // add directory tree of current drive

    dir1 = CurrDir()
    dir = dir1
    if lFind(dir[1],"gi^")
        GetSub(sub,dir)                 // drive
    else
        GetSub(sub,dir)                 // unc-folder
        GetSub(sub,dir)
        GetSub(sub,dir)
        AddLine(Format("\\",sub))
        GetSub(sub,dir)
        EndLine()
        InsertText(Format("\",sub))
    endif
    level = 0
    while Length(dir)
        GetSub(sub,dir)
        level = level + 2
        AddLine(Format("":level,sub))
    endwhile
    AddSubDirs()

    // clean up

    GotoBufferId(bid)

    // add custom keys to drop down list

    Hook(_LIST_STARTUP_,FolderHook)
end

proc FolderComboDone()
    if GoDir(GetListDir())
        dir1 = ""
    endif
end

proc FolderComboClose()
    if Length(dir1)
        GoDir(dir1)
    endif
end

/****************************************************************************\
    sub-class files list box
    +   LoadFile            load file without closing dialog
    +   ViewFile            pre-view a file
    +   DeleteFile          delete current file
    +   RenameFile          rename current file
    +   SetSortOrder        change sort order
    +   SortMenu            sub menu
    +   ListMenu            local list menu
    +   IdListMenu          pop up local list menu
    +   CheckListBoxKeys    check for additional list box keys
    +   ExecListBoxKeys     execute additional list box keys
\****************************************************************************/

proc LoadFile()
    integer attr
    integer bid = GetBufferId()
    string name[255]

    attr = FileExists(file)
    if attr & _DIRECTORY_
        GoDir(file)
    else
        name = QuotePath(ExpandPath(file,TRUE))
        AddHistoryStr(name,hist)
        EditFile(name)
    endif
    GotoBufferId(bid)
end

proc ViewFile()
    integer fileid
    integer attr
    integer synhi
    integer rc = TRUE
    integer bid = GetBufferId()

    fileid = GetBufferId(file)
    if fileid
        GotoBufferId(fileid)
    else
        attr = FileExists(file)
        if attr & _DIRECTORY_
            GoDir(file)
            return()
        endif
        rc = EditFile(QuotePath(file))
    endif

    if rc
        PushPosition()
        synhi = Set(ShowSyntaxHilite,OFF)
        lList(CurrFilename(),Query(ScreenCols),
            Query(ScreenRows),_ENABLE_SEARCH_|_ENABLE_HSCROLL_)
        Set(ShowSyntaxHilite,synhi)
        PopPosition()
        if fileid == 0
            AbandonFile()
        endif
    else
        Alarm()
        ExecDialog(Format(
            "MsgBox ",
            Chr(MB_OK),
            Chr(MB_ERROR),
            Chr(CNTRL_CTEXT),"Cannot load file!"
        ))
    endif

    GotoBufferId(bid)
end

proc DeleteFile()
    integer rc, bid
    integer line, row
    integer isdir

    bid = GotoBufferId(filebuff)
    row = CurrRow()
    line = CurrLine()
    isdir = FileExists(file) & _DIRECTORY_
    GotoBufferId(bid)

    ExecDialog(Format(
        "MsgBox ",
        Chr(MB_YESNO),
        Chr(MB_PROMPT),
        Chr(CNTRL_CTEXT),
        "Do you really want to ",
        iif( isdir, "remove the folder?", "delete the file?")
    ))
    if Val(Query(MacroCmdLine)) == ID_YES
        if isdir
            rc = RemoveDirectory(file)
        else
            rc = EraseDiskFile(file)
        endif
        if not rc
            Alarm()
            ExecDialog(Format(
                "MsgBox ",
                Chr(MB_OK),
                Chr(MB_ERROR),
                Chr(CNTRL_CTEXT),
                "Cannot ",
                iif( isdir, "remove folder!", "delete file!")
            ))
        endif
    endif

    IdCmbTypes(FALSE)
    bid = GotoBufferId(filebuff)
    if line > NumLines()
        line = NumLines()
    endif
    GotoLine(line)
    ScrollToRow(row)
    GetCurrFilename()
    GotoBufferId(bid)
    DisplayCurrFilename(TRUE)
end

proc RenameFile()
    integer bid
    string name[255] = file

    SetGlobalStr(DlgMsgText,name)
    ExecDialog(Format(
        "InpBox ",
        0,Chr(13),
        "Rename File",Chr(13),
        "Enter new filename:",Chr(13),
        Chr(13),Chr(13),"1"
    ))
    name = Query(MacroCmdLine)
    if name[1]  == Chr(ID_OK)
        name = GetGlobalStr(DlgMsgText)
        if not RenameDiskFile(file,name)
            Alarm()
            ExecDialog(Format(
                "MsgBox ",
                Chr(MB_OK),
                Chr(MB_ERROR),
                Chr(CNTRL_CTEXT),"Cannot rename file!"
            ))
            return()
        endif
    else
        return()
    endif

    IdCmbTypes(FALSE)
    bid = GotoBufferId(filebuff)
    if lFind("  "+name+"$","gx")
        ScrollToRow(5)
    endif
    GetCurrFilename()
    GotoBufferId(bid)
    DisplayCurrFilename(TRUE)
end

proc ShowCurrent()
    GoDir(dir)
end

proc ShowDesktop()
    string desktop[255] = ""

    GetDesktopFolder(desktop)
    if desktop <> ""
        GoDir(desktop)
    endif
end

proc ShowMyDocs()
    string mydocs[255] = ""

    GetMyDocsFolder(mydocs)
    if mydocs<> ""
        GoDir(mydocs)
    endif
end

proc SetSortOrder( string order, integer rescan )
    integer bid
    string file1[255]

    case Lower(order)
        when "n"    sort_order = "f"
        when "e"    sort_order = "en"
        when "d"    sort_order = "dtn"
        when "s"    sort_order = "sn"
    endcase
    if sort_desc
        sort_order = Upper(sort_order)
    endif
    if rescan
        file1 = file
        IdCmbTypes(FALSE)
        file = file1
        bid = GotoBufferId(filebuff)
        if lFind("  "+file,"g$")
            ScrollToRow(5)
        endif
        GotoBufferId(bid)
        DisplayCurrFilename(TRUE)
    endif
end

string proc ShowSortFlag()
    return (iif( sort_desc, "Descending", "Ascending" ))
end

proc ToggleSortFlag()
    sort_desc = not sort_desc
end

menu SortMenu()
    "&Name",    SetSortOrder("n",TRUE)
    "&Type",    SetSortOrder("e",TRUE)
    "&Date",    SetSortOrder("d",TRUE)
    "&Size",    SetSortOrder("s",TRUE)
    "",, divide
    "&Order"    [ShowSortFlag():10],    ToggleSortFlag(),   DontClose
end

menu ListMenu()
    "&Open   <Enter>",      PushKey(<Enter>)
    "",, divide
    "&Load",                LoadFile()
    "&View",                ViewFile()
    "",, divide
    "&Delete",              DeleteFile()
    "&Rename",              RenameFile()
    "",, divide
    "Re&fresh",             IdCmbTypes(TRUE)
    "",, divide
    "D&esktop",             ShowDesktop()
    "&My Documents",        ShowMyDocs()
    "Return to &Current",   ShowCurrent()
    "",, divide
    "&Sort            ",   SortMenu(),             DontClose
end

proc IdListMenu()
    integer bid = GetBufferId()

    if Query(Key) == <RightBtn>
        Set(X1, Query(MouseX))
        Set(Y1, Query(MouseY))
    else
        Set(X1, Query(PopWinX1) + CurrChar(POS_X1))
        Set(Y1, Query(PopWinY1) + CurrChar(POS_Y1))
    endif
    ListMenu()
    GotoBufferId(bid)
end

integer proc CheckListBoxKeys()
    integer next_key

    case Query(Key)
        when <Del>          next_key = KEY_DEL
        when <F2>           next_key = KEY_REN
        otherwise           next_key = 0
    endcase

    if next_key
        Set(Key,KEY_BREAK)
        PushKey(next_key)
        return(FALSE)
    endif

    return(TRUE)
end

integer proc ExecListBoxKeys()
    case Query(Key)
        when KEY_DEL            DeleteFile()
        when KEY_REN            RenameFile()
        otherwise               return(TRUE)
    endcase
    return(FALSE)
end

/****************************************************************************\
    options dialog
\****************************************************************************/

public proc Op32WOptsDataInit()
    ExecMacro(Format("DlgSetData ",ID_CHK_NOINFO," ",chk_noinfo))
    ExecMacro(Format("DlgSetData ",ID_CHK_NODIRS," ",chk_nodirs))
    ExecMacro(Format("DlgSetData ",ID_CHK_BIN," ",chk_bin))
    ExecMacro(Format("DlgSetData ",ID_CHK_HEX," ",chk_hex))
    ExecMacro(Format("DlgSetData ",ID_CHK_CHDIR," ",chk_chdir))
    ExecMacro(Format("DlgSetData ",ID_CHK_LDWILD," ",chk_wild))

    if mode <> MODE_OPEN
        ExecMacro(Format("DlgSetEnable ",ID_CHK_BIN," ",0))
        ExecMacro(Format("DlgSetEnable ",ID_CHK_HEX," ",0))
        ExecMacro(Format("DlgSetEnable ",ID_CHK_LDWILD," ",0))

        if not (mode in MODE_SAVEAS,MODE_DIALOG,MODE_RESOURCE)
            ExecMacro(Format("DlgSetEnable ",ID_CHK_CHDIR," ",0))
        endif
    endif
end

integer proc GetOpt( integer id )
    ExecMacro(Format("DlgGetData ",id))
    return(Val(Query(MacroCmdLine)))
end

public proc Op32WOptsDataDone()
    integer new_noinfo
    integer new_nodirs

    if CurrChar(POS_ID) == ID_OK
        new_noinfo = GetOpt(ID_CHK_NOINFO)
        new_nodirs = GetOpt(ID_CHK_NODIRS)
        chk_bin    = GetOpt(ID_CHK_BIN)
        chk_hex    = GetOpt(ID_CHK_HEX)
        chk_chdir  = GetOpt(ID_CHK_CHDIR)
        chk_wild   = GetOpt(ID_CHK_LDWILD)
        dirty = new_noinfo <> chk_noinfo or new_nodirs <> chk_nodirs
        chk_noinfo = new_noinfo
        chk_nodirs = new_nodirs
    endif
end

proc IdBtnDrives()
    ExecDialog("ScanDrives")
    ExecMacro("DlgTerminate")
end

public proc Op32WOptsBtnDown()
    case CurrChar(POS_ID)
        when ID_OK              ExecMacro("DlgTerminate")
        when ID_BTN_DRIVES      IdBtnDrives()
        when ID_HELP            InitHelp(HLP_WIDTH) QuickHelp(DlgOpenOptsHelp)
    endcase
end

proc IdOpts()
    integer resource
    integer rc
    integer bid
    integer line, row

    bid = GotoBufferId(filebuff)
    row = CurrRow()
    line = CurrLine()
    GotoBufferId(bid)

    dirty = FALSE
    resource = CreateTempBuffer()
    rc = resource and InsertData(dlgop32b) and ExecDialog("dialog Op32WOpts")
    GotoBufferId(bid)
    AbandonFile(resource)

    if rc
        if dirty
            SetFolder()
            IdCmbTypes(FALSE)
            bid = GotoBufferId(filebuff)
            if line > NumLines()
                line = NumLines()
            endif
            GotoLine(line)
            ScrollToRow(row)
            GetCurrFilename()
            GotoBufferId(bid)
            DisplayCurrFilename(TRUE)
        endif
    else
        Warn("DlgOpen: Error executing options dialog")
    endif
end

/****************************************************************************\
    control response functions
    +   IdCmbTypes      set wildcard according to file type
    +   IdLstFiles      update edit control with current filename
    +   IdDirUp         go to parent folder
    +   IdDirNew        make a new folder
\****************************************************************************/

proc IdCmbTypes( integer paint )
    integer bid

    bid = GotoBufferId(typebuff)
    file = "*." + RTrim(GetText(1,3))
    GotoBufferId(bid)
    ListFiles()
    if paint
        DisplayCurrFilename(TRUE)
    endif
end

proc IdLstFiles()
    integer bid

    bid = GotoBufferId(filebuff)
    GetCurrFilename()
    GotoBufferId(bid)
    DisplayCurrFilename(FALSE)
end

proc IdDirUp()
    string desktop[255] = ""

    if IsRoot()
        GetDesktopFolder(desktop)
        if desktop <> ""
            GoDir(desktop)
        endif
    else
        GoDir("..")
    endif
    ExecMacro(Format("DlgExecCntrl ",ID_LST_FILES))
end

proc IdDirNew()
    string dir[255] = ""


    SetGlobalStr(DlgMsgText,"")
    ExecDialog(Format(
        "InpBox ",
        0,Chr(13),
        "New Folder",Chr(13),
        "Enter name of new folder:",Chr(13),
        Chr(13),Chr(13),"1"
    ))
    dir = Query(MacroCmdLine)
    if dir[1] == Chr(ID_OK)
        dir = GetGlobalStr(DlgMsgText)
        if CreateDirectory(dir,0)
            GoDir(dir)
        else
            Alarm()
            ExecDialog(Format(
                "MsgBox ",
                Chr(MB_OK),
                Chr(MB_ERROR),
                Chr(CNTRL_CTEXT),"Cannot create new folder!"
            ))
        endif
    endif
    ExecMacro(Format("DlgExecCntrl ",ID_LST_FILES))
end

/****************************************************************************\
    ok button
\****************************************************************************/

proc IdOk()
    integer attr
    integer tokens
    string dir[255], name[255]

    // get the specified file name

    ExecMacro(Format("DlgGetTitle ",ID_EDT_NAME))
    file = GetGlobalStr(DlgMsgText)

    // check for an empty line

    if Length(file) == 0
        ExecMacro(Format("DlgExecCntrl ",ID_EDT_NAME))
        Alarm()
        return()
    endif

    // check for wildcards and narrow down file list

    if isWildPath(file)
        if Pos(":",file) or Pos("\",file)
            tokens = NumTokens(file,"\")
            if tokens > 1
                name = GetToken(file,"\",tokens)
                dir = SubStr(file,1,Pos(name,file)-1)
            else
                name = GetToken(file,":",2)
                dir = GetToken(file,":",1) + ":"
            endif
            file = name
            if GoDir(dir)
                file = name
                DisplayCurrFilename(FALSE)
            else
                ExecMacro(Format("DlgExecCntrl ",ID_EDT_NAME))
                return()
            endif
        endif
        if chk_wild
            ExecMacro(Format("DlgTerminate ",ID_OK))
        else
            ListFiles()
            ExecMacro(Format("DlgPaintCntrl ",ID_LST_FILES))
            ExecMacro(Format("DlgExecCntrl ",ID_EDT_NAME))
        endif
        return()
    endif

    // if the file name is a directory, let's go there

    if Length(file) == 2 and file[2] == ":"
        file = file + "."
    endif

    attr = FileExists(file)
    if attr & _DIRECTORY_ or file == "\"
        if GoDir(file)
            ExecMacro(Format("DlgExecCntrl ",ID_LST_FILES))
        else
            ExecMacro(Format("DlgExecCntrl ",ID_EDT_NAME))
        endif
        return()
    endif

    // must the file exist ?

    if must_exist and FileExists(file) == 0
        ExecDialog(Format(
            "MsgBox ",
            Chr(MB_OK),
            Chr(MB_ERROR),
            Chr(CNTRL_CTEXT),"The file does not exists!"
        ))
        return ()
    endif

    // otherwise, say bye and go home

    ExecMacro(Format("DlgTerminate ",ID_OK))
end

/****************************************************************************\
    custom hot keys
    +   CheckHotKeys    check for custom hot key and exit secondary loops
    +   ExecHotKeys     execute actions of custom hot keys
\****************************************************************************/

integer proc CheckHotKeys()
    integer next_key

    if LoByte(Query(Key)) == Asc("?")
        Set(Key,<Shift />)
    endif

    case Query(Key)
        when <Shift />          next_key = KEY_HELP
        when <Ctrl Tab>         next_key = KEY_OPTS
        when <Backspace>        next_key = KEY_DIRUP
        when <Ins>,<GreyIns>    next_key = KEY_DIRNEW
        when <F5>               next_key = KEY_REFRESH
        otherwise               next_key = 0
    endcase

    if next_key
        if CurrChar(POS_ID) == ID_EDT_NAME
            if not (next_key in KEY_OPTS, KEY_REFRESH)
                return(FALSE)
            endif
        endif
        Set(Key,KEY_BREAK)
        PushKey(next_key)
        return(FALSE)
    endif

    return(TRUE)
end

integer proc ExecHotKeys()
    integer cntrl = 0

    case Query(Key)
        when KEY_OPTS       IdOpts()
        when KEY_HELP       cntrl = ID_HELP
        when KEY_DIRUP      cntrl = ID_BTN_DIRUP
        when KEY_DIRNEW     cntrl = ID_BTN_DIRNEW
        when KEY_REFRESH    IdCmbTypes(TRUE)
        otherwise           return(TRUE)
    endcase

    if cntrl
        ExecMacro(Format("DlgExecCntrl ",cntrl))
        PushKey(<Enter>)
    endif

    return(FALSE)
end

/****************************************************************************\
    message response functions
    +   Event           custom hot keys
    +   FixedList       provide a fixed length list for folder combo
    +   AnchorList      anchor search in type and drive lists
    +   DropDown        fill folder drop down list
    +   CloseUp         reset folder drop down list
    +   RightClk        activate context menu of file list
    +   ListMenu        display context menu of file list
    +   SetFocus        ok in dir list and open type drive lists
    +   SelChanged      handle selection changes in file list
    +   DblClick        double clicks within list boxes
    +   BtnDown         push button actions
\****************************************************************************/

public proc Op32WEvent()
    integer level = Val(Query(MacroCmdLine))

    if level <= 1 and CheckHotKeys()
        if ExecHotKeys()
            if CurrChar(POS_ID) == ID_LST_FILES
                if CheckListBoxKeys()
                    ExecListBoxKeys()
                endif
            endif
        endif
    endif
end

public proc Op32WFixedList()
    if CurrChar(POS_ID) == ID_CMB_FOLDER
        Set(MacroCmdLine,"1")
    endif
end

public proc Op32WAnchorList()
    if CurrChar(POS_ID) == ID_CMB_TYPES
        Set(MacroCmdLine,"1")
    endif
end

public proc Op32WDropDown()
    string cmd[64]
    integer top, lft, wdt, hgt

    cmd = Query(MacroCmdLine)
    lft = Val(GetToken(cmd," ",1))
    top = Val(GetToken(cmd," ",2))
    wdt = Val(GetToken(cmd," ",3))
    hgt = Val(GetToken(cmd," ",4))

    case CurrChar(POS_ID)
        when ID_CMB_FOLDER
            lft = lft - 9
            wdt = wdt + 9
            hgt = Query(PopWinRows) - 9
            FolderComboInit()
        when ID_EDT_NAME
            hgt = Min(Query(PopWinRows)-9, NumHistoryItems(hist))
            top = top - hgt - 3
            lft = Query(PopWinX1) + 3
            wdt = Query(PopWinCols) - 8
        when ID_CMB_TYPES
            top = CurrChar(POS_Y1)
            GotoBufferId(typebuff)
            hgt = Min(12, NumLines())
            top = Query(PopWinY1) + top - hgt - 3
    endcase

    Set(MacroCmdLine, Format(lft:4, top:4, wdt:4, hgt:4))
end

public proc Op32WCloseUp()
    if CurrChar(POS_ID) == ID_CMB_FOLDER
        FolderComboClose()
    endif
end

public proc Op32WRightClk()
    if CurrChar(POS_ID) == ID_LST_FILES
        Set(MacroCmdLine,"1")
    endif
end

public proc Op32WContext()
    if CurrChar(POS_ID) == ID_LST_FILES
        IdListMenu()
    endif
end

public proc Op32WSetFocus()
    if CurrChar(POS_ID) == ID_LST_FILES
        IdLstFiles()
    endif
end

public proc Op32WSelChanged()
    case CurrChar(POS_ID)
        when ID_LST_FILES   IdLstFiles()
        when ID_CMB_TYPES   IdCmbTypes(TRUE)
        when ID_CMB_FOLDER  FolderComboDone()
    endcase
end

public proc Op32WDblClick()
    if CurrChar(POS_ID) == ID_LST_FILES
        IdOk()
    endif
end

public proc Op32WBtnDown()
    case CurrChar(POS_ID)
        when ID_OK              IdOk()
        when ID_BTN_DIRUP       IdDirUp()
        when ID_BTN_DIRNEW      IdDirNew()
        when ID_BTN_OPTS        IdOpts()
        when ID_HELP            InitHelp(HLP_WIDTH) QuickHelp(DlgOpenHelp)
    endcase
end

/****************************************************************************\
    initialize dialog data
\****************************************************************************/

proc MoveCntrl( integer dx1, integer dy1, integer dx2, integer dy2 )
    integer x1 = CurrChar(POS_X1) + dx1
    integer y1 = CurrChar(POS_Y1) + dy1
    integer x2 = CurrChar(POS_X2) + dx2
    integer y2 = CurrChar(POS_Y2) + dy2

    ExecMacro(Format("DlgMoveCntrl",x1:4,y1:4,x2:4,y2:4))
end

proc TweakSize()
    integer delta

    delta = Query(ScreenRows) - 25
    if delta == 0
        return()
    endif

    PushPosition()
    BegFile()                           // dialog window
    MoveCntrl(0,0,0,delta)
    repeat                              // manually, b/o stack usage
        Down()
    until CurrChar(POS_ID) == ID_LST_FILES
    MoveCntrl(0,0,0,delta)
    Down()
    MoveCntrl(0,0,0,delta)
    while Down()
        MoveCntrl(0,delta,0,delta)
    endwhile
    PopPosition()
end

public proc Op32WDataInit()
    string name[255] = file

    if CheckVersion("DlgOpen",2,3)
        ExecMacro("DlgTerminate")
        return()
    endif

    if not (ExecDialog("DriveLst") and Val(Query(MacroCmdLine)))
        ExecMacro("DlgTerminate")
        return()
    endif

    TweakSize()

    if mode in MODE_EXECMACRO,MODE_LOADMACRO
        GoMacDir("*.mac")
    elseif mode in MODE_DIALOG
        GoMacDir("*.d")
    elseif mode in MODE_RESOURCE
        GoMacDir("*.dlg")
    elseif mode in MODE_LOADKEY,MODE_SAVEKEY,MODE_DECOMP
        GoKbdDir("*.kbd")
    elseif mode in MODE_RECOMP
        GoKbdDir("*.k")
    elseif mode in MODE_LOADPROJ,MODE_SAVEPROJ
        file = "*.tpr"
    else
        file = "*.*"
    endif

    ListFiles()
    SetFolder()
    if file == "*.*"
        file = name
    endif

    DisplayCurrFilename(FALSE)
    ExecMacro(Format("DlgSetData ",ID_EDT_NAME," ",hist))
    ExecMacro(Format("DlgSetData ",ID_LST_FILES," ",filebuff))
    ExecMacro(Format("DlgSetData ",ID_CMB_TYPES," ",typebuff))
    ExecMacro(Format("DlgSetData ",ID_CMB_FOLDER," ",dirsbuff))

    if mode <> MODE_OPEN
        case mode
            when MODE_SAVEAS
                ExecMacro("DlgSetTitle 0 Save File As")
            when MODE_INSERT
                ExecMacro("DlgSetTitle 0 Insert File As Block")
            when MODE_SAVEBLOCK
                ExecMacro("DlgSetTitle 0 Save Block To File")
            when MODE_EXECMACRO
                ExecMacro("DlgSetTitle 0 Execute Macro")
            when MODE_LOADMACRO
                ExecMacro("DlgSetTitle 0 Load Macro")
            when MODE_LOADKEY
                ExecMacro("DlgSetTitle 0 Load Keyboard Macros")
            when MODE_SAVEKEY
                ExecMacro("DlgSetTitle 0 Save Keyboard Macros")
            when MODE_DECOMP
                ExecMacro("DlgSetTitle 0 Decompile Keyboard Macros")
            when MODE_RECOMP
                ExecMacro("DlgSetTitle 0 Recompile Key Listings")
            when MODE_DIALOG
                ExecMacro("DlgSetTitle 0 Compile Dialog Resource")
            when MODE_RESOURCE
                ExecMacro("DlgSetTitle 0 Display Dialog Resource")
            when MODE_LOADPROJ
                ExecMacro("DlgSetTitle 0 Load Project")
            when MODE_SAVEPROJ
                ExecMacro("DlgSetTitle 0 Save Project")
        endcase
    endif

    ExecMacro(Format("DlgExecCntrl ",ID_EDT_NAME))
end

/****************************************************************************\
    retrieve dialog data
\****************************************************************************/

//  public proc Op32WDataDone()
//  end

/****************************************************************************\
    main program (helper: initialize)
\****************************************************************************/

proc Init( integer new_mode, integer new_hist, string ext )
    mode = new_mode
    hist = new_hist
    if Length(ext)
        file = ext
    endif
end

integer proc CheckKbdSave()
    constant KBD_BUFF = 5
    integer bid, rc

    if mode <> MODE_SAVEKEY
        return(FALSE)
    endif

    bid = GotoBufferId(KBD_BUFF)
    rc = NumLines() == 0
    GotoBufferId(bid)
    if rc
        ExecDialog(Format(
            "MsgBox ",
            Chr(MB_OK),
            Chr(MB_ERROR),
            Chr(CNTRL_CTEXT),"No key macros defined!"
        ))
    endif
    return(rc)
end

/****************************************************************************\
    main program (helper: finialize)
\****************************************************************************/

proc LoadFileFromDisk()
    integer lwfi

    lwfi = Set(LoadWildFromInside,chk_wild)
    if chk_bin
        file = Format("-b",iif(chk_hex,16,64)," ",file)
    endif
    if EditFile(file,_DONT_PROMPT_)
        if chk_hex
            DisplayMode(_DISPLAY_HEX_)
        endif
    else
        Alarm()
        ExecDialog(Format(
            "MsgBox ",
            Chr(MB_OK),
            Chr(MB_ERROR),
            Chr(CNTRL_CTEXT),"Open error: ",file
        ))
    endif
    Set(LoadWildFromInside,lwfi)
end

proc SaveFileAs()
    if ChangeCurrFilename(file)
        SaveFile()
    endif
end

/****************************************************************************\
    main program
\****************************************************************************/

proc Main()
    integer i, rc
    integer execute
    integer userbuff
    string cmd[32] = Query(MacroCmdLine)

    // initialize global variables

    chk_wild = Query(LoadWildFromInside)
    chk_chdir = Query(PickFileChangesDir)
    dir = CurrDir()
    file = CurrFilename()
    file = GetToken(file,"\",NumTokens(file,"\"))

    // compute command line arguments

    execute = TRUE

    for i = 1 to NumTokens(cmd," ")
        case GetToken(cmd," ",i)
            when "-s"   Init(MODE_SAVEAS,_EDIT_HISTORY_,"")
            when "-i"   Init(MODE_INSERT,_EDIT_HISTORY_,"")
            when "-b"   Init(MODE_SAVEBLOCK,_EDIT_HISTORY_,"")
            when "-e"   Init(MODE_EXECMACRO,_EXECMACRO_HISTORY_,"*.mac")
            when "-l"   Init(MODE_LOADMACRO,_LOADMACRO_HISTORY_,"*.mac")
            when "-k"   Init(MODE_LOADKEY,_KEYMACRO_HISTORY_,"*.kbd")
            when "-v"   Init(MODE_SAVEKEY,_KEYMACRO_HISTORY_,"*.kbd")
            when "-d"   Init(MODE_DECOMP,_KEYMACRO_HISTORY_,"*.kbd")
            when "-r"   Init(MODE_RECOMP,GetFreeHistory("ReComp:files"),"*.k")
            when "-c"   Init(MODE_DIALOG,GetFreeHistory("DLG:txt"),"*.d")
            when "-y"   Init(MODE_RESOURCE,GetFreeHistory("DLG:bin"),"*.dlg")
            when "-p"   Init(MODE_LOADPROJ,GetFreeHistory("UI:Sessions"),"*.tpr")
            when "-j"   Init(MODE_SAVEPROJ,GetFreeHistory("UI:Sessions"),"*.tpr")
            when "-n"   chk_noinfo = TRUE
            when "-f"   chk_nodirs = TRUE
            when "-t"   must_exist = TRUE
            when "-x"   execute = FALSE
            when "-on"  SetSortOrder("n",FALSE)
            when "-oe"  SetSortOrder("e",FALSE)
            when "-od"  SetSortOrder("d",FALSE)
            when "-os"  SetSortOrder("s",FALSE)
        endcase
    endfor

    if CheckKbdSave()
        goto finalize
    endif

    // initialize work space and exec dialog

    PushBlock()
    userbuff = GetBufferId()

    filebuff = CreateTempBuffer()
    dirsbuff = CreateTempBuffer()
    tempbuff = CreateTempBuffer()
    typebuff = CreateTempBuffer()

    rc = filebuff and dirsbuff and tempbuff and typebuff
    if rc
        case mode
            when MODE_EXECMACRO, MODE_LOADMACRO rc = InsertData(MacroTypes)
            when MODE_LOADKEY, MODE_SAVEKEY     rc = InsertData(KeyTypes)
            when MODE_RECOMP                    rc = InsertData(ListTypes)
            when MODE_DIALOG                    rc = InsertData(DialogTypes)
            when MODE_RESOURCE                  rc = InsertData(ResourceTypes)
            when MODE_LOADPROJ, MODE_SAVEPROJ   rc = InsertData(SessionTypes)
            otherwise                           rc = InsertData(FileTypes)
        endcase
    endif
    if rc
        resource = CreateTempBuffer()
        rc = resource and InsertData(dlgop32a) and ExecDialog("dialog Op32W")
    endif

    GotoBufferId(userbuff)
    PopBlock()

    if not rc
        Warn("DlgOpen: Error executing open dialog")
        goto finalize
    endif

    // execute chosen action

    if Val(Query(MacroCmdLine)) == ID_OK
        file = QuotePath(ExpandPath(file,TRUE))
        AddHistoryStr(file,hist)
        if execute
            case mode
                when MODE_OPEN          LoadFileFromDisk()
                when MODE_SAVEAS        SaveFileAs()
                when MODE_INSERT        InsertFile(file)
                when MODE_SAVEBLOCK     SaveBlock(file)
                when MODE_EXECMACRO     ExecMacro(file)
                when MODE_LOADMACRO     LoadMacro(file)
                when MODE_LOADKEY       LoadKeyMacro(file)
                when MODE_SAVEKEY       SaveKeyMacro(file)
                // otherwise
                // let parent handle event (same as -x switch)
            endcase
        endif
    endif

    // restore working directory

    if not (rc and chk_chdir)
        ChDir(dir)
    endif

    // finialize

finalize:

    AbandonFile(resource)
    AbandonFile(typebuff)
    AbandonFile(tempbuff)
    AbandonFile(dirsbuff)
    AbandonFile(filebuff)

    PurgeMacro(CurrMacroFilename())
    UpdateDisplay(_HELPLINE_REFRESH_)
end

