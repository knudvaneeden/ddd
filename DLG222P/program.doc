
1. Welcome
----------

Welcome to the dialogs programmers' guide. Let's start with a couple of
warnings. The following text contains highly technical and advanced stuff.
Thus, if you haven't had any previous experience with message oriented
programming and don't know what a callback function is, please don't be too
frustrated if you do not understand everything right away. On the other
hand, if you should already have constructed one or another dialog for
Windows, you might find the following to be very familiar.

Another warning yet. If you should ever need a special control, which is not
provided by Dialog.S, please resist the temptation and do not change the
library itself. There are mechanisms built into it which make it quite easy
to implement your own custom controls. Furthermore, you might find a couple
of places in there which contain some quite complex code which is rather
easy to break, if you don't know exactly what you are doing. (I know what
I'm talking about. I inadvertently broke something in there a couple of
times while I still was expanding the functionality. Which doesn't mean,
that I don't know what I'm doing, though <RBG>). Moreover, changing the
event handler or main event loop of Dialog.S will most probably completely
upset the dialog editor DE.

Finally, the following cannot and does not intend to be a text book on
message oriented programming. Instead it is (a rather short) technical
reference on how to use Dialog.S to build dialogs. Which means the
information presented is not structured linearly (it can't be). To
understand everything which is explained in the beginning, you had to know
some information which is in the reference sections further down. Maybe the
best thing to do is print the file and read a hard copy of it (which makes a
better reference manual anyway).



2. What's New (Version 2.2)
---------------------------

Update 2.2 is the first one which doesn't change the API. All the changes
pertain to fixing the painting routines to work with an ANSI character set.



3. The Programming Model
------------------------


3.1. What Is Dialog.S
---------------------

Dialog.S is a dynamic link library (DLL) which paints and executes dialog
windows. Well, what is a DLL? A DLL is a program which is not meant to be
executed by the user. The other differences to a "normal" program are almost
negligible. In another world, the operating system provides for a mechanisms
which prohibits the user from executing a DLL. Since there isn't such a
mechanism built into TSE, I added two simple but effective tests to Dialog.S
which do exactly that: they prevent that the innocent user inadvertently
runs his latest internet mail as a dialog box :-). (The sad truth is, that
doing so might even hang his machine.)


3.2. Dialog Resources
---------------------

A dialog is based on a formal description which is called a dialog resource.
The latter is an ASCII file, which describes the visual appearance of a
dialog: initial position and size, which controls are included and where
they are located, etc. This ASCII file is turned into its (more or less)
binary counterpart using the resource compiler DC. This serves a twofold
purpose: first DC (quite rigorously) checks, if the resource file is
correct, and thus relieves Dialog.S from this time consuming task, and
second the binary information is easier and faster to access from within
Dialog.S.


3.3. Executing a Dialog
-----------------------

Now let's shortly discuss, how Dialog.S is used from within a dialog macro.
To execute a dialog you must basically do only a couple of things: first
load the binary resource into a (system) buffer, next execute Dialog.MAC
with a unique string as a command line argument, and finally get the return
code after Dialog.MAC has terminated. This code might, for example, look
like this:

        #include "example.dlg"

        proc main()
            integer dlg

            dlg = CreatTempBuffer()
            if dlg and InsertData(example)
                ExecMacro("dialog example")
                Warn("return code = ",Query(MacroCmdLine))
            endif
            AbandonFile(dlg)
        end

If you study this example carefully, you might find something I didn't tell
you so far. The binary dialog resource is stored in a file which contains
only a single datadef statement and the name of that datadef is also the
name of the resource file (or vice versa). This simply provides for an easy
access to the dialog resource. Another very important thing is, that the
buffer which contains the dialog resource MUST be the current buffer at the
moment you launch Dialog.MAC.


3.4. Callback Functions
-----------------------

Dialogs would be rather boring, if that would be the only thing you could do
with them. Well, there are many more possibilities to interact with dialogs
while they are executing. First and foremost Dialog.MAC will inform you (or
rather your macro), when something interesting is happening within the
dialog. This is done by calling a callback function, which you must provide
("sending a message" is another fitting term). Well, that's were the unique
string you provided at the ExecMacro call comes in. Whenever Dialogs calls
back your macro, it prefixes its internal callback names with your string.
This is done to avoid grand confusion, when multiple dialogs are executing.
(Yes, you can open a dialog box from within another dialog box. The whole
game is completely re-entrant.) While program control is back within your
own macro you can change things within the dialog by calling public
functions which Dialog.S provides. (Someplace else these are called external
entries or API functions.) Here's an example, which augments the previous
one.

        public proc ExampleBtnDown()
            if CurrChar(POS_ID) == ID_OK
                ExecMacro("DlgTerminate")
            endif
        end

This assumes, that your dialog contains a PushButton with an id of ID_OK.
The example is vital in more than one respect. First of all it demonstrates,
that your dialog doesn't shut down automatically, when a button is pressed.
(The one exception is a button having the id ID_CANCEL. You should label it
"Cancel" :-)). Second it shows, how to access information about the focused
control. This is done, by getting binary values at certain columns at the
current line. You don't have to learn those positions by heart, they are
defined as symbolic constants in the include file Dialog.SI. Finally this
include file also contains many other important constants, among them a few
pre-defined id's used with PushButtons. But more of that later.


3.5. Control Data
-----------------

Most of the controls have some piece of private data. E.g., the data of a
CheckBox is an integer which is either "1" or "0" depending on whether the
box is checked or not. Whenever program control is back within your dialog
macro, you can query and set control data. Moreover, there are two special
callbacks which are issued, when Dialog.S initializes and terminates:
DataInit and DataDone. These are used to initialize the data of the dialog
and to retrieve it when the dialog terminates. E.g., let's suppose that our
previous example dialog includes a CheckBox with an id of ID_CHKBX and that
the box should initially be checked. (You don't have to do anything special
in the other case, because all dialog data is initialized to zero "0", when
Dialog.S allocates the data buffer.) To check the box at startup, you have
to do the following:

        public proc ExampleDataInit()
            ExecMacro(Format("DlgSetData ",ID_CHKBX," 1"))
        end

Retrieving the data (to see, whether the user changed the check mark or
not) is almost as simple:

        public proc ExampleDataDone()
            integer mark

            ExecMacro(Format("DlgGetData ",ID_CHKBX))
            mark = Val(Query(MacroCmdLine))
        end


3.6. Configuration
------------------

Dialog.S allows interactive configuration of its basic parameters and of its
color palette. The latter is even extensible to include the color palettes
of custom controls. Usually you don't have to care about the configuration
process, because DlgSetup.S handles all the minute details. The only
exception to this rule are custom controls (c.f. section 13).



4. Helper Libraries
-------------------

Dialog.S is accompanied by two small libraries which implement two often
used dialogs: MsgBox and InpBox. Message boxes are panels which either
inform the user about something that is happening within your macro or ask
him simple questions (yes-no, ok-cancel, etc.). Input boxes essentially
give you the same functionality as the SAL Ask function. Both libraries are
quite flexible and easy to use. You control the contents of the dialogs
with the macro command line and get the user input back the same way.


4.1. Message Boxes
------------------

There are two examples which show you how to use message boxes: Hello.S
and TestMB1.S. Moreover, the ready to use dialogs distributed separately
also make frequent use of this utility. The return code of a message box
is always the id of one of its PushButtons, e.g. ID_OK, ID_YES. (Well,
it's the string representation of one of these numbers, but that should be
fairly clear by now.) What's left, is to show you a formal description of
the MsgBox command line.

        Chr(BtnDef) + TitleDef + Chr(TextAlign) + Text
                [ + Chr(13) + Chr(TextAlign) + Text ... ]

Where

        BtnDef          one of the predefined PushButton combinations,
                        e.g. MB_YESNO (c.f. MsgBox.SI)
        TitleDef        StdTitleDef | ( Chr(MB_TITLE) + Title + Chr(13) )
        Title           any string
        TextAlign       CNTRL_LTEXT | CNTRL_CTEXT CNTRL_RTEXT
        Text            any string
                        when repeated, multiple lines are displayed

Where
        StdTitleDef     one of the predefined titles, e.g. Chr(MB_ERROR)

Please note, that all the pieces of the MsgBox command line must be
concatenated without intervening spaces, because spaces are significant
within the title and text portions of it.

Please also note, that the size of Text is limited to approximately 100
characters due to the maximum size of MacroCmdLine.


4.2. Input Boxes
----------------

Please have a look at the example file TestIB1.S. (You should also compile
and execute the examples, when you are referred to them.) The formal
description of the InpBox command line is:

        Str(History) +
                + Chr(13) + Title
                + Chr(13) + Prompt
                + Chr(13) + InitialText
                [ + Chr(13) + HelpCallBack
                [ + Chr(13) + Use_DlgMsgText ]]

Where

        History         any valid history number or 0 (zero)
        Title           any string
        Prompt          any string
        InitialText     any string
        HelpCallBack    name of a public proc
        Use_DlgMsgText  0 | 1
                        if 1, pass text via global variable DlgMsgText

The returned data has also a fairly simple structure. It is what has been
inside the EditControl when the user closed the input box. Well, with the
exception of the first character of the returned command line. This is
either Chr(ID_OK) or Chr(ID_CANCEL), which depends on how the user closed
the dialog.

If you supply a help call back, the input box will display a help button.
Whenever the help button is pressed, InpBox executes the macro indicated
by HelpCallBack. Set HelpCallBack to an empty string, when Use_DlgMsgText
is present but a help button should not be displayed.

If you include a non-zero Use_DlgMsgText at the macro command line, InpBox
will retrieve the initial text to display inside its EditControl from the
global variable DlgMsgText. This is the only way to initialize the text to
sizes larger than ca. 80 characters (the exact limit depends on the sizes
of both Title and Prompt). When returning InpBox sets DlgMsgText to the
current contents of its EditControl. Use the global variable to avoid
truncation due to the limited size of MacroCmdLine.



5. The Dialog Resource Compilers
--------------------------------


5.1 The Command Line Compiler (DC)
----------------------------------

First, let's briefly talk about conventions. Somehow, I decided that .D is
a fitting extension for the textual representation of a dialog resource and
that .DLG is fine for its binary counterpart. Since the resource compiler DC
depends on those extensions, you're stuck with them (well, as long as you
don't change the source code of DC :-)).

DC is nothing but a SAL macro. Thus, if you want to compile a dialog
resource, you have to do this from within TSE. But since you most probably
use TSE anyway to put together such a resource, I guess that's not much of
an obstacle. DC has two modes of operation. First, if your current file has
an extension of .D, it will save that file and compile it. Second, if the
extension is something else, DC will ask you for the name of the input file,
then it will load and compile the latter. When DC finds an error, it
will stop, display a message and mark the erroneous portion of the file.
Otherwise DC will save the binary resource using the name of the input
file, but will replace the extension by .DLG.

After compiling your file DC will ask you, if it should immediately
launch DD to display the dialog. You can suppress this prompt using the
-b (batch) switch. DC features another two switches, but these are not
meant for interactive usage (the file header of DC.S gives you more
information, in case you're interested).


5.2 The Dialog Display Utility (DD)
-----------------------------------

Use this simple utility to quickly display an already compiled dialog
resource. You cannot do much with this dialog, except to test tabbing
order and hotkeys and to see if everything looks fine. DD provides some
additional functionality, though. The dialog will be closed if you press
any PushButton. DD also includes a simple mechanism to paint custom
controls.

You can include the name of the dialog resource file which DD should
display at the macro command line. If you omit it, DD will prompt you
for a file name.


5.3 Interactively Editing Dialogs (DE)
--------------------------------------

Using DE is the most convenient way to build and edit dialog resources.
DE displays a dialog window which corresponds to the current state of
the resource file and thus gives you an immediate visual feedback while
you add and edit controls. Moreover, it's almost completely mouse
driven, e.g. you can move, size and add controls using your mouse.

The user interface of DE is simple and straight forward. Left click at a
control and drag the mouse to move it. If you want to change the size of
a control, press the ctrl-key and left click and drag. To inspect and/or
alter the properties of a control right click it and choose Properties
from the menu which pops up. Right clicking at the dialog background or
outside the dialog pops up the main menu of DE. This menu allows you to
add new controls, define the tabbing order and the grouping of controls.
It also allows you to access the identifier and source code editors.

If you prefer the keyboard, you can use it. Press F10 to access the main
menu and Alt-F10 to pop up the object menu. To find out more about key
assignments, use the on-line help (F1).

If you build a new dialog from scratch, use the following recipe:

    - Insert all the controls you need.
    - Define the tabbing order.
    - Define group boundaries.
    - Optionally add comments.

The reason for this is, that the tabbing order editor removes all group
statements, comments and empty lines from the resource file. E.g., don't
insert comments into your source code until your work is finished, they will
most probably be deleted anyway. If you insert an additional control into an
elaborate dialog resource, don't use the tabbing order editor at all. Use
the source code editor instead, it also features a very efficient method to
move controls.

After you have finished your work, you should at least once compile your
dialog resource using DC to check the boundaries of the controls. (DE
executes DC in relaxed mode to allow for controls which are located outside
of the dialog window.)

Here are some additional hints you might find useful.

- DE creates a backup of the input file (*.d0) whenever it is executed.

- To remove the marking frame, press escape or click someplace outside
  of the dialog window. (This effectively marks the main dialog control.)

- You cannot move controls above or to the left of the dialog. But you
  CAN move them to the right and below it. This gives you a convenient
  place to temporarily store controls.

- To access controls which are stacked on top of each other, either use
  the tab key or click multiple times to cycle the frame.

- To cancel a dragging operation, press escape or the right mouse button
  while you are still holding the left button.

Well, now simply go ahead and build a dialog using DE, it's the best way
to learn it.



6. Dialog Resources Files
-------------------------

This section will give you a formal description on what you can put into a
dialog resource file and on how it is structured.

A line within a dialog resource is defined as follows:

        Line = Comment | Include | GroupDef | ControlDef

Where

        Comment = BlankLine | ( "//" any characters )

                Comments are simply ignored and
                can appear anywhere within the resource file

        Include = "#include" " " [" "...] """ FileName """

        FileName = name of an existing file defining symbolic constants

                E.g., #include "dialog.si". There are two important
                limitations concerning include files. First, you cannot
                re-define any constant. Second, each constant must be on
                a separate line and must have its own constant identifier
                (c.f. any of the .SI files). Include statements also can
                appear anywhere within the resource file.

        GroupDef = "group"

                Group definitions come in pairs, e.g. the first opens
                the group and the second one closes it. Grouped
                controls can be accessed using the cursor keys.
                Currently there are three types of controls which usually
                are grouped: PushButtons, CheckBoxes and RadioButtons.
                (In fact, RadioButtons MUST be grouped, in order that
                the user is able to move the mark from one button to
                another using the keyboard. Well, unless he uses a
                hotkey that you provided.)

The last definition is the most complex and important one, because it
defines a "real" control. It looks like this:

        ControlDef = CntrlName    " " [" "...]
                     CntrlId      " " [" "...]
                     EnableFlag   " " [" "...]
                     X1           " " [" "...]
                     Y1           " " [" "...]
                     X2           " " [" "...]
                     Y2           " " [" "...]
                     Title
                     ["," Hint]

Now, let's have a closer look on each of these.

        CntrlName = "dialog"  |
                    "frame"   |
                    "ltext"   |
                    "rtext"   |
                    "ctext"   |
                    "open"    |
                    "edit"    |
                    "button"  |
                    "defbtn"  |
                    "radio"   |
                    "check"   |
                    "combo"   |
                    "list"    |
                    "vscroll" |
                    "hscroll" |
                    "scredge" |
                    "control"

You will find an entry for each control type in section 8, which describes
what each control does and how you can use it. There is one important point,
though: The "dialog" control MUST be the first control which is defined,
because it defines the size of the dialog and all other controls depend on
that. Moreover, Dialog.S assumes that the "dialog" control is the first line
within a binary dialog resource and uses this to check that the current
buffer contains a valid resource definition. A second point is: the order of
the controls within the resource file also defines the tabbing order within
the dialog, e.g. the order of the lines within your resource files is quite
significant.

        CntrlId = SymbolicConstant | OrdinalNumber

The control id is used to identify and manipulate specific controls whenever
Dialog.S calls back your own dialog macro. It is an ordinal number in the
range 0..255. Symbolic constants are used to make your code more readable.
The value zero is specific. It means, that the control doesn't have an id at
all and that you will not (in fact cannot) access it from within your dialog
macro. (Well, this also means that you are limited to 255 accessible
controls, which you can put into any one dialog. But I guess that you will
never reach that limit without putting ten layers of controls on top of each
other :-)).

        EnableFlag = "0" | "1"

This value simply specifies, whether the control is initially enabled or
disabled. You can change the enable state of a control at any time while
your dialog macro is executing.

        X1, Y1, X2, Y2 = OrdinalNumber

These are the coordinates of the upper left and lower right corners of the
control. Their values also are in the range 0..255 and are relative to the
upper left corner of the dialog window itself. Well, there is one important
exception: the "dialog" control. In this case the coordinates are relative
to the upper left corner of the screen itself.

        Title = any string

E.g., this might be "Cancel", "O&k" or "&Yes". These examples show, that the
hot key of any control is defined by placing an "&" immediately in front of
the respective character in the title of the control. If you do not include
an "&" that control doesn't have a hotkey.

        Hint = any string

A hint is some (presumably helpful) text, which is displayed at the help
line whenever and as long as the control has the input focus. This one is
completely optional.



7. The Binary Dialog Resource
-----------------------------

We must also briefly discuss the structure of the binary dialog resource,
because you have to interact with this data structure while Dialog.MAC is
executing. (Don't panic! In most any case this interaction is as simple as
issuing an CurrChar(POS_ID) call.)

The (binary) dialog resource is located in a system buffer, while Dialog.MAC
is executing. It contains one line for each control you put into the dialog.
The focused control (the one which currently accepts input) is the current
line. This means, e.g., that the current line will move downward within the
resource buffer, when the user is tabbing through the dialog, and that it
will move upward, when the user is back-tabbing. When the top or bottom of
the buffer is reached, it wraps around. When the user types a hotkey or
clicks a control with the mouse, the current line is immediately changed to
reflect the new input focus.

The format of a line within the binary resource is almost identical to its
ASCII counterpart. Well, comments, include statements and symbolic constants
have been stripped away by the resource compiler. Moreover, two additional
items have been introduced: the location and value of the hotkey (oh well,
the "&" has also been stripped away from the title during this process).
Finally all the decimal numbers have been translated to binaries. E.g., each
numerical data field now only occupies one column of the file and the ASCII
value of that character is the value of that number. The reason for this is,
that it is much easier and faster to access binary data within a fixed
formatted data structure during runtime, than to parse ASCII data each time
you need it.

The following table shows a breakdown of the data structure of a line within
the resource buffer.

    Column |  Symbolic    |  Value         |  Comment
           |  Constant    |                |
   --------+--------------+----------------+-------------------------------
       1   |  POS_CNTRL   |  CNTRL_XXXX    |  control type
       2   |  POS_ID      |  user defined  |  control id
       3   |  POS_ENABLE  |  0 or 1        |  enable flag
       4   |  POS_GROUP   |  0 or 1        |  group flag
       5   |  POS_X1      |  0..255        |  left boundary
       6   |  POS_Y1      |  0..255        |  upper boundary
       7   |  POS_X2      |  0..255        |  right boundary
       8   |  POS_Y2      |  0..255        |  bottom boundary
       9   |  POS_HKPOS   |  0..255        |  position of hotkey in title
      10   |  POS_HTKEY   |  character     |  the hotkey
      11   |  POS_TITLE   |  character     |  first character of title

You will never have to access the following items directly, because they are
either completely under the control of Dialog.S or because there is a more
comfortable way in using the external functions of the library: the control
type, the enable flag, the group flag, the title (including the hotkey info)
and the hint. This leaves the control id and the control coordinates. You
will need the coordinates only, if you should design a custom control. Thus,
in most any case the only thing you really have to know, is how to get the
control id. And as I already have you told, this is done by issuing an
CurrChar(POS_ID) call, which returns exactly that piece of information.

Finally, please heed the following advice: the resource data is READ ONLY.
Never change it directly. The result is unsatisfactory at least and might
very well hang your machine.



8. Controls
-----------

This section gives you a detailed description of each of the control types,
its data and how its title is used. Moreover, it shows you how the various
control types interact with each other and how you must arrange them so that
this interaction is working smoothly.


8.1. The Dialog Control
-----------------------

This control is a special case. First, there is one (and only one) dialog
control per dialog and, second, as I already have told you, this control
must be the first control within the resource. It serves the following
purposes:

(i)     it is used by Dialog.S to check, if the dialog resource it has been
        passed actually is a dialog resource,
(ii)    it defines the size and initial position of the dialog,
(iii)   it paints the close box [x] near the upper right corner of the dialog
        window and cancels the dialog, if the user clicks on that box,
(iv)    it displays the dragging frame and moves the dialog, when the user
        moves the dialog with the mouse.

You should never disable this control, because this would prohibit the user
from moving the dialog and it would also disable the close box. Users don't
expect either thing to happen. Finally, the id of the dialog control always
must be zero. (DC will remind you about this fact, though :-)).

Types:          dialog

Data:           none

Title:          the title of the dialog

Remarks:        This control ignores the hotkey.


8.2. Text and Frames
--------------------

The various types of Text and Frames are quite similar. They serve either
one of two purposes:

(i)     display some informative text
        (these controls usually have an id, but no hotkey),
(ii)    function as a label for another control
        (these controls usually have no id, but an hotkey).

These controls never gain the input focus. If you use them as labels, you
must place them immediately in front of the labeled control within the
resource file. The reason is, that they simply issue a forward tab, when
their hotkey is executed, which effectively focuses the labeled control.

Types:          ltext, ctext, rtext, frame

Data:           none

Title:          the text, which the control (initially) displays


8.3. EditControls
-----------------

These are full featured text editors, which are limited to one line only.
You can bind a history list to them, which is opened when the user types a
<CursorUp> or <CursorDown>. The text from the history list is inserted
automatically (c.f. OpenControl).

Types:          edit

Data:           history id or 0, if there isn't any history data

Title:          the text, which the control should initially display

Remarks:        To change the text of the control during runtime, use
                DlgSetTitle. To retrieve it, when the dialog terminates,
                use DlgGetTitle. This control ignores the hotkey.


8.4. PushButtons
----------------

PushButtons are used to execute actions within a dialog and often also close
the dialog. There are three special PushButtons. If there is a button with
an id of ID_HELP within your dialog, it will automatically be bound to the
special hotkey <F1> (you should label such a button with "Help"). If a
button with an in of ID_CANCEL is present, it is bound to the <Escape> key
(label it "Cancel"). Finally, if a control has the type "defbtn" it is the
default PushButton, which is executed when the user types <Enter>. This
button isn't automatically bound to the id ID_OK. Moreover, there should be
one and only one default button within any dialog. Everything else will not
only greatly confuse the user, but it won't work either.

Types:          button, defbtn

Data:           none

Title:          the label of the button


8.5. CheckBoxes and RadioButtons
--------------------------------

These are switches. CheckBoxes, although usually grouped together, stand for
options which are independent from each other, while RadioButtons represent
a one of many choice. There is only one thing to remember. Since all dialog
data is initialized to be zero, no RadioButton will initially be marked. You
must do this yourself within the DataInit callback function. To retrieve the
state of these controls, use DlgGetData.

Types:          check, radio

Data:           state of control

Title:          the label of the control


8.6. ListBoxes and ComboBoxes
-----------------------------

ListBoxes and ComboBoxes are similar. Both display lists of strings where
exactly one item can be chosen as the current item. A ListBox constantly
displays a section of its list, while a ComboBox displays only the current
item (a ComboBox has to be explicitly opened to change the current
selection). ListBoxes use ScrollBar controls to scroll the contents of the
list, if the latter includes more items than the ListBox can display at a
time. A ComboBox uses a DropDownList to display its contents. The buffers
which contain the lists must be supplied by your dialog macro. Moreover, you
must set the control data of these controls within the DataInit callback
function (otherwise the controls wouldn't know what to display ;-)). The
current item within the list is determined by the current line of the list
buffer. This means, that you can set the current item during initialization
by setting the current line within the list buffer. To determine which item
is marked when the dialog terminates, query the current line within the list
buffer (CurrLine). The item itself is retrieved using the GetText function.

Types:          list, combo

Data:           id of the buffer containing the list

Title:          none


8.7. ScrollBars
---------------

ScrollBars are used to scroll the contents of a control with the mouse. They
come in two flavors: horizontal and vertical ones. Controls can have up to
two ScrollBars. These must be placed immediately after the control they
should interact with within the dialog resource file. If you want to use
ScrollBars with a list box, you won't have to do anything else. Everything
that is necessary for this interaction to take place, is already built right
into Dialog.S. If you want to use ScrollBars with a custom control, it takes
a bit more fiddling around to make things work, but that isn't tremendously
difficult either (c.f. TestDlg2.S and the callback functions GetListPos,
GetListLen and SetListPos, which are explained in section 10).

Types:          hscroll, vscroll

Data:           none

Title:          none


8.8. ConnectControl
-------------------

This serves as "connector piece" between a vertical and horizontal
ScrollBar. No further functionality, just beautification.

Types:          scredge

Data:           none

Title:          none


8.9. OpenControl
----------------

This is also something fairly simple: it's a spot where the user can
click with the mouse to open a DropDownList (either an edit history or
the list of a ComboBox). There is only one thing you must remember when
using an OpenControl (everything else goes on auto pilot): This control
must be placed immediately after the control within the resource file it
should open. The reason is that an OpenControl issues a <Shift Tab>
followed by an <Alt CursorDown>, effectively focusing the control in
front of it. (Actually, it's the other way round, because PushKey is
used :-).)

Types:          open

Data:           none

Title:          none


8.10. Custom Controls
---------------------

This control is the most simple in terms of predefined behavior, but the
most complicated to implement, because Dialog.S doesn't know and doesn't
assume anything about it. It serves as placeholder for something which is
not yet invented. If you want to implement a custom control, please
carefully read the next to last section within this guide, it shows you, how
you can do this.

Types:          control

Data:           undefined

Title:          undefined



9. Public Library Functions
---------------------------

This section briefly describes the public functions which Dialog.S exports.
These functions are used to control various aspects of a running dialog.
They are issued from a callback function located within your dialog macro.


9.1. DlgGetVersion
------------------

This function is used to query the Dialog version number.

Version:        1.10

Arguments:      none

Return Value:   string VERSION
                the version number (format #.##)

Example:        integer hi,lo
                string ver[8]

                if isMacroLoaded("DlgGetVersion")
                    ExecMacro("DlgGetVersion")
                    ver = Query(MacroCmdLine)
                else
                    ver = "1.00"
                endif
                hi = Val(GetToken(ver,".",1))
                lo = Val(GetToken(ver,".",2))

Remarks:        c.g. ScVer.SI which defines a function CheckVersion
                that can be used for version checking.


9.2. DlgGetUnload
-----------------

This function is used to query the unload status. When unload is 1 (TRUE)
the library will be unloaded (purged) whenever the topmost dialog is
terminated, otherwise it will remain resident. The default value of UNLOAD
is FALSE.

Version:        1.10

Arguments:      none

Return Value:   integer UNLOAD
                unload status

Remark:         the unload status is saved within the cfg file


9.3. DlgSetUnload
-----------------

This function is used to set the Dialog unload status (c.f. DlgGetUnload).

Version:        1.10

Arguments:      integer UNLOAD
                unload status

Return Value:   none


9.4. DlgGetDblTime
------------------

This function is used to query the double click delay time, e.g. the time
which may pass between two mouse clicks so that the second one is still
considered a double click. This time is measured in clock ticks and its
default value is 9.

Version:        1.10

Arguments:      none

Return Value:   integer DBL_DELAY
                double click delay in clock ticks

Remark:         the double click delay is saved within the cfg file
                c.f. DlgInitMouseLoop and DlgMouseDoubleClick


9.5. DlgSetDblTime
------------------

This function is used to set a new double click delay time.

Version:        1.10

Arguments:      integer DBL_DELAY
                double click delay in clock ticks

Return Value:   none

Remark:         DO NOT USE THIS FUNCTION!


9.6. DlgGetColor
----------------

Retrieves the value of a color variable (c.f. section 3.6). If the color is
not definied, the return value is -1.

Version:        1.10

Arguments:      string COLOR_ENTRY
                name of color variable

Return Value:   integer ATTRIBUTE
                color value (screen attribute)


9.7. DlgSetColor
----------------

Changes an existing color variable or defines a new one. These variables
must be in the form ControlName_ColorEntry, where

ControlName     is the (unique) name, which identifies either a
                pre-defined control type or a custom control, and

ColorEntry      is the name for one of the colors which are used
                to paint the control.

The underscore character is mandatory. Color changes will not take affect
until the next Paint function is called. Thus, in order to display all
changes immediately you should use DlgPaintWindow (c.f. 9.11).

Version:        1.10

Arguments:      string COLOR_ENTRY
                name of color variable
                integer ATTRIBUTE
                color value (screen attribute)

Return Value:   none


9.8. DlgLoadSetup
-----------------

This function is used to load the dialog setup file. In general it is not
necessary to explicitly call DlgLoadSetup, since this is automatically done
during the initialization of the libraries.

Version:        1.10

Arguments:      none

Return Value:   none


9.9. DlgSaveSetup
-----------------

This function is used to save the dialog setup on disk. DlgSetup uses
DlgSaveSetup to create a new cfg file, if one doesn't already exist.
Furthermore, it can be used to save custom colors definied via DlgSetColor.
This allows the user to edit custom colors the same way as the predefined
ones.

Version:        1.10

Arguments:      none

Return Value:   none

Example:        c.f. DlgAscii.S (function AsciiDataInit)


9.10. DlgShowWindow
-------------------

This may be used to temporarily hide a dialog window. It is mandatory to
re-display (show) the dialog before your callback function returns. (It is
a bit inconvenient to interact with invisible controls :-)).

Version:        1.10

Arguments:      integer SHOW
                0 to hide the dialog and 1 to show it

Return Value:   none


9.11. DlgPaintWindow
--------------------

This repaints the dialog by simply closing and re-opening the dialog window.
Repainting the entire dialog should only be necessary in rare circumstances.

Version:        1.10

Arguments:      none

Return Value:   none


9.12. DlgPaintCntrl
-------------------

This function is used to immediately re-paint the specified control, which
is only necessary in rare circumstances.

Version:        1.00

Arguments:      integer CNTRL_ID
                the id of the control which should be re-painted

Return Value:   none

Example:        ExecMacro(Format("DlgPaintCntrl ",ID_LST_FILES))


9.13. DlgMoveCntrl
------------------

This function is used to move and/or resize the focused control (this may
include the dialog window itself).

WARNING:
The control is neither cleared at its old position nor is it repainted at
its new position. Therefore, using this function is only meaningful when the
dialog isn't currently displayed (c.f. ShowWindow). Since the dialog isn't
displayed until the DataInit callback has returned, it is safe to use this
function during the initialization phase of a dialog.

Version:        2.00

Arguments:      integer NEW_X1
                integer NEW_Y1
                integer NEW_X2
                integer NEW_Y2
                these are the new coordinates of the control

Return Value:   none

Example:        c.f. ScOp32W.SI, which adapts the size of the dialog
                window to the current height of the screen


9.14. DlgExecCntrl
------------------

This function is used to move the input focus to the specified control. Both
controls, the one which loses the focus and the one which gains the focus,
are re-painted automatically. Moreover, this function generates KillFocus
and SetFocus callback messages.

WARNING:
DlgExecCntrl should be used judiciously. The user does not expect that the
input focus jumps around wildly while he's interacting with a dialog.

WARNING:
Do not use DlgExecCntrl just prior to terminating a dialog (DlgTerminate),
since it pushes a KEY_NOTHING onto the event queue which would otherwise be
inserted into the user file.

The most common use of DlgExecCntrl is to move the focus back into a
ListBox, after the user pressed a PushButton which does not close the
dialog.

Version:        1.00

Arguments:      integer CNTRL_ID
                the id of the control which should receive the focus

Return Value:   none

Example:        ExecMacro(Format("DlgExecCntrl ",ID_LST_FILES))


9.15. DlgGetEnable
------------------

This function is used to retrieve the enable state of the specified control.

Version:        1.00

Arguments:      integer CNTRL_ID
                the id of the control whose state should be determined

Return Value:   integer STATE
                either 0 if the control is disabled or 1 otherwise

Example:        ExecMacro(Format("DlgGetEnable ",ID_OK))
                state = Val(Query(MacroCmdLine))


9.16. DlgSetEnable
------------------

This function is used to enable or disable the specified control. The
control is re-painted automatically.

Version:        1.00

Arguments:      integer CNTRL_ID
                the id of the control whose state should be changed
                integer NEW_STATE
                either 0 to disable the control or 1 to enable it

Return Value:   none

Example:        ExecMacro(Format("DlgSetEnable ",ID_OK," 0"))


9.17. DlgGetTitle
-----------------

This function retrieves the current title of a control. If the title
includes a hotkey, it is marked with an "&".

This function also sets the global variable DlgMsgText (version 2.10 and
later). Using DlgMsgText is the only way to retrieve titles which exceed
the maximum size of MacroCmdLine.

Version:        1.00, 2.10

Arguments:      integer CNTRL_ID
                the id of the control whose title should be retrieved

Return Value:   string TITLE
                the current title of the control

Set Variable:   DlgMsgText = TITLE

Example:        ExecMacro(Format("DlgGetTitle ",ID_CLOSE))
                title = Query(MacroCmdLine)  // might be "&Close"


9.18. DlgSetTitle
-----------------

This function assigns a new title to the specified control. The control
is re-painted automatically. If the control should have a hotkey you must
prefix the respective character with an "&". If the value of the prefixed
character changes, the hotkey also changes.

Version:        1.00

Arguments:      integer CNTRL_ID
                the id of the control whose title should be changed
                string NEW_TITLE
                the new title of the control

Return Value:   none

Example:        ExecMacro(Format("DlgSetTitle ",ID_CLOSE," &Explode"))
                ExecMacro(Format("DlgSetTitle ",ID_EDIT," text to edit"))


9.19. DlgSetTitleEx
-------------------

This function works analogos to DlgSetTitle, but uses DlgMsgText instead
of MacroCmdLine to pass the new title of the control. This is the only way
to set control titles which exceed the maximum size of MacroCmdLine.

Version:        2.10

Arguments:      integer CNTRL_ID
                the id of the control whose title should be changed

Get Variable:   NEW_TITLE = DlgMsgText

Return Value:   none

Example:        SetGlobalStr(DlgMsgText,LongText)
                ExecMacro(Format("DlgSetTitleEx ",ID_EDIT))


9.20. DlgGetHint
----------------

This function retrieves the current hint of a control.

Version:        1.10

Arguments:      integer CNTRL_ID
                the id of the control whose hint should be retrieved

Return Value:   string HINT
                the current hint of the control

Example:        ExecMacro(Format("DlgGetHint ",ID_CLOSE))
                hint = Query(MacroCmdLine)


9.21. DlgSetHint
----------------

This function assigns a new hint to the specified control. The help line
is re-painted automatically, if the control is currently focused.

NOTE:
Due to the maximum size of MacroCmdLine the size of NEW_HINT is limited to
approximately 100 characters.

Version:        1.00

Arguments:      integer CNTRL_ID
                the id of the control whose hint should be changed
                string NEW_HINT
                the new hint line of the control

Return Value:   none

Example:        ExecMacro(Format("DlgSetHint ",ID_CLOSE," Don't touch"))


9.22. DlgGetData
----------------

This function retrieves the data of a control.

Version:        1.00

Arguments:      integer CNTRL_ID
                the id of the control whose data should be retrieved

Return Value:   variant DATA
                the current data of the control

Example:        ExecMacro(Format("DlgGetData ",ID_EDIT))
                edit_hist = Val(Query(MacroCmdLine))


9.23. DlgSetData
----------------

This function assigns new data to a control. The control is re-painted
automatically.

Version:        1.00

Arguments:      integer CNTRL_ID
                the id of the control whose data should be changed
                variant NEW_DATA
                the new data of the control

Return Value:   none

Example:        ExecMacro(Format("DlgSetData ",ID_EDIT," ",new_hist))


9.24. DlgGetHScroll
-------------------

This function is used to query the parameters which determine horizontal
scrolling.

Version:        1.10

Arguments:      none

Return Value:   integer HSCROLL_PAGE
                the horizontal page size of the list
                integer HSCROLL_LENGTH
                the horizontal size of the list


9.25. DlgSetHScroll
-------------------

This function is used to set the parameters which determine horizontal
scrolling. The standard values are: 8 for HSCROLL_PAGE and 128 for
HSCROLL_LENGTH. If you want to change these, you should do this within the
SetFocus callback function whenever the corresponding list (or custom
control) is activated. These parameters are reset to their default values
during the init phase of a dialog (prior to the InitData call back).

Version:        1.10

Arguments:      integer HSCROLL_PAGE
                the horizontal page size of the list
                integer HSCROLL_LENGTH
                the horizontal size of the list

Return Value:   none


9.26. DlgInitMouseLoop
----------------------

Use this function to initialize the secondary event loop of a custom control
which should be mouse sensitive. This function serves a twofold purpose.
First, it pushes the last event back onto the keystack which allows the
control to "see" the mouse immediately. Second, it initializes double click
handling (c.f. section 13.4).

Version:        1.20

Arguments:      none

Return Value:   none

Example:        c.f. DlgAscii.S


9.27. DlgMouseClick
-------------------

This function is used to check, if the last mouse click hit a custom
control (c.f. section 13.4).

Version:        1.20

Arguments:      none

Return Value:   integer HIT
                1, if the mouse hit the control, 0 otherwise

Example:        c.f. DlgAscii.S


9.28. DlgMouseDoubleClick
-------------------------

Checks, if the last mouse click actually was a double click. Function
DlgMouseClick MUST be called prior to DlgMouseDoubleClick.

Version:        1.20

Arguments:      none

Return Value:   integer DOUBLE
                1, if it was a double click, 0 otherwise

Example:        c.f. DlgAscii.S


9.29. DlgMouseXOffset
---------------------

This function returns the x-offset of the last mouse click from the upper
left corner of a custom control. The offset is zero based.

Version:        1.20

Arguments:      none

Return Value:   integer X_OFFSET
                distance of last mouse click from left boundary of control

Example:        c.f. DlgAscii.S


9.30. DlgMouseYOffset
---------------------

This function returns the y-offset of the last mouse click from the upper
left corner of a custom control. The offset is zero based.

Version:        1.20

Arguments:      none

Return Value:   integer Y_OFFSET
                distance of last mouse click from top boundary of control

Example:        c.f. DlgAscii.S


9.31. DlgGetEvent
-----------------

This function returns a dialog event waiting for the next key stroke or
mouse click if necessary. You should use it instead of directly calling
GetKey. Using DlgGetEvent will generate Event and Idle messages.

Version:        1.20

Arguments:      [integer LEVEL]
                nesting level of event loops (defaults to 1)

Return Value:   integer EVENT
                the key code

Example:        c.f. section 13.4 and TestDlg2.S


9.32. DlgGetRefCount
--------------------

This function returns the library reference count, e.g. the number of
currently active dialog macros. This function can be used to determine
if it is safe to unload the library.

Version:        1.10

Arguments:      none

Return Value:   integer REF_COUNT
                the library reference count

Example:        c.f. DlgSetup.S


9.33. DlgTerminate
------------------

This function initiates the shutdown process of a dialog. If you do not
specify an explicit return code, the latter will be set to the id of the
currently focused control.

Version:        1.00

Arguments:      [integer RET_CODE]
                the optional return code of the dialog

Return Value:   none

Example:        ExecMacro(Format("DlgTerminate ",ID_CANCEL))




10. Callback Functions (Messages)
---------------------------------

This section describes the messages which Dialog.S is sending to your dialog
macro whenever something interesting is happing within the dialog. You must
not forget to prefix the names of these functions with the unique string you
used on the Dialog macro call, otherwise Dialog.S will be unable to find
your callback functions (c.f. section 3.3 and the example dialogs). Whenever
a callback function is issued, the resource buffer, e.g. the buffer which
holds the binary dialog resource, is the current buffer. Moreover, the line
which corresponds to the focused control is the current line.

WARNING:
You MUST NOT change this. E.g., you may switch buffers while program control
is back within your dialog macro, but at the moment your callback function
returns, the resource buffer MUST be the current buffer. Furthermore, you
MUST NOT explicitly change the current line within the resource buffer. If
you want to move the input focus to another control, use DlgExecControl
instead. In other words, the dialog resource is READ ONLY. (If you don't
heed this bit of advice, you most probably will hang your machine.)

To make things a bit easier, you do not have to return to the resource
buffer, whenever you execute a call to the external functions which Dialog.S
provides. These will position themselves automatically and they will also
restore the state of the buffers before they return.

If you closely examined the list of callback functions which follows, you
might find that an important piece of information is not included into their
argument lists: the id of the current control. This was done on purpose,
since it is much easier (and faster) to query the current control id
directly. To get the id of the current control use CurrChar(POS_ID). This is
best done immediately after the callback function is entered.


10.1. DataInit
--------------

This is the first callback Dialog.S issues. It is executed immediately after
the basic data of the dialog has been set up, but before the dialog appears
on-screen. It is most commonly used to initialize the data of the dialog. It
may also be used to move the focus to some other than the default startup
control. (On default, Dialog.S activates the first control which accepts the
input focus.)

Version:        1.00

Arguments:      none

Return Value:   none

See Also:       DlgSetData, DlgSetTitle, DlgExecControl


10.2. DataDone
--------------

This is the last callback Dialog.S issues. It is executed immediately after
the dialog has been removed from the screen, but before any data is cleaned
up. It is most commonly used to retrieve data from the dialog.

Version:        1.00

Arguments:      none

Return Value:   none

See Also:       DlgGetData, DlgGetTitle


10.3. Idle
----------

This message is issued whenever Dialog is querying an empty input queue. It
is most useful for executing lengthy tasks which should not render the user
interface inoperational. There are a few things to consider when using this
message. First, return early and return often, otherwise the response of the
dialog to user input may become sluggish. Second, disable all those controls
which are not ready to interact with the user while the dialog is executing
its task (this may well mean everything except the Cancel button). Finally,
this message doesn't allow programming non-modal dialogs. (A non-modal
dialog actually is a window masquerading as a dialog box and Dialog.S only
provides for (real) dialogs and not for (overlapping) windows.)

Version:        1.10, 1.20

Arguments:      integer LEVEL
                the nesting level of event loops

Return Value:   none

Remarks:        It is not save to change the input focus when LEVEL is
                greater than zero (c.f. DlgExecCntrl).


10.4. Event
-----------

Whenever Dialog retrieves user input it issues an event message. This
allows for message filtering and custom hot keys.

It is not save to change the input focus when LEVEL is greater than zero
(c.f. DlgExecCntrl). Nonetheless, you can implement custom hot keys. C.f.
section 12.1 which explains how to do that.

Version:        1.10, 1.20, 2.00 (enhanced doc)

Arguments:      integer LEVEL
                the nesting level of event loops

Return Value:   none

Example:        public proc ExampleEvent()
                    if Query(Key) == <Del>
                        Set(Key,<Alt R>)
                    endif
                end

Remarks:        It is not save to change the input focus when LEVEL is
                greater than zero (but c.f. section 12.1).


10.5. SetFocus
--------------

This message is issued, whenever a control gains the input focus. At the
moment of the callback, it is already the focused control, but it has not
yet been re-painted in its active state.

Version:        1.00

Arguments:      none

Return Value:   none


10.6. KillFocus
---------------

This message is issued, whenever a control loses the input focus. At the
moment of the callback, it is still the focused control, but has already
been re-painted in its non-active state.

Version:        1.00

Arguments:      none

Return Value:   none


10.7. RightClk
--------------

This message is issued, whenever a control is clicked with the right
mouse button. A dialog macro should do nothing but set the return value
on receipt of this message. Especially, it should not pop up a context
menu yet, c.f. next section.

Version:        1.21

Arguments:      none

Return Value:   integer ACCEPT
                "1" if the control accepts right clicks, "0" otherwise


10.8. Context
-------------

If a control accepts right button clicks to pop up a context menu, it
should do so whenever it receives this message.

Version:        1.21

Arguments:      none

Return Value:   none


10.9. EditSetIndex
------------------

This callback is issued immediately before an EditControl is executed. It
allows you to set the initial position of the cursor. If INDEX is zero, the
default startup index is used (Length(text)+1).

Version:        1.10

Arguments:      none

Return Value:   integer INDEX
                the initial position of the cursor

Example:        c.f. DlgFind


10.10. EditSetMark
------------------

This callback is issued immediately before an EditControl is executed. It
allows you to change the initial mark. If MARK_BEG is zero, the default is
used (marking everything). To entirely removed the mark use any values for
which the following is true 1 <= MARK_BEG == MARK_END <= Length(text+1).


Version:        1.20

Arguments:      none

Return Value:   integer MARK_BEG
                the index of the first marked character
                integer MARK_END
                the index of the first character beyond the mark

Example:        c.f. DlgFind


10.11. EditChanged
------------------

This is issued, whenever an event is processed by an EditControl and allows
you to control which characters are accepted. E.g., if an EditControl should
accept only digits, you can use this callback to reject anything else.
Non-typable keys (e.g. cursors keys) produce negative values for NEW_CHAR.
These simply are the negative key codes.

This message also sets the global variable DlgMsgText (version 2.10 and
later). The value of DlgMsgText is the current text of the EditControl.
Using DlgMsgText is the only way to retrieve the full text of the control
when its size exceeds ca. 100 characters. The arguments still include
OLD_TEXT for backwards compatibility, but the latter might be truncated due
to the maximum size of MacroCmdLine.

Version:        1.00, 1.10, 2.10

Arguments:      integer OLD_INDEX
                the current position of the cursor
                integer NEW_CHAR
                the character entered (negative keycode if non-character)
                string OLD_TEXT
                the current contents of the EditControl

Return Value:   integer ACCEPT
                "1" if the character can be accepted, "0" otherwise

Set Variable:   DlgMsgText = OLD_TEXT

Example:        c.f. DlgGoto

Remarks:        This message has been enhanced with version 1.10 and is not
                fully backward compatible to version 1.00. It now allows you
                to monitor what's going on inside an EditControl in full
                detail.


10.12. EditKill
---------------

This callback is issued immediately after an EditControl stops executing.
It allows you to monitor the position of the cursor and mark inside an
EditControl. Use this callback to store the relevant indexes and use
EditSetIndex and/or EditSetMark to restore them.

Version:        1.20

Arguments:      integer INDEX
                the current position of the cursor
                integer MARK_BEG
                the index of the first marked character
                integer MARK_END
                the index of the first character beyond the mark

Return Value:   none

Example:        c.f. DlgFind


10.13. BtnDown
--------------

This message is triggered by two events: whenever a PushButton is pressed
and whenever the state of a CheckBox is toggled. Use CurrChar(POS_ID), to
determine which control has been affected.

Version:        1.00

Arguments:      none

Return Value:   none

Example:        public proc ExampleBtnDown()
                    case CurrChar(POS_ID)
                        when ID_OK      ExecMacro("DlgTerminate")
                        when ID_HELP    Help()
                        // don't need otherwise,
                        // simply let them fall through
                    endcase
                end


10.14. SelChanged
-----------------

This message is triggered whenever the user

(i)     moves the mark within a group of RadioButtons,
(ii)    moves the highlight within a ListBox,
(iii)   changes the current item within a DropDownList
        (both history lists of EditControls and the lists of ComboBoxes).

Version:        1.00

Arguments:      none

Return Value:   none


10.15. DblClick
---------------

This is issued whenever the user double clicks an item within a ListBox. The
usual reaction to this message is to execute the action which is connected
with the DefaultPushButton.

Version:        1.00

Arguments:      none

Return Value:   none

Remarks:        The messages issued by a ListBox occur in the following
                order:
                (i)     AnchorList,
                        whenever an incremental search starts
                (ii)    SelChanged.
                        whenever the user moves the highlight
                (iii)   DblClick,
                        whenever the user double clicks an item
                Don't depend on the order of (i) and (ii), though!


10.16. AnchorList
-----------------

This message is issued whenever a list, e.g. ListBox or DropDownList, is
activated. It queries, if the incremental search, which is active within
these lists, should be anchored to the beginning of the lines. If you don't
answer this call, the incremental search will not be anchored.

Version:        1.00

Arguments:      none

Return Value:   integer ANCHOR_LIST
                "1" if the search should be anchored, "0" otherwise


10.17. FixedList
-----------------

This message is issued whenever a DropDownList is activated. It queries,
whether the vertical size of the list should be adjusted or not, if the
number of items contained in the list is smaller than its visual length
(either designed or adjusted via the DropDown message). If you don't answer
this call, the list will be adjusted, e.g. it will shrink so that no empty
lines are visible.

Version:        2.01

Arguments:      none

Return Value:   integer FIXED_LIST
                "1" if the length of the list should be fixed, "0" otherwise


10.18. DropDown
---------------

This is triggered before a DropDownList is opened. It allows you to change
the default size and position of the list. If you don't answer this call,
the default values are used.

Version:        1.00

Arguments:      integer LEFT, TOP, WITDH, HEIGHT
                the default values of the list's position and size

Return Value:   integer LEFT, TOP, WITDH, HEIGHT
                the custom values of the list's position and size


10.19. CloseUp
--------------

This message is triggered after a DropDownList has been closed.

Version:        1.00

Arguments:      none

Return Value:   none

Remarks:        The messages issued by a DropDownList occur in the following
                order:
                (i)     AnchorList
                (ii)    FixedList
                (iii)   DropDown
                (iv)    SelChanged,
                        unless the user closed the list with an <Escape>
                (v)     CloseUp


10.20. PaintCntrl
-----------------

This function is called, when a custom control must be painted. To determine
which control needs painting, use CurrChar(POS_ID). When you use custom
controls, you MUST answer this call, otherwise custom controls will never
appear on-screen.

Version:        1.00

Arguments:      integer STATE
                the state of the control:
                STATE_DISABLE, STATE_NORMAL or STATE_ACTIVE

Return Value:   none


10.21. GotoCntrl
----------------

This function is called, to determine if a specific custom control will
accept the input focus, when an event has occurred. When you use custom
controls, you MUST answer this call, otherwise custom controls will never be
focused.

Version:        1.00

Arguments:      integer EVENT
                the type of the event which just has occurred
                (one of the EVENT_XXXX values, c.f. Dialog.SI)

Return Value:   integer ACCEPT
                "1" if the event will be handled by the control,
                "0" otherwise


10.22. ExecCntrl
----------------

This function is called, whenever a custom control gets the input focus. To
determine which control is executed, use CurrChar(POS_ID). When you use
custom controls, you MUST answer this call, otherwise custom controls won't
do anything.

WARNING:
At a minimum, an enabled control must respond to the EVENT_TAB event by
pushing the most recent key back onto the key stack, PushKey(Query(Key)),
otherwise the focus may become stuck at a control which is not ready to
handle it.

Version:        1.00

Arguments:      integer EVENT
                the type of the event which just has occurred
                (one of the EVENT_XXXX values, c.f. Dialog.SI)

Return Value:   none


10.23. MouseHit
---------------

This message is used to determine, if a custom control has been hit with the
mouse. The area of a control which responds to a mouse click can be smaller
than the area of the control which is defined in the dialog resource (c.f.
EditControl and ComboBox). If you don't answer this call, the area which is
defined in the dialog resource will be used. It is somewhat tedious to
compute mouse coordinates (c.f. MouseHit and MouseHitFirstLine in dialog.s).

Version:        1.00

Arguments:      none

Return Value:   integer HIT
                "1" if the mouse hit the control, "0" otherwise

Remarks:        You MUST NOT use DlgMouseClick within this call back,
                because the latter depends on this call back to check,
                if the mouse actually hit the control.


10.24. GetListPos
-----------------

This function is called, when you use a ScrollBar in connection with a
custom control. Whenever the ScrollBar needs to know which item is the
current item within your control, it issues GetListPos (c.f. TestDlg2.S).

Version:        1.00

Arguments:      integer CNTRL_TYPE
                type of the ScrollBar (CNTRL_HSCROLL or CNTRL_VSCROLL)

Return Value:   integer POSITION
                the current position of the control


10.25. GetListLen
-----------------

This function is called, when you use a ScrollBar in connection with a
custom control. Whenever the ScrollBar needs to know the current number
of items your control contains, it issues GetListLen (c.f. TestDlg2.S).

Version:        1.00

Arguments:      integer CNTRL_TYPE
                type of the ScrollBar (CNTRL_HSCROLL or CNTRL_VSCROLL)

Return Value:   integer POSITION
                the current number of items of the control


10.26. SetListPos
-----------------

This function is called, when you use a ScrollBar in connection with a
custom control. Whenever the ScrollBar has changed its position, it calls
SetListPos, so that the list can adjust itself accordingly.

Version:        1.00

Arguments:      integer CNTRL_TYPE
                type of the ScrollBar (CNTRL_HSCROLL or CNTRL_VSCROLL)
                integer NEW_POSITION
                the new current position of the control

Return Value:   none



11. Tracing Dialogs
-------------------

The dialog run time libraries (Dialog.S and DialogP.S) include conditional
code which allows you to trace the flow of your programming logic. To
activate this code you have to use the -dTRACE switch when compiling the
libraries. The trace itself is produced by a stand alone macro named
DbgTrace.S. The latter will be automatically loaded by Dialog.S if you use
the trace enabled libraries.

The trace is accumulated in a file named "dbgtrace.lst" which includes the
following information (one line per trace point):

    MacroStackAvail     the amount of free memory on TSE's macro stack
                        (This doesn't include memory used by the trace
                        call itself.)
    BufferId            the id of the current buffer
    CurrLine            the current line within the current buffer
    CurrCol             ditto: current column
    CurrChar            ditto: current character
                        (The ascii code will be dumped, if a control
                        character is encountered. Moreover, the character
                        dumped can be fixed to a specific column.
                        When tracing dialogs this _is_ fixed to POS_ID,
                        effectively dumping the control id.)
    CurrFileName        the name of the current buffer
                        (This column if optional and, in fact, is disabled
                        when tracing dialogs. The dialog resource is a
                        system buffer and thus doesn't have a name ;-).)
    Comment             some "arbitrary" text
                        (When tracing dialogs this is the name of the
                        traced function.)

DbgTrace isn't limited to be used only in conjunction with the dialog
libraries, it may be used to trace any macro. Actually, it does include a
simple user interface which allows you to start and stop tracing and also
interactively insert trace points into your code. The menu of DbgTrace is
accessed using <CtrlShift F12> (if that key doesn't fit into your UI, go
ahead and change it). Maybe the best thing to do, if you want to learn more
about DbgTrace, is to inspect its source code, which isn't terribly long and
complicated.

One final note: trace points are activated in a rather peculiar way, e.g.

    SetGlobalStr('DbgTraceArgs','some comment to be sent to the trace')
    PressKey(0xFFFE)

The reason for this is, that calling a trace point must not alter the layout
of the stack frame of the current function in any way. Especially, it must
not add additional string data, in order that the trace produces a correct
picture of the stack usage of your macro(s). Unfortunately, ExecMacro uses a
temporary string whenever it is called with an argument. In other words, it
adds 257 bytes to the stack frame, unless the latter already includes at
least one temporary string. Thus, I had to resort to some less obvious
method to activate a trace point. Please note that DbgTrace reserves the
key code 0xFFFE, which is linked to the trace point routine. This
doesn't affect your daily work, though, since 0xFFFE isn't a "real" key.



12. Customizing Dialogs
-----------------------

The dialog library can be customized in several ways. It allows you to
define custom hot keys. Moreover, you can alter the response of standard
controls and even design all new custom controls (c.f. section 13).


12.1. Custom Hot Keys
---------------------

The main dialog library only checks the user input for a fixed set of hot
keys, e.g. numbers, digits and some special keys (F1, Tab, Esc, Enter). You
can, however, include additional hot keys into your dialogs.

This is extremely easy, if the new key is only an alias for an existing hot
key, which can be handled by the dialog library. The only thing you must do
in this case, is to hook into the Event callback (c.f. section 10.4) and
replace any custom alias by its conventional counterpart.

        proc ExampleEvent
            case Query(Key)
                when <Del>  Set(Key,<Alt D>)
            endcase
        end

Also compare for DlgBuff and DlgRcnt which use this technique.

Things are more complicated, if you want to make an all new stand alone hot
key. Especially if pressing this hot key also means switching focus. The
reasons is that in order to catch a custom hot key you have to hook into the
Event callback, but you cannot switch the focus from inside this callback
when the LEVEL is greater than zero (c.f. sections 9.14 and 10.4), e.g. when
a secondary event loop is active. You have to terminate the secondary event
loop using the KEY_BREAK event, before you can switch the focus and execute
whichever action is appropriate for your custom hot key, e.g. pressing a
PushButton. These two actions are most conveniently linked through an user
defined event (or message).

        constant KEY_USER = 0xFFE0

        integer proc CheckHotKey()
            if Query(Key) == <Ctrl Tab>         // check for custom key
                Set(Key,KEY_BREAK)              // break out of inner loop
                PushKey(KEY_USER)               // queue custom event
                return(TRUE)
            endif
            return(FALSE)
        end

        proc ExecHotKey()
            if Query(Key) == KEY_USER           // check for custom event
                                                // switch focus and push btn
                ExecMacro(Format("DlgExecCntrl ",ID_BTN))
                PushKey(<Enter>)
            endif
        end

        proc ExampleEvent
            if CheckHotKey()        // found custom key
                // NOP              // -> return to terminate inner loops
            else                    // otherwise
                ExecHotKey()        // -> can safely switch focus
            endif
        end

Also compare for ScOp32W.SI which makes extensive use of this technique.

Since custom events are nothing but "faked" key strokes, you have to be a
bit careful when defining them in order not to use the codes of real keys.
Codes in the range 0xFFE0 to 0xFFEF are a good choice. Please note that the
codes 0xFFF0 to 0xFFFF are reserved by the dialog library.


12.2. Customizing Standard Controls
-----------------------------------

Sometimes you want to do something special which cannot quite be done using
a standard control, but which isn't far enough off the beaten track so that
writing a custom control is worthwhile. Dialogs includes a couple of hooks
which allow you to customize standard controls to some extend.

First and foremost, each time a control gains or looses the input focus you
will receive SetFocus and KillFocus messages. These messages can be used to
adapt the response of controls so that they depend on the state of other
controls. E.g., you might want to disable a PushButton unless a certain
CheckBox is marked or a specific control is active.

Furthermore, each control sends messages, if it is clicked with the right
mouse button (RightClk, Context). The usual response to these messages is to
pop up a context menu which gives the user the opportunity to customize the
response of the respective control, e.g. by changing the sort order within a
ListBox.

Finally, several controls send special messages which allow you to fine
tune their response to user input. For instance, the contents, position and
size of a DropDownList is completely under the control of your dialog macro.
It is perfectly legal to change the contents of a DropDownList while it is
open and reset its contents after it has been closed.



13. Custom Controls
-------------------

A custom control is a control which is not made available by Dialog.S.
Nevertheless, Dialog.S includes enough hooks, so that you can construct your
own controls without changing the library itself. But doing so requires a
thorough understanding of the inner workings of Dialog.S. You have been
warned, so off we go. (Please study TestDlg2.S. It implements two (rather
silly) custom controls. But also showcases a few techniques which might be
helpful in your own work.)


13.1. The Main Event Loop
-------------------------

First of all, we have to take a closer look on the main event loop of
Dialog.S, because that is where the hooks which allow custom controls are
installed. The basic logic of this loop is as follows:

        repeat
            "get an event and search addressee"
            "ask addressee, if it will accept the focus"        (ii)
            if "focus changes"
                "re-paint previously focused control"
                "send KillFocus and SetFocus messages"
            endif
            "paint hint of the focused control"
            "execute the focused control"                       (iii)
        until terminate

If you study this piece of pseudo-code carefully, you will notice that each
control type is defined by three routines:

(i)     PaintCntrl, defines the visual appearance of a control
(ii)    GotoCntrl,  defines the types of events a control will respond to
(iii)   ExecCntrl,  defines how a control interacts with the user

GotoCntrl and ExecCntrl are essentially called only by the event loop, while
PaintCntrl is called from many places. E.g., the event loop repaints a
control in its normal state when it loses the focus, but it doesn't paint
it in its active state when it gains the focus. Thus, it's the ExecCntrl
function's task to take care about that. The pseudo-code also shows, that a
control doesn't have to paint its hint and it doesn't have to know when and
how it is activated.


13.2. Painting Controls
-----------------------

When a custom control needs painting, it will receive a Paint message (c.f.
section 10.19). There are only two things you must remember when painting
controls. First, a control must always completely paint the rectangle it is
responsible for and it must be able to react to the three basic states of a
control (STATE_NORMAL, STATE_DISABLE and STATE_ACTIVE). Your control might
actually define more states, but these are completely under the control of
your ExecCntrl routine, because Dialog.S doesn't know and doesn't care about
them.

Dialog.S provides some API calls which allow you to install color palettes
for your custom controls. These are stored within the dialog configuration
file and can be edited using DlgSetup.S. Doing so is fairly simple. (The
following piece of pseudo code is supposed to be located somewhere within
the InitData callback.)

        "query all custom colors (DlgGetColor)"

        if "some attribute is -1"
            "set all custom colors to default values"
            "install custom colors (DlgSetColor)"
            "save new configuration (DlgSaveSetup)"
        endif

See DlgAscii.S, if you're looking for an example.


13.3. Answering Events
----------------------

Dialog.SI defines a couple of event types (EVENT_XXXX). If your control
does something useful, it will surely answer a view of them (c.f. section
10.20). But even when it is completely ornamental, it MUST at least answer
the EVENT_TAB call (c.f. next section). Here are some examples:

        public proc MinimumGotoCntrl()
            integer event = Val(Query(MacroCmdLine))

            Set(MacroCmdLine,Str( event == EVENT_TAB ))
        end

        public proc StandardGotoCntrl()
            integer event = Val(Query(MacroCmdLine))

            Set(MacroCmdLine,Str( event <> EVENT_GROUP ))
        end


13.4. Executing Controls
------------------------

ExecCntrl is the part of your code which defines what a control actually
does. It is called whenever the control gets the input focus (c.f. section
10.21).

There are two type of controls: those which do something useful and those
which only display something (presumably useful :-)). The latter usually
never grab the input focus, they just pass it on:

        public proc MinimumExecCntrl()
            PushKey(Query(Key))
        end

The reason behind this (admittedly silly) piece of code is, that the dialog
resource doesn't include any information about tab stops, e.g., tab stops
must be handled by the controls' exec functions.

(Well, why not having explicit tab stops? Actually, life's easier without
them. First, you don't have to care about tab stops while putting together
the resource file (I always forget the most crucial ones). Second, purely
ornamental control types are rare. The odds are, that everything which is
ornamental is already included in Dialog.S, and the latter uses a single
routine to handle the situation.)

The other case (a control which actually does something) may again be
divided into two subclasses: fairly simple controls (e.g. CheckBoxes) and
complicated ones (e.g. EditControls). In the first case it's best you handle
the incoming event and directly return to the main message loop:

        public proc SimpleExecCntrl()
            event = Val(Query(MacroCmdLine))

            SimplePaintCntrl(STATE_ACTIVE)
            case event
                when EVENT_HTKEY, EVENT_MOUSE
                    DoSomething()
                otherwise
                    if Query(Key) == <Spacebar>
                        DoSomethingElse()
                    endif
            endcase
        end

If you have to deal with a more complicated control, the best thing to do is
to enter a secondary event loop, which might look like this:

        public proc ElaborateExecCntrl()
            event = Val(Query(MacroCmdLine))

            ExecMacro("DlgInitMouseLoop")       // (*)

            loop
                ElaboratePaintCntrl(STATE_ACTIVE)

                ExecMacro("DlgGetEvent")        // get the event
                code = Val(Query(MacroCmdLine))

                case code

                    when KEY_BREAK      // get out immediately
                        return()        // do _not_ push back last key

                                                // mouse handling
                    when <LeftBtn>
                        ExecMacro("DlgMouseClick")
                        if Val(Query(MacroCmdLine))
                            ExecMacro("DlgMouseDoubleClick")
                            if Val(Query(MacroCmdLine))
                                DoubleClickHandler()
                            else
                                SingleClickHandler()
                            endif
                        else
                            break
                        endif

                    when .....          // usually a lot of additional whens

                    otherwise           // don't know what to do with it
                        break           // so let's call it quits
                endcase
            endloop

            PushKey(code)               // this is essential, since
        end                             // we didn't handle the last event

        (*) This construct is DANGEROUS! If you use it, make sure that
            you properly handle any mouse event within your message loop.
            Otherwise you will produce an INFINITE LOOP. Thus, double
            check any mouse coordinates you compute and test your code
            extensively. (Click and/or double click just inside and
            just outside the lower right corner of your control!)

This doesn't look too complicated, but beware, in real life these case
statements tend to become rather lengthy (c.f. ExecEdit in Dialog.S). Well,
that's about all I have to say on this subject. It certainly will take some
experiments and fiddling around, until your first custom control will work
the way it is supposed to. Just don't forget that this package contains a
lot of examples to steal from (you might find that a few of these even do
some useful work :-)).



14. History or What Has Been New
--------------------------------


14.1. Version 1.00
------------------

First try. Had all the basic ideas, but also many rough edges and some bugs.


14.2. Version 1.10
------------------

The most prominent new feature of version 1.10 is the configuration API and
the accompanying setup program (DlgSetup). Furthermore, there are a couple
of new hooks which allow you to fine tune message handling and horizontal
scrolling. Finally, one or two rough edges have been somewhat smoothed.

New configuration API
        DlgGetUnload, DlgSetUnload
        DlgGetDblTime, DlgSetDblTime
        DlgGetColor, DlgSetColor
        DlgLoadSetup, DlgSaveSetup

New external functions
        DlgGetVersion
        DlgShowWindow, DlgPaintWindow
        DlgGetHint
        DlgGetHScroll, DlgSetHScroll
        DlgGetRefCount

New messages
        Idle, Event
        EditSetIndex

Enhanced message
        EditChanged


14.3. Version 1.20
------------------

The most important addition to the new version is the dialog editor DE. It
is fully mouse driven and allows you to build and edit dialog resources
visually. Other enhancements include:

- EditControl
    CUA style shift marking, full clipboard and mouse support
    (includes marking) and local pop up menu (press RightBtn)
- Input boxes
    the InpBox library now allows you to add a help button which
    calls back your dialog macro
- Mouse API
    added API functions which considerably simplify computing
    mouse events inside a custom control's event handler
- External GetEvent function
    retrieves an event for a custom control's event handler
    (ensures that Idle and Event messages are generated)

New external functions
        GetEvent
        InitMouseLoop
        MouseClick, MouseDoubleClick
        MouseXOffset, MouseYOffset

New messages
        EditSetMark, EditKill

Enhanced messages
        Idle, Event (both fully backward compatible)

Fixed message
        EditChanged (returned new index instead of old)

Again, a couple of bugs have been fixed (c.f. the file header of dialog.s,
if you're interested in details).


14.4. Version 1.21
------------------

This versions adds two new messages to dialogs which allow you to pop up
a context menu whenever a control is clicked with the right mouse button.

New messages
        RightClk, Context


14.5. Version 1.22
------------------

This update corrects bugs and adds a couple of new paragraphs to the
programmers' guide (check out 10.4. Event).


14.6. Version 1.23
------------------

This is a bug fix only and doesn't includes any new programmers' stuff.


14.7. Version 2.00
------------------

This version defines a new API function and is compatible with versions 2.5
and 2.6 of the editor. The dialog libraries now include conditional code
which allows you to trace the flow of the programming logic (c.f. DbgTrace
and section 12).

All the painting routines have been moved out of Dialog and into DialogP,
because macro space finally became too crowded within Dialog (at least for
version 2.5 of TSE). These changes are completely transparent for both users
and programmers. DialogP defines some API functions which are used by the
main library to communicate with its sidekick. These functions have
deliberately been left undocumented, because there's absolutely no reason to
call them directly. Actually, it might prove disastrous to do so. If you're
really interested in the minute details, well, go ahead and check out the
source code.

Finally, you may want to check out sctoken.si which includes a couple of
simple routines designed to parse quoted command lines.

New external function
        MoveCntrl

New documentation
        (11) Tracing Dialogs
        (12) Customizing Dialogs


14.8. Version 2.10
------------------

Updates 2.01 through 2.10 fix some bugs (will the EditControl ever work
the way it is supposed to <sigh>) and add some new goodies. First of all
there is a new example dialog (TestDlg4), which demonstrates the usage of
the Idle callback. A new message (FixedList) can be used to fix the size
of DropDownLists. Finally, a global string variable (DlgMsgText) has been
added, which allows to pass string arguments exceeding the maximum size of
MacroCmdLine. This allows for much larger texts inside EditControls.
Search for "DlgMsgText" to find out how to uses this feature.

New example
        [2.01]  TestDlg4 (works for TSE32 only)

New external functions
        [2.10]  DlgSetTitleEx (uses DlgMsgText)

New message
        [2.01]  FixedList

New global variable
        [2.10]  DlgMsgText (used to pass long string arguments)

Fixes
        [2.10]  dialog windows are now horizontally centered on the screen
        [2.10]  more fixes (EditControl, painting Hint, incr. search)
        [2.02]  more fixes (EditControl, TracePointKey)
        [2.01]  GetEvent, painting (used GotoXY instead of VGotoXY)



15. Limitations
---------------

There currently exist a few limitations concerning the functionality of
Dialog.S. They exist, because I either haven't had a better idea on how to
solve the specific problem or because I simply was to lazy to care about
some minor points. Here's s short list of those things I'm aware of:

-       Dialog.S works in color mode only.
        (B&W mode, to a certain extend, is painted completely different
        as compared to color mode. Thus, I didn't include it, because
        nowadays practically anybody owns a color screen and because this
        would have bloated Dialog.S to even a bigger size.)

-       The number of lines the screen scrolls per second, when you hold
        down the mouse key while it is on a ScrollBar is hard coded. The
        list will scroll 18 lines per second (one line per clock tick).
        (Actually, I have no idea how to change this, since MouseRepeatDelay
        is inherently machine dependent and doesn't conform to any real
        world time. Albeit, the solution would be a simple one, if SAL
        provided a WaitMouseRepeatDelay function.)

Well, if you should have any (severe) complaints about these restrictions or
have found something which I have missed, please let me know. Suggestions,
discussions and error reports always are welcome. You will find my e-mail
address at the end of the users' guide. BTW, you should have read the latter
before this one anyway, because it includes vital information, even for a
programmer <RBG>.

