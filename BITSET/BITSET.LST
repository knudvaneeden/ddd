Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 1
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Preliminaries

      1					     IDEAL
      2				     ;******************************************************************************;
      3				     ;										    ;
      4				     ;			      CRAZY JACK'S BIT SET ROUTINES			    ;
      5				     ;										    ;
      6				     ; (c)Copyright 1993 by Jack Hazlehurst					    ;
      7				     ; Author :	Jack Hazlehurst							    ;
      8				     ; Date   :	07/01/93							    ;
      9				     ;										    ;
     10				     ; Use  the	binary to your heart's content when you	customize your copy of The  ;
     11				     ; Semware Editor.	If you modify it (creating a  derivative  work)	 you  MUST  ;
     12				     ; retain the copyright notice, and	add your own if	you wish.  Just	don't make  ;
     13				     ; anyone pay any more for its use than I charge you (which	is nothing).	    ;
     14				     ;------------------------------------------------------------------------------;
     15				     ; These are routines to convert bit strings to and	from the character strings  ;
     16				     ; used by WordSet and VarTabs.  SAL does not support this for variables.	    ;
     17				     ;										    ;
     18				     ; The routines are	defined	by:						    ;
     19				     ;	 binary	["bitset.bin"]							    ;
     20				     ;	     integer proc WrdChrs2WrdSet( string LetterSet, var	string Result ):  0 ;
     21				     ;	     integer proc TabSet2TabPosns( string VTabSet, var string TabStr ) :  3 ;
     22				     ;	     integer proc TabPosns2TabSet( string TabStr, var string VTabSet ) :  6 ;
     23				     ;	     integer proc WrdSet2WrdChrs( string BitSet, var string Result )   :  9 ;
     24				     ;	 end									    ;
     25				     ;										    ;
     26				     ; Further details are given below with each routine.			    ;
     27				     ;										    ;
     28				     ; This assembles with the Turbo Assembler v 3.2 and better	(and maybe worser). ;
     29				     ;										    ;
     30				     ; Some  attention has been	paid to	reducing the number of jumps along the most ;
     31				     ; likely path in loops, which sometimes gives rise	to odd sequences.	    ;
     32				     ;										    ;
     33				     ; Alas, the calling sequence used by SAL precludes	our using  the	fancy  PROC ;
     34				     ; parameter addressing features of	the Turbo Assembler, which assumes that	the ;
     35				     ; BP has been pushed on the stack just after the call.			    ;
     36				     ;										    ;
     37				     ;******************************************************************************;
     38
     39	0000				    SEGMENT _TEXT
     40					    ASSUME  CS:_TEXT
     41					    LOCALS
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 2
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
The Entry Vector

     42				     ;...............................................................................
     43				     ; The  following  macro aligns each jump on a 3 byte boundary.  That way, the
     44				     ; "binary"	declaration within the macro file can assume each function  starts
     45				     ; on the next multiple of 3.
     46
     47					     MACRO   JUMP dest	     ;force a 3	byte jump
     48					     DB	     0E9H	     ;;jmp
     49					     DW	     OFFSET dest - $ - 2
     50					     ENDM
     51				     ;...............................................................................
     52
     53	0000				     PROC    VECTORS
     54
     55					     JUMP    WC2WS	     ;WrdChrs2WrdSet()
1    56	0000  E9			     DB	     0E9H	     ;
1    57	0001  00C9			     DW	     OFFSET WC2WS - $ -	2
     58					     JUMP    TS2TP	     ;TabSet2TabPosns()
1    59	0003  E9			     DB	     0E9H	     ;
1    60	0004  013F			     DW	     OFFSET TS2TP - $ -	2
     61					     JUMP    TP2TS	     ;TabPosns2TabSet()
1    62	0006  E9			     DB	     0E9H	     ;
1    63	0007  01B8			     DW	     OFFSET TP2TS - $ -	2
     64				     ;	     JUMP    WS2WC	     ;WrdSet2WrdChrs() (not real jump; just falls in)
     65
     66	0009				     ENDP    VECTORS
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 3
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Convert	a WordSet Bit Set To A Character String

     67				     ;===============================================================================
     68				     ;
     69				     ;	     integer proc WrdSet2WrdChrs( string BitSet, var string Result ) : 9
     70				     ;
     71				     ;	     This  routine  examines  the  bits	 in  the bit set string	given by
     72				     ;	     "BitSet" and  builds  a  string  in  "Result"  that  sepcifies  the
     73				     ;	     characters	to be selected.	 If the	result string is not long enough
     74				     ;	     to	hold the complete resulting string, WrdSet2WrdChrs returns zero,
     75				     ;	     otherwise it returns 1.
     76				     ;
     77				     ;-------------------------------------------------------------------------------
     78
     79	0009				     PROC    WS2WC FAR
     80
     81					     ;The stack:
     82	      =	[DWORD BP+10]	     @@BtSt  EQU     [DWORD BP+10]	     ;Bit set string to	convert.
     83	      =	[DWORD BP+6]	     @@Rslt  EQU     [DWORD BP+6]	     ;A	Character string to receive result.
     84	      =	[BYTE BP+4]	     @@MaxRL EQU     [BYTE BP+4]
     85				     ; ret address   BP+0
     86	      =0002			     LOCAL   @@SWITCH :	BYTE = @@VARSIZ
     87	      =0001		     @@NEEDASH =     1
     88
     89	0009  8B EC			     MOV     BP, SP		     ;Address parameters.
     90	000B  83 EC 02			     SUB     SP, @@VARSIZ	     ;Allocate local variable
     91	000E  C6 46 FE 00		     MOV     [@@SWITCH], 0	     ;Don't need a dash.
     92	0012  FC			     CLD
     93	0013  C4 7E 06			     LES     DI, @@Rslt		     ;Point to start of	result string.
     94	0016  8A 56 04			     MOV     DL, @@MaxRL	     ;Get maximum result string	size allowed.
     95	0019  FE C2			     INC     DL			     ;Set up result size limit counter.
     96	001B  C5 76 0A			     LDS     SI, @@BtSt		     ;Point to bit set.
     97	001E  AD			     LODSW			     ;Get its length.
     98
     99	001F  8A C8			     MOV     CL, AL		     ;Set byte count for bit set.
    100	0021  FE C1			     INC     CL
    101	0023  33 DB			     XOR     BX, BX		     ;Output length = 0.
    102	0025  8A F7			     MOV     DH, BH		     ;Flag "we don't need a dash".
    103	0027  8A EF			     MOV     CH, BH		     ;Initialize character value.
    104	0029  B6 01			     MOV     DH, 1		     ;Set a testing bit.
    105
    106	002B  EB 06			     JMP     @@STATE0B		     ;Begin the	processing.
    107				     ;
    108				     ; This routine is organized as a state machine, but it uses the program
    109				     ; counter as the state variable.
    110				     ;
    111				     ; Register	useage:	AL - current byte of bit set being tested.
    112				     ;			BX - index into	result string (and result length, thereby)
    113				     ;			CH - value of current character
    114				     ;			CL - bytes remaining to	check in bit set string
    115				     ;			DH - Counts bits by shifting.
    116				     ;			DL - count to limit result size
    117				     ;			DS:SI -	pointer	to current byte	in bit set string
    118				     ;			ES:DI -	pointer	to result string
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 4
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Convert	a WordSet Bit Set To A Character String

    119				     ;
    120				     ; In state	0 we are looking for a character that is by itself, or starts
    121				     ; a range.
    122				     ;
    123	002D			     @@STATE0A:
    124	002D  80 4E FE 01		     OR	     [@@SWITCH], @@NEEDASH   ;Flag "we need a dash".
    125	0031  EB 0E			     JMP     @@STATE0
    126	0033			     @@STATE0B:
    127	0033  FE C9			     DEC     CL			     ;Any more bytes to	process?
    128	0035  74 74			     JZ	     @@DUN		     ;Jump if not
    129	0037  AC			     LODSB			     ;else get next byte.
    130	0038  0A C0			     OR	     AL, AL		     ;Any bits in this byte at all?
    131	003A  75 0B			     JNE     @@STATE0C		     ;Go process them if yes,
    132	003C  80 C5 08			     ADD     CH, 8		     ;else count across	all 8 bits
    133	003F  EB F2			     JMP     @@STATE0B		     ;and try the next byte.
    134	0041			     @@STATE0:
    135	0041  FE C5			     INC     CH			     ;Value of next character.
    136	0043  D0 C6			     ROL     DH, 1		     ;Next bit to test.
    137	0045  72 EC			     JC	     @@STATE0B		     ;Jump if bits in byte exhausted.
    138	0047			     @@STATE0C:
    139	0047  D0 E8			     SHR     AL, 1		     ;Is this bit on?
    140	0049  73 F6			     JNC     @@STATE0		     ;Keep looking if not.
    141
    142	004B  80 FD 2D			     CMP     CH, '-'		     ;This bit stand for dash?
    143	004E  74 DD			     JE	     @@STATE0A		     ;Jump if it does.
    144				     ;
    145				     ; In state	1 we have a character.	It may start a group, or it may	be a
    146				     ; stand-alone character.  We'll find out.
    147				     ;
    148	0050  FE CA			     DEC     DL			     ;Be sure we have room for a character.
    149	0052  74 68			     JZ	     @@OFLO		     ;Jump if no more room.
    150	0054  43			     INC     BX			     ;Where new	output character goes.
    151	0055  26: 88 69	01		     MOV     [ES:DI+BX+1], CH	     ;Move character to	output string.
    152
    153	0059  FE C5			     INC     CH			     ;Value of next character.
    154	005B  D0 C6			     ROL     DH, 1		     ;Next bit to test.
    155	005D  73 05			     JNC     @@STATE1A		     ;Jump if bits in byte not exhausted.
    156
    157	005F  FE C9			     DEC     CL			     ;Any more bytes to	process?
    158	0061  74 48			     JZ	     @@DUN		     ;Jump if not.
    159	0063  AC			     LODSB			     ;Get next byte of bit set.
    160	0064			     @@STATE1A:
    161	0064  D0 E8			     SHR     AL, 1		     ;Is this bit on?
    162	0066  73 D9			     JNC     @@STATE0		     ;If not, there's no sequence.
    163									     ;We may have two in a row.
    164	0068  80 FD 2D			     CMP    CH,	'-'		     ;This bit stand for dash?
    165	006B  74 C0			     JE	    @@STATE0A		     ;Sequence is broken if it does.
    166				     ;
    167				     ; In state	2 we've	got two	characters in a	row and	we're looking for three.
    168				     ;
    169	006D  FE CA			     DEC     DL			     ;Be sure we have room for a character.
    170	006F  74 4B			     JZ	     @@OFLO		     ;Jump if no more room.
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 5
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Convert	a WordSet Bit Set To A Character String

    171	0071  43			     INC     BX			     ;Where new	output character goes.
    172	0072  26: 88 69	01		     MOV     [ES:DI+BX+1], CH	     ;Move character to	output string.
    173
    174	0076  FE C5			     INC     CH			     ;Value of next character.
    175	0078  D0 C6			     ROL     DH, 1		     ;Next bit to test.
    176	007A  73 05			     JNC     @@STATE2A		     ;Jump if bits in byte not exhausted.
    177
    178	007C  FE C9			     DEC     CL			     ;Any more bytes to	process?
    179	007E  74 2B			     JZ	     @@DUN		     ;Jump if not.
    180	0080  AC			     LODSB			     ;Get next byte of bits.
    181	0081			     @@STATE2A:
    182	0081  D0 E8			     SHR     AL, 1		     ;Is this bit on?
    183	0083  73 BC			     JNC     @@STATE0		     ;If not, the sequence is just two long.
    184
    185	0085  FE CA			     DEC     DL			     ;Be sure we have room for 3rd character.
    186	0087  74 33			     JZ	     @@OFLO		     ;Jump if no more room.
    187	0089  43			     INC     BX			     ;Where 3rd	output character goes.
    188	008A  26: C6 01	2D		     MOV     [BYTE ES:DI+BX], "-"    ;Overwrite	2nd character with dash.
    189	008E  EB 07			     JMP     @@STATE3		     ;Go find last character of	series.
    190				     ;
    191				     ; In state	3 we have a sequence three or more characters long and we are looking
    192				     ; for the end of the sequence.
    193				     ;
    194	0090			     @@STATE3A:
    195	0090  FE C9			     DEC     CL			     ;Any more bytes to	process?
    196	0092  74 0F			     JZ	     @@STATE3C		     ;Jump if not.
    197	0094  AC			     LODSB			     ;Get next byte of set.
    198	0095  EB 04			     JMP     @@STATE3B
    199	0097			     @@STATE3:
    200	0097  D0 C6			     ROL     DH, 1		     ;Next bit to test.
    201	0099  72 F5			     JC	     @@STATE3A		     ;Jump if bits in byte not exhausted.
    202	009B			     @@STATE3B:
    203	009B  FE C5			     INC     CH			     ;Value of next character.
    204	009D  D0 E8			     SHR     AL, 1		     ;Is this bit on?
    205	009F  72 F6			     JC	     @@STATE3		     ;If yes, we're still in sequence.
    206
    207	00A1  FE CD			     DEC     CH			     ;Retrieve last character.
    208	00A3			     @@STATE3C:
    209	00A3  26: 88 69	01		     MOV     [ES:DI+BX+1], CH	     ;Move 3rd character to output string.
    210	00A7  FE C5			     INC     CH			     ;Back to current character.  (Will	wrap
    211									     ;to zero at end!)
    212	00A9  75 96			     JNZ     @@STATE0		     ;Jump if more characters to go.
    213	00AB			     @@DUN:
    214	00AB  F6 46 FE 01		     TEST    [@@SWITCH], @@NEEDASH   ;Do we need a dash?
    215	00AF  75 0F			     JNZ     @@DODASH		     ;Jump if not.
    216	00B1			     @@OKAY:
    217	00B1  B8 0001			     MOV     AX, 1		     ;Return "TRUE".
    218	00B4			     @@STRSIZ:
    219	00B4  26: 89 1D			     MOV     [ES:DI], BX	     ;Store result string size in string.
    220	00B7  33 D2			     XOR     DX, DX		     ;Clear high-order word of return value.
    221
    222	00B9  8B E5			     MOV     SP, BP		     ;Toss local variables.
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 6
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Convert	a WordSet Bit Set To A Character String

    223	00BB  CB			     RETF			     ;Back to the caller.
    224
    225	00BC			     @@OFLO:			     ;We have overflowed the Result area.
    226	00BC  33 C0			     XOR     AX, AX		     ;Return "FALSE".
    227	00BE  EB F4			     JMP     @@STRSIZ
    228
    229	00C0			     @@DODASH:			     ;We need an explicit dash.
    230	00C0  FE CA			     DEC     DL			     ;Be sure we have room for it.
    231	00C2  74 F8			     JZ	     @@OFLO		     ;Jump if we don't,
    232	00C4  43			     INC     BX			     ;else add a dash to end of	string.
    233	00C5  26: C6 41	01 2D		     MOV     [BYTE ES:DI+BX+1],	"-"  ;Stash the	dash.
    234	00CA  EB E5			     JMP     @@OKAY		     ;Go finish	up.
    235
    236	00CC				     ENDP    WS2WC
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 7
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Convert	A Character String To A	WordSet	Bit Set

    237				     ;===============================================================================
    238				     ;
    239				     ;	     integer proc WrdChrs2WrdSet( string LetterSet, var	string Result )	: 12
    240				     ;
    241				     ;	     This procedure takes a string of letters specifying the contents of
    242				     ;	     a WordSet bit string and produces the bit string.	 If  the  result
    243				     ;	     string  is	 not EXACTLY 32	bytes long, it is forced to 32 bytes and
    244				     ;	     cleared; otherwise	it is assumed to be a legit WordSet bit	 string,
    245				     ;	     and  the  characters called for by	the "LetterSet"	string are ADDED
    246				     ;	     to	it.  If	this is	not the	effect you want, either	 clear	the  bit
    247				     ;	     string  yourself  (using ClearBitSet()), or set it	to "".	If there
    248				     ;	     are no  problems,	WrdChrs2WrdSet	returns	 TRUE.	 The  only  real
    249				     ;	     problem  it  can  have is if the Result string maximum size is less
    250				     ;	     than 32 bytes.  In	this case, the Result string is	not changed, and
    251				     ;	     WrdChrs2WrdSet returns FALSE.
    252				     ;
    253				     ;-------------------------------------------------------------------------------
    254
    255	00CC				     PROC    WC2WS FAR
    256
    257					     ;The stack:
    258	      =	[DWORD BP+10]	     @@LtrSt EQU     [DWORD BP+10]	     ;String of	letters	to put in word set.
    259	      =	[DWORD BP+6]	     @@Rslt  EQU     [DWORD BP+6]	     ;Where to build the word set bit array.
    260	      =	[WORD BP+4]	     @@MaxRL EQU     [WORD BP+4]	     ;There had	BETTER be at least 32 bytes!
    261				     ; ret address   BP+0
    262
    263	00CC  8B EC			     MOV     BP, SP		     ;Address parameters.
    264	00CE  FC			     CLD
    265	00CF  33 D2			     XOR     DX, DX		     ;We'll need this later.
    266	00D1  C4 7E 06			     LES     DI, @@Rslt		     ;Get pointer to result string.
    267	00D4  B8 0020			     MOV     AX, 32
    268	00D7  26: 39 05			     CMP     [ES:DI], AX	     ;Is it EXACTLY 32 bytes long?
    269	00DA  74 13			     JE	     @@USEIT		     ;Yes, keep	it as is.
    270	00DC  39 46 04			     CMP     @@MaxRL, AX	     ;Can it be	made 32	bytes long?
    271	00DF  73 03			     JAE     @@FORCE		     ;Go do it if it can.
    272
    273	00E1  8B C2			     MOV     AX, DX		     ;Can't use	this string.
    274	00E3  CB			     RETF			     ;Return FALSE.
    275
    276	00E4			     @@FORCE:
    277	00E4  AB			     STOSW			     ;Force 32-bit length.
    278	00E5  B9 0010			     MOV     CX, 16		     ;Clear all	bits in	the string.
    279	00E8  8B C2			     MOV     AX, DX
    280	00EA  F3>			     REP
    281	00EB  AB			     STOSW
    282	00EC  83 EF 22			     SUB     DI, 34
    283	00EF			     @@USEIT:
    284	00EF  47			     INC     DI			     ;Simplify addressing of bit set.
    285	00F0  47			     INC     DI
    286	00F1  C5 76 0A			     LDS     SI, @@LtrSt	     ;Point to the spec	string.
    287	00F4  AD			     LODSW			     ;Get string length.
    288	00F5  8A E8			     MOV     CH, AL		     ;Set up counter to	say when we're done.
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 8
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Convert	A Character String To A	WordSet	Bit Set

    289	00F7  FE C5			     INC     CH
    290	00F9  8A FE			     MOV     BH, DH		     ;Ensure high-order	zero.
    291
    292				     ;
    293				     ; As  before,  we use a kind of staste machine in which the program counter
    294				     ; acts as the state variable.  There are only two states  involved	 here  -
    295				     ; processing single characters, and processing ranges.
    296				     ;
    297				     ; Register	useage:	AH - positioned	bit for	ORing into bit set string.
    298				     ;			AL - picking up	characters, and	counting in ranges.
    299				     ;			BX - pointer to	byte where bit is to go.
    300				     ;			CH - count of chars left to process.
    301				     ;			CL - shift counter for positioning bit;	temp holder.
    302				     ;			DX - zero for when we return; supplies zeros to	load, too.
    303				     ;			DS:SI -	points to character string.
    304				     ;			ES:DI -	points to bit set.
    305				     ;
    306				     ; In state	0 we are just looking at single	characters.
    307				     ;
    308
    309	00FB			     @@STATE0:
    310	00FB  FE CD			     DEC     CH			     ;Any more characters to process?
    311	00FD  74 3F			     JZ	     @@DUN		     ;We're finished if	not.
    312	00FF			     STATE0A:
    313	00FF  AC			     LODSB			     ;Get next character to set	bit for.
    314	0100  8A D8			     MOV     BL, AL		     ;Set its bit.
    315	0102  D0 EB			     SHR     BL, 1
    316	0104  D0 EB			     SHR     BL, 1
    317	0106  D0 EB			     SHR     BL, 1
    318	0108  8A C8			     MOV     CL, AL
    319	010A  80 E1 07			     AND     CL, 7
    320	010D  B4 01			     MOV     AH, 1
    321	010F  D2 E4			     SHL     AH, CL
    322	0111  26: 08 21			     OR	     [ES:DI+BX], AH
    323
    324	0114  80 FD 03			     CMP     CH, 3		     ;Do we have AT LEAST two more characters
    325	0117  72 E2			     JB	     @@STATE0		     ;to process? Jump if not,
    326
    327	0119  80 3C 2D			     CMP     [BYTE SI],	'-'	     ;else see if we might have	a range.
    328	011C  75 DD			     JNE     @@STATE0		     ;Jump if not.
    329
    330	011E  3A 6C 01			     CMP     CH, [SI+1]		     ;It might be -- is	end <= start?
    331	0121  77 D8			     JA	     @@STATE0		     ;If not, it isn't a range.
    332
    333				     ;
    334				     ; In state	1 we are processing a range.
    335				     ;
    336	0123  FE CD			     DEC     CH			     ;Count next two xharacters	as
    337	0125  FE CD			     DEC     CH			     ;processed.
    338	0127  8A C8			     MOV     CL, AL		     ;Save start char (still in	AL).
    339	0129  46			     INC     SI			     ;Advance pointer past "-".
    340	012A  AC			     LODSB			     ;Get end character.
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 9
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Convert	A Character String To A	WordSet	Bit Set

    341	012B  2A C1			     SUB     AL, CL		     ;Get difference.
    342	012D  74 CC			     JZ	     @@STATE0		     ;Jump if no more bits to set.
    343
    344	012F			     @@STATE1:
    345	012F  D0 C4			     ROL     AH, 1		     ;Shift to next bit.
    346	0131  72 0F			     JC	     @@STATE1B		     ;Jump if time to go to next byte.
    347	0133			     @@STATE1A:
    348	0133  26: 08 21			     OR	     [ES:DI+BX], AH	     ;Set next bit.
    349	0136  FE C8			     DEC     AL			     ;All bits in series set?
    350	0138  75 F5			     JNZ     @@STATE1		     ;Jump if not.
    351
    352	013A  FE CD			     DEC     CH			     ;Any more characters to process?
    353	013C  75 C1			     JNZ     STATE0A		     ;If yes, go do 'em.
    354	013E			     @@DUN:
    355	013E  B8 0001			     MOV     AX, 1		     ;Return TRUE to caller.
    356	0141  CB			     RETF			     ;All done.
    357
    358	0142			     @@STATE1B:				     ;Advance to next byte.
    359	0142  43			     INC     BX			     ;Bit in AH	will be	in the right place.
    360	0143  EB EE			     JMP     @@STATE1A
    361
    362	0145				     ENDP    WC2WS
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 10
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Convert	A VarTabs Bit Set To An	ASCII String Of	Tab Positions

    363				     ;===============================================================================
    364				     ;
    365				     ;	     integer proc TabSet2TabPosns( string VTabSet, var string TabStr ) : 12
    366				     ;
    367				     ;	     This  procedure  converts a VarTabs bit set into a	character string
    368				     ;	     that lists	the tab	positions.  If	the  "TabStr"  provided	 by  the
    369				     ;	     caller  isn't  big	 enough	to hold	the entire list, TabSet2TabPosns
    370				     ;	     returns FALSE, otherwise it returns TRUE.
    371				     ;
    372				     ;-------------------------------------------------------------------------------
    373
    374	0145				     PROC    TS2TP FAR
    375
    376					     ;The stack:
    377	      =	[DWORD BP+10]	     @@VTSet EQU     [DWORD BP+10]
    378	      =	[DWORD BP+6]	     @@TbStr EQU     [DWORD BP+6]
    379	      =	[BYTE BP+4]	     @@MaxSL EQU     [BYTE BP+4]
    380				     ; ret address   BP+0
    381
    382	0145  8B EC			     MOV     BP, SP		     ;Address parameters.
    383	0147  FC			     CLD
    384	0148  33 DB			     XOR     BX, BX		     ;Initial length of	output string.
    385	014A  C5 76 0A			     LDS     SI, @@VTSet	     ;Point to tabs bit	set.
    386	014D  AD			     LODSW			     ;Get its length.
    387	014E  0A C0			     OR	     AL, AL		     ;Zero length bit set is poopoo.
    388	0150  74 2A			     JZ	     @@DUN
    389	0152  8A C8			     MOV     CL, AL
    390	0154  C4 7E 06			     LES     DI, @@TbStr	     ;Get pointer to result string.
    391	0157  8A 56 04			     MOV     DL, @@MaxSL	     ;Get max length of	output string.
    392	015A  FE C2			     INC     DL
    393	015C  B6 01			     MOV     DH, 1		     ;Initialize bit counter.
    394	015E  8A EF			     MOV     CH, BH		     ;Current character.
    395	0160  EB 0E			     JMP     @@NXTBYT
    396				     ;
    397				     ; Here  is	the main loop of this program.	It checks bits to see which tab
    398				     ; positions are set.  When	it finds one it	goes to	a routine that converts
    399				     ; the position into a character string.
    400				     ;
    401				     ; Register	useage:	AH - used for division
    402				     ;			AL - used for division;	holds current byte from	bit set.
    403				     ;			BX - index into	and current length of result string.
    404				     ;			CH - current character value.
    405				     ;			CL - count number of bit set bytes processed.
    406				     ;			DH - bit-being-tested-in-this-byte counter
    407				     ;			DL - count to limit length of output string.
    408				     ;			DS:SI -	pointer	to VarTabs bit set
    409				     ;			ES:DI -	pointer	to character string being built.
    410				     ;
    411				     ;
    412	0162			     @@NXTBIT:
    413	0162  D0 E8			     SHR     AL, 1		     ;Next bit on?
    414	0164  72 2B			     JC	     @@GOTATAB		     ;Yes, go convert position to number.
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 11
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Convert	A VarTabs Bit Set To An	ASCII String Of	Tab Positions

    415	0166			     @@CNTBIT:
    416	0166  FE C5			     INC     CH			     ;Advance position value.
    417	0168  D0 C6			     ROL     DH, 1		     ;Done with	this byte?
    418	016A  73 F6			     JNC     @@NXTBIT		     ;No, go check next	bit.
    419
    420	016C  FE C9			     DEC     CL			     ;Any more bytes to	process?
    421	016E  74 0C			     JZ	     @@DUN		     ;We're finished if	not.
    422	0170			     @@NXTBYT:
    423	0170  AC			     LODSB			     ;Get the next byte	from bit set.
    424	0171  0A C0			     OR	     AL, AL		     ;Are there	any bits?
    425	0173  75 ED			     JNZ     @@NXTBIT		     ;Yes, go process this byte.
    426
    427	0175  80 C5 08			     ADD     CH, 8		     ;No, skip over these values.
    428	0178  FE C9			     DEC     CL			     ;Any more bytes?
    429	017A  75 F4			     JNZ     @@NXTBYT		     ;Yes, go check next one out.
    430	017C			     @@DUN:
    431	017C  B8 0001			     MOV     AX, 1		     ;Set TRUE for caller.
    432	017F  0B DB			     OR	     BX, BX		     ;Any characters in	result string?
    433	0181  74 08			     JZ	     @@STRSIZ		     ;Jump if not,
    434	0183  26: 80 79	01 20		     CMP     [BYTE ES:DI+BX+1],	' '  ;else see if trailing space.
    435	0188  75 01			     JNE     @@STRSIZ		     ;Jump if no trailing space,
    436	018A  4B			     DEC     BX			     ;else remove it.
    437	018B			     @@STRSIZ:
    438	018B  26: 89 1D			     MOV     [WORD ES:DI], BX	     ;Store length of result string.
    439	018E  33 D2			     XOR     DX, DX		     ;Clear high word of return	code.
    440	0190  CB			     RETF			     ;Back to caller.
    441
    442				     ;
    443				     ; This routine converts the current tab position (in CH) into a decimal
    444				     ; number string.
    445				     ;
    446	0191			     @@GOTATAB:
    447	0191  B4 20			     MOV     AH, ' '		     ;Prepare trailing blank.
    448	0193  50			     PUSH    AX			     ;This also	saves byte being checked.
    449	0194  8A C5			     MOV     AL, CH		     ;Get the position.
    450	0196			     @@XTRACT:
    451	0196  32 E4			     XOR     AH, AH		     ;Set up for divide.
    452	0198  2E: F6 36	0245		     DIV     [BYTE CS:TEN]	     ;Divide by	ten, remainder is in AH.
    453	019D  80 CC 30			     OR	     AH, '0'		     ;Convert to ASCII digit.
    454	01A0  50			     PUSH    AX			     ;Save the digit.
    455	01A1  0A C0			     OR	     AL, AL		     ;Any more original	number left?
    456	01A3  75 F1			     JNZ     @@XTRACT		     ;Extract next digit if yes.
    457	01A5			     @@NXTDGT:				     ;
    458	01A5  58			     POP     AX			     ;Get next digit for output.
    459	01A6  FE CA			     DEC     DL			     ;Room for another char in result string?
    460	01A8  74 0C			     JZ	     @@OFLO		     ;Jump if not,
    461	01AA  43			     INC     BX			     ;else add character to the	end
    462	01AB  26: 88 61	01		     MOV     [ES:DI+BX+1], AH	     ;of the result string.
    463	01AF  80 FC 20			     CMP     AH, ' '		     ;Was it end-of-number trailing space?
    464	01B2  75 F1			     JNE     @@NXTDGT		     ;Go get next digit	if not.
    465
    466	01B4  EB B0			     JMP     @@CNTBIT		     ;Test byte	restored, go check next	bit.
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 12
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Convert	A VarTabs Bit Set To An	ASCII String Of	Tab Positions

    467
    468	01B6			     @@OFLO:
    469	01B6  80 FC 20			     CMP     AH, ' '		     ;Just trailing blank?
    470	01B9  75 AB			     JNE     @@CNTBIT		     ;We can let it go if yes.
    471
    472	01BB  8B E5			     MOV     SP, BP		     ;Bad stuff	if not;	restore	the stack
    473	01BD  33 C0			     XOR     AX, AX		     ;and return FALSE.
    474	01BF  EB CA			     JMP     @@STRSIZ		     ;Back to caller.
    475
    476	01C1				     ENDP    TS2TP
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 13
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Convert	An ASCII String	Of Tab Positions To A VarTabs Bit Set

    477				     ;===============================================================================
    478				     ;
    479				     ;	     integer proc TabPosns2TabSet( string TabStr, var string VTabSet ) : 15
    480				     ;
    481				     ;	     This  is  the obverse of the previous routine: it converts	a string
    482				     ;	     of	tab positions into a bit set.  VTabSet MUST be AT LEAST	32 bytes
    483				     ;	     long.   If	 it is,	the tabs in the	string will be ADDED to	whatever
    484				     ;	     is	already	there, otherwise it will  be  FORCED  to  32  bytes  and
    485				     ;	     cleared, then the new positions will be added.  If	the result CAN'T
    486				     ;	     be	forced to 32 bytes, it remain unchanged	 and  a	 FALSE	will  be
    487				     ;	     returned, otherwise TRUE is returned.
    488				     ;
    489				     ;	     Only  spaces  and	decimal	digits are acceptable.	If there are any
    490				     ;	     other characters found, they will be treated as spaces, but a FALSE
    491				     ;	     will be returned.
    492				     ;
    493				     ;	     The  positions  may  range	 from  zero  through 255, though zero is
    494				     ;	     meaningless and higher values are strange,	too.  Range checking  is
    495				     ;	     NOT  performed; out-of-range numbers are reduced modulo 256 with no
    496				     ;	     error flagged.
    497				     ;
    498				     ;-------------------------------------------------------------------------------
    499
    500	01C1				     PROC    TP2TS FAR
    501
    502					     ;The stack:
    503	      =	[DWORD BP+10]	     @@TbStr EQU     [DWORD BP+10]	     ;String of	tab positions in ASCII.
    504	      =	[DWORD BP+6]	     @@VTSet EQU     [DWORD BP+6]	     ;Where to build the tab set bit array.
    505	      =	[WORD BP+4]	     @@MaxSL EQU     [WORD BP+4]	     ;There had	BETTER be at least 32 bytes!
    506				     ; ret address   BP+0
    507
    508	01C1  8B EC			     MOV     BP, SP		     ;Address parameters.
    509	01C3  FC			     CLD
    510	01C4  33 D2			     XOR     DX, DX
    511	01C6  C4 7E 06			     LES     DI, @@VTSet	     ;Get pointer to result string.
    512	01C9  B8 0020			     MOV     AX, 32
    513	01CC  26: 39 05			     CMP     [ES:DI], AX	     ;Is it EXACTLY 32 bytes long?
    514	01CF  74 13			     JE	     @@USEIT		     ;Yes, keep	it as is.
    515	01D1  39 46 04			     CMP     @@MaxSL, AX	     ;Can it be	made 32	bytes long?
    516	01D4  73 03			     JAE     @@FORCE		     ;Go do it if it can.
    517
    518	01D6  8B C2			     MOV     AX, DX		     ;Can't use	this string.
    519	01D8  CB			     RETF			     ;Return FALSE.
    520
    521	01D9			     @@FORCE:
    522	01D9  AB			     STOSW			     ;Force 32-bit length.
    523	01DA  B9 0010			     MOV     CX, 16		     ;Clear all	bits in	the string.
    524	01DD  8B C2			     MOV     AX, DX
    525	01DF  F3>			     REP
    526	01E0  AB			     STOSW
    527	01E1  83 EF 22			     SUB     DI, 34
    528	01E4			     @@USEIT:
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 14
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Convert	An ASCII String	Of Tab Positions To A VarTabs Bit Set

    529	01E4  47			     INC     DI			     ;Simplify addressing of bit set.
    530	01E5  47			     INC     DI
    531	01E6  C5 76 0A			     LDS     SI, @@TbStr	     ;Point to the spec	string.
    532	01E9  AD			     LODSW			     ;Get string length.
    533	01EA  8A E8			     MOV     CH, AL		     ;Set up counter to	say when we're done.
    534	01EC  FE C5			     INC     CH
    535	01EE  8A FE			     MOV     BH, DH		     ;Ensure high-order	zero.
    536	01F0  FE C2			     INC     DL			     ;No bad characters	-- yet...
    537	01F2  EB 0C			     JMP     @@NXTCHR		     ;Begin processing.
    538
    539				     ;
    540				     ; Nothing tricky here, though the instruction ordering is aimed at	reducing
    541				     ; overall execution time on an 8088.
    542				     ;
    543				     ; Register	useage:	AH - positioned	bit for	ORing into bit set string.
    544				     ;			AL - picking up	characters.
    545				     ;			BX - pointer to	byte where bit is to go.
    546				     ;			CH - count of chars left to process.
    547				     ;			CL - shift counter for positioning bit;	ASCII to binary	conv.
    548				     ;			DH - handy zero.
    549				     ;			DL - 1 unless bad character found, then	zero.
    550				     ;			DS:SI -	points to ASCII	tab position string.
    551				     ;			ES:DI -	points to bit set.
    552				     ;
    553	01F4			     @@QTAB:
    554	01F4  3C 09			     CMP     AL, 9		     ;Is it a tab?
    555	01F6  74 08			     JE	     @@NXTCHR		     ;Yes, is okay delimiter.
    556
    557	01F8  8A D6			     MOV     DL, DH		     ;Not digit	or whitespace, flag error.
    558	01FA  EB 04			     JMP     @@NXTCHR		     ;Get next character.
    559
    560	01FC			     @@SEP:
    561	01FC  3C 20			     CMP     AL, ' '		     ;Separator	a space?
    562	01FE  75 F4			     JNE     @@QTAB		     ;No, see if tab.
    563	0200			     @@NXTCHR:
    564	0200  FE CD			     DEC     CH			     ;Is there another character?
    565	0202  74 3C			     JZ	     @@DUN		     ;Jump if not,
    566	0204  AC			     LODSB			     ;else get next character.
    567	0205  3C 30			     CMP     AL, '0'		     ;Is it a digit?
    568	0207  72 F3			     JB	     @@SEP
    569	0209  3C 39			     CMP     AL, '9'
    570	020B  77 EF			     JA	     @@SEP
    571
    572	020D			     @@GOTDGT:				     ;We've got	a digit,
    573	020D  8A CE			     MOV     CL, DH		     ;start accumulation of value.
    574	020F			     @@NXTDGT:
    575	020F  8A E1			     MOV     AH, CL		     ;Multiply accumulating value by ten.
    576	0211  D0 E4			     SHL     AH, 1		     ;(This way	is quickler than
    577	0213  D0 E4			     SHL     AH, 1		     ;the MUL instruction.
    578	0215  02 CC			     ADD     CL, AH
    579	0217  D0 E1			     SHL     CL, 1
    580	0219  2C 30			     SUB     AL, '0'		     ;Digit to binary.
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 15
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Convert	An ASCII String	Of Tab Positions To A VarTabs Bit Set

    581	021B  02 C8			     ADD     CL, AL		     ;Accumulate.
    582
    583	021D  FE CD			     DEC     CH			     ;Any more characters?
    584	021F  74 09			     JZ	     @@SETBIT		     ;Go set the bit if	no,
    585	0221  AC			     LODSB			     ;else get the next	character.
    586	0222  3C 30			     CMP     AL,'0'		     ;Is it a decimal digit?
    587	0224  72 04			     JB	     @@SETBIT
    588	0226  3C 39			     CMP     AL,'9'
    589	0228  76 E5			     JNA     @@NXTDGT		     ;If it is,	continue accululation.
    590
    591	022A			     @@SETBIT:
    592	022A  8A D9			     MOV     BL, CL
    593	022C  80 E1 07			     AND     CL, 7		     ;Get bit offset in	byte.
    594	022F  D0 EB			     SHR     BL, 1		     ;Get byte offset in string.
    595	0231  D0 EB			     SHR     BL, 1
    596	0233  D0 EB			     SHR     BL, 1
    597	0235  B4 01			     MOV     AH, 1
    598	0237  D2 E4			     SHL     AH, CL		     ;Position the bit.
    599	0239  26: 08 21			     OR	     [ES:DI+BX], AH	     ;Set the bit.
    600
    601	023C  0A ED			     OR	     CH, CH		     ;Any more characters?
    602	023E  75 BC			     JNZ     @@SEP		     ;Go check 'em if there are.
    603
    604	0240			     @@DUN:
    605	0240  8B C2			     MOV     AX, DX		     ;Get result code.
    606	0242  8A D6			     MOV     DL, DH		     ;Clear high-order word of result.
    607	0244  CB			     RETF			     ;Back to the caller.
    608
    609	0245				     ENDP    TP2TS
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 16
BITSET.ASM
Bit Set	Support	For Semware Editor Macros
Additional Material

    610				     ;
    611				     ; Some constants
    612				     ;
    613	0245  0A		     TEN:    DB	     10			     ;Used in binary-to-ASCII conversion.
    614
    615
    616	0246				     ENDS    _TEXT
    617
    618					     END
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 17
Symbol Table
Bit Set	Support	For Semware Editor Macros



Symbol Name		Type   Value			   Cref	(defined at #)

??DATE			Text   "07/10/93"
??FILENAME		Text   "BITSET	"
??TIME			Text   "16:16:06"
??VERSION		Number 0314
@@BTST			Text   [DWORD BP+10]		   #82	96
@@CNTBIT		Near   _TEXT:0166		   #415	 466  470
@@DODASH		Near   _TEXT:00C0		   215	#229
@@DUN			Near   _TEXT:00AB		   128	158  179  #213
@@DUN			Near   _TEXT:013E		   311	#354
@@DUN			Near   _TEXT:017C		   388	421  #430
@@DUN			Near   _TEXT:0240		   565	#604
@@FORCE			Near   _TEXT:00E4		   271	#276
@@FORCE			Near   _TEXT:01D9		   516	#521
@@GOTATAB		Near   _TEXT:0191		   414	#446
@@GOTDGT		Near   _TEXT:020D		   #572
@@LTRST			Text   [DWORD BP+10]		   #258	 286
@@MAXRL			Text   [BYTE BP+4]		   #84	94
@@MAXRL			Text   [WORD BP+4]		   #260	 270
@@MAXSL			Text   [BYTE BP+4]		   #379	 391
@@MAXSL			Text   [WORD BP+4]		   #505	 515
@@NEEDASH		Number 0001			   #87	124  214
@@NXTBIT		Near   _TEXT:0162		   #412	 418  425
@@NXTBYT		Near   _TEXT:0170		   395	#422  429
@@NXTCHR		Near   _TEXT:0200		   537	555  558  #563
@@NXTDGT		Near   _TEXT:01A5		   #457	 464
@@NXTDGT		Near   _TEXT:020F		   #574	 589
@@OFLO			Near   _TEXT:00BC		   149	170  186  #225	231
@@OFLO			Near   _TEXT:01B6		   460	#468
@@OKAY			Near   _TEXT:00B1		   #216	 234
@@QTAB			Near   _TEXT:01F4		   #553	 562
@@RSLT			Text   [DWORD BP+6]		   #83	93
@@RSLT			Text   [DWORD BP+6]		   #259	 266
@@SEP			Near   _TEXT:01FC		   #560	 568  570  602
@@SETBIT		Near   _TEXT:022A		   584	587  #591
@@STATE0		Near   _TEXT:0041		   125	#134  140  162	183  212
@@STATE0		Near   _TEXT:00FB		   #309	 325  328  331	342
@@STATE0A		Near   _TEXT:002D		   #123	 143  165
@@STATE0B		Near   _TEXT:0033		   106	#126  133  137
@@STATE0C		Near   _TEXT:0047		   131	#138
@@STATE1		Near   _TEXT:012F		   #344	 350
@@STATE1A		Near   _TEXT:0064		   155	#160
@@STATE1A		Near   _TEXT:0133		   #347	 360
@@STATE1B		Near   _TEXT:0142		   346	#358
@@STATE2A		Near   _TEXT:0081		   176	#181
@@STATE3		Near   _TEXT:0097		   189	#199  205
@@STATE3A		Near   _TEXT:0090		   #194	 201
@@STATE3B		Near   _TEXT:009B		   198	#202
@@STATE3C		Near   _TEXT:00A3		   196	#208
@@STRSIZ		Near   _TEXT:00B4		   #218	 227
Turbo Assembler	 Version 3.2	    07/01/93 10:40:22	    Page 18
Symbol Table
Bit Set	Support	For Semware Editor Macros


@@STRSIZ		Near   _TEXT:018B		   433	435  #437  474
@@SWITCH		Number [BP-0002]		   #86	91  124	 214
@@TBSTR			Text   [DWORD BP+6]		   #378	 390
@@TBSTR			Text   [DWORD BP+10]		   #503	 531
@@USEIT			Near   _TEXT:00EF		   269	#283
@@USEIT			Near   _TEXT:01E4		   514	#528
@@VARSIZ		Number 0002			   #86	90
@@VTSET			Text   [DWORD BP+10]		   #377	 385
@@VTSET			Text   [DWORD BP+6]		   #504	 511
@@XTRACT		Near   _TEXT:0196		   #450	 456
@CPU			Text   0101H
@CURSEG			Text   _TEXT			   #39
@FILENAME		Text   BITSET
@WORDSIZE		Text   2			   #39
STATE0A			Near   _TEXT:00FF		   #312	 353
TEN			Near   _TEXT:0245		   452	#613
TP2TS			Far    _TEXT:01C1		   63  #500
TS2TP			Far    _TEXT:0145		   60  #374
VECTORS			Near   _TEXT:0000		   #53
WC2WS			Far    _TEXT:00CC		   57  #255
WS2WC			Far    _TEXT:0009		   #79

Macro Name						   Cref	(defined at #)

JUMP							   #47	55  58	61

Groups & Segments	Bit Size Align	Combine	Class	   Cref	(defined at #)

_TEXT			16  0246 Para	none		   #39	40

