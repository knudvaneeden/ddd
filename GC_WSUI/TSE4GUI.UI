/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                            Notes for users:
   I grew up with Wordstar and many ofthe key commands are of necessity an
extension of the basic Worstar set.  Ctrl M and Ctrl J were use to extend
control key functions.  The J set is mostly for help or list functions.  The
M set is for external macros and there control functions.

   Changing, adding, or deleting code is done at your own risk.  Most of the
code is non critical.  the command line code is critical if you do not understand
what is been done, best left alone.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  file: SE32.ui             GRAFCO                        2002/06/07
                     TSE4GUI.UI SOURCE FILE

  27 Apr  94  cut down QuickHelp size, renamed from ws.. to se..
  12 Jan  94  added wordset menu selection
   5 Sept 94  update to beta 160a, add SHOW BOOKMARK code
  20 Sept 94  update to release ver 2.00
   2 Oct  94  add RepeatFind toggle
  28 Jan  95  comment out hex and birnary display modes
              added 'bitset' code and bin for wordset and variable tabs
              add to tab menu and wordset menu
              add 132 x 28 video mode toggle
   6 Jan 95   update se200a.ui macros from tse.ui beta 201s
   4 Feb 95   major block handling revisions,  redo ASCII chart
  28 May 95   add unmarkblock to ^k^l (mmarkline)
  29 May 95   add delta column
  10 Jun 95   Major changes of some macros for 202z
  20 Jun 95   Change some code to external macros.
  1 Sept 95   Changes for 249a implementation
  2 Sept 95   Implementation of 249c
  10 Oct 95   Implement 250a. Major changes. Much code to external macros.
  11 Nov 96   Change AutoLoad startup video mode to auto detect since running
              586 DOS in 100x50 mode
  22 Jan 97   add history to mFindWordAtCursor, implement Hex edit
  29 Mar 97   add STB ET600 video card video modes and routines
  30 Jan 98   add disk file delete and DOS mshell
  20 Mar 98   add history to CASEMENU
  19 Jun 98   fix for Pro32

  2002/06/07  Get up and running with 4 GUI
              Clean up/out code no longer applicable
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

#include ["TSE4gui.cfg"]      // config-endconfig definitions

constant MAXPATH = 255
string CONSOLE[] = "CONIN$"

dll "<kernel32.dll>"
    integer proc GetShortPathName(string inpath:cstrval, var string outpath:strptr, integer len) : "GetShortPathNameA"
end
dll "<user32.dll>"
    integer proc SendMessage(integer hwnd, integer msg, integer wparam, integer lparam) : "SendMessageA"
    integer proc IsMaximized(integer hwnd) : "IsZoomed"
    integer proc IsMinimized(integer hwnd) : "IsIconic"
end

#define WM_SYSCOMMAND   0x0112
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_RESTORE      0xF120


// Global variables - assumes globals initialized to 0.

integer cmode                         // used to invoke C-mode
integer language                      // used to invoke language package
// integer sort_flags                 // used for Sorting
integer recent_files                  // id of the recent_files

// used by ggc macros
integer wordwrap_mode                 // wordwrap flag
integer DBlockAttr                    // set in main() black on white
integer DCursorInBlockAttr            // set in main() black on white
integer DStatusLineAttr               // set in main() black on cyan

// integer persistent_recent_files
// integer pick_buffer                // id of the pick-buffer
// integer save_autoindent

string KeyWords[] = " case do else elseif for if loop otherwise proc repeat switch when while "
string c_fun[]      = "^_@[a-zA-Z][a-zA-Z0-9_* \t]@([~;]*$"
string cpp_fun[]    = "^_|~@[a-zA-Z:~][a-zA-Z0-9_* \t:~]@([~;]*$"
string sal_fun[]    = "^{menu}|{{public #}?{{integer #}|{string #}}@proc} +[a-zA-Z_]"
string pas_fun[]    = "{procedure}|{function} +[a-zA-Z_]"
string xbase_fun[]  = "^{static }?{{procedure}|{function}} +[a-zA-Z_]"
string ini_fun[]    = "\[.*\]"      // .ini files
string ident_set[]  = "[_a-zA-Z]"
string TSEPro[]     = "TSE 4 GUI   "
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     DEFINED LATER IN CODE                 ASSOCIATED WITH
  mark_flag                              mKB()   mKN()              Mark "k"
  find_flag                              mFind() mFindWordAtCursor  Mark "l"
  blockfill_mode       1=on    0=off     gBlockFillToggle()
  blockoverwrite_mode  1=on    0=off     gBlockOverwriteToggle()
  scrollroll_mode      1=roll  0=scroll  gScrollRollToggle()
  scrolllock_mode      1=lock  0=off     gScrollLockToggle()
  repeatfind_mode      1=BKWD  0=FOWD    gRepeatFindToggle(1)
  statlinehex_mode     1=on    0=off     gStat_ShowHexToggle()  Forced on WhenLoaded()
  delta_mode           1=line  0=col     gDeltaLineToggle ()
  delta_ofset          offset            gDeltaLineToggle()
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

proc DefaultFont()
//   SetFont("Letter Gothic Line", 0x810,0)   // contains line drawing characters
   SetFont("HyperFont",0x90f,0)               // contains line drawing characters
end                                           // Called by WhenLoaded()

/*****************************************************************  semware GUI
  GetShortPathName only works for existing path's..., so create inpath if
  it does not already exist.
 **************************************************************************/
string proc mGetShortPathname(string inpath)
    integer h, len
    string short_path[MAXPATH] = Format("":MAXPATH:Chr(0))

    h = iif(FileExists(inpath), -1, fCreate(inpath))
    len = GetShortPathName(inpath, short_path, MAXPATH)
    if h <> -1
        fClose(h)
        EraseDiskFile(inpath)
    endif
    return (iif(len > 0, short_path[1:Pos(Chr(0), short_path) - 1], inpath))
end

/******************************************************************  semware GUI
  Since the macro debugger can't handle filenames with spaces, we need to
  pass it the short name if spaces in the name, and we need to save it
  if changed.
 **************************************************************************/
proc mDebugCurrFile()          // KSW changed
    string fn[MAXPATH]

    fn = CurrFilename()
    if Pos(' ', fn)
        if (FileChanged() or not FileExists(CurrFilename())) and not SaveFile()
            Warn("Error saving ", CurrFilename())
            return ()
        endif
        fn = mGetShortPathname(CurrFilename())
    endif
    ExecMacro("debug " + fn)
end

/*********************  MOUSE FUNCTIONS  ***********************************/
proc mRightBtn()
    if WaitForMouseEvent(_MOUSE_HOLD_TIME_|_MOUSE_RELEASE_|_MOUSE_MOVE_) == _MOUSE_RELEASE_
//        MouseMenu()
//    else
        MouseMarking(_COLUMN_)
    endif
end


proc mLeftBtn()
    if not ProcessHotSpot()
//     MainMenu()
     return()
    endif
end

/*
forward menu MouseMenu()
proc mRightBtn()
    if WaitForMouseEvent(_MOUSE_HOLD_TIME_|_MOUSE_RELEASE_|_MOUSE_MOVE_) == _MOUSE_RELEASE_
//      MouseMenu()
      return()
    else
        MouseMarking(_COLUMN_)
    endif
end
*/
/*
proc mTrackMouseCursor()
    if GotoMouseCursor()
        TrackMouseCursor()
    endif
end
*/
/*================================================================= semware ===
                            SETUP FOR LIST BOXES
   called by: mListRecentFiles, mGotoBookMark
 ============================================================================*/
integer proc ListIt(string title, integer width)
    return (List(title, Min(width + 4, Query(ScreenCols))))
end

/*================================================================= semware ===
        RETURN THE FIRST WORD ON THE LINE AS STRING - NULL IF NOT THERE.
   called by: mCReturn
 ============================================================================*/

string proc GetFirstWord()
    string word[32] = ''

    PushPosition()                  // Save where we're at
    GotoPos(PosFirstNonWhite())     // Go to first non white
    word = Lower(GetWord())         // Now get the word there & lower case it
    PopPosition()                   // Restore saved position
    return (' ' + word + ' ')       // And return the word
end

//======================= USED IN VARIOUS Menus =================== semware ===
string proc OnOffStr(integer i)
    return (iif(i, "On", "Off"))
end

/*================================================================== semware ==
                          RECENT FILE PICK LIST          update TSE32 98/06/20
 ============================================================================*/
string proc RecentFilesStr()
    return (LoadDir() + "tsefiles.dat")
end

// Create the recent files buffer, if needed
// BOOL Return
integer proc GotoRecentFilesBuffer()
    if not GotoBufferId(recent_files)
        if Query(PersistentRecentFiles)
            recent_files = EditBuffer(RecentFilesStr(), _SYSTEM_, -1)
        else
            if CreateTempBuffer()
                BinaryMode(-1)
                recent_files = GetBufferId()
            endif
        endif
    endif
    return (recent_files)
end

string recentfiles_footer[] = " {Del}-Delete entry "
string recent_files_title[] = "Recent Files"

keydef RecentFilesKeys
<del>   KillLine()
end


proc RecentFilesHelper()
    if Enable(RecentFilesKeys)
        ListFooter(recentfiles_footer)
    endif
    Unhook(RecentFilesHelper)
    BreakHookChain()
end

// Display the recent files list
string proc mListRecentFilesStr()
    integer start_id, maxl
    string fn[MAXPATH]

    fn = ""
    start_id = GetBufferId()

    if not GotoRecentFilesBuffer() or NumLines() == 0
        GotoBufferId(start_id)
        Warn("No Recent Files list")
        return ("")
    endif

    maxl = LongestLineInBuffer()
    GotoLine(1 + (NumFiles() <> 0))

    Hook(_LIST_STARTUP_, RecentFilesHelper)
    if List(recent_files_title, max(maxl + 1, Length(recent_files_title) + 6))
       fn = GetText(1, CurrLineLen())
    endif
    GotoBufferId(start_id)
    return (fn)
end

// proc mPromptRecentFiles()
//     BegLine()
//     KillToEol()
//     InsertText(mListRecentFilesStr())
// end

integer proc mListRecentFiles()
    string fn[MAXPATH] = mListRecentFilesStr()
    return (iif(Length(fn), EditFile(QuotePath(fn)), FALSE))
end


/*================================================================== semware ==
                             FIND FUNCTIONS
  This function returns a regular expression that can be used to find
  functions in the current source file.
   called by: mCompressView
 ============================================================================*/
// Note that c++ allows a few extra characters in function names.
string proc GetFunctionStr()
    case CurrExt()
        when ".c",".h"
            return(c_fun)
        when ".cpp",".hhp"
            return(cpp_fun)
        when ".s", ".ui", ".si"
            return(sal_fun)
        when ".pas"
            return(pas_fun)
        when ".prr",".prg",".spr",".mpr",".qpr",".fmt",".frg",".lbg",".ch"
            return(xbase_fun)
        when ".ini"
            return(ini_fun)
    endcase
    return("")
end

/*================================================================== semware ==
                            COMPRESS PICK LIST            update TSE32 98/06/20

    CompressView(0) -> user string list  CompressView(1) -> function list
 ============================================================================*/
integer compress_hist, compress_option_hist
proc mCompressView(integer show_functions)
    string expression[100], options[12]

    if compress_hist == 0
        compress_hist = GetFreeHistory("UI:CompressViewFind")
        compress_option_hist = GetFreeHistory("UI:CompressViewFindOptions")
    endif
    if show_functions
        options = "ix"
        expression = GetFunctionStr()
        if Length(expression) == 0
            expression = "^" + ident_set
        endif
    else
        expression = ''
        options = ''
        if not ask("String to list all occurrences of:", expression, compress_hist)
            return ()
        endif
        if Length(expression) == 0
            options = "x"
            expression = "^" + ident_set
        elseif not ask("Search options [IWXA] (Ignore-case Words reg-eXp All-files):", options, compress_option_hist)
            return ()
        endif
    endif
    if not lFind(expression, options + 'v')
        Warn(expression, " not found.")
    endif
end mCompressView

/*================================================================== semware ==
                          ENHANCED ASCII CHART
                                                                modify 95/03/08
   WARNING: use chr(n) for control codes else they will affect printout
 ============================================================================*/
DataDef ASCIIData
    "   0  00     ^@  NUL Null"
    "   1  01  "+chr(1) +"  ^A  SOH Start of Header"
    "   2  02  "+chr(2) +"  ^B  STX Start of Text"
    "   3  03  "+chr(3) +"  ^C  ETX End of Text"
    "   4  04  "+chr(4) +"  ^D  EOT End of Transmission"
    "   5  05  "+chr(5) +"  ^E  ENQ Enquiry"
    "   6  06  "+chr(6) +"  ^F  ACK Acknowledge"
    "   7  07  "+chr(7) +"  ^G  BEL Bell"
    "   8  08  "+chr(8) +"  ^H  BS  BackSpace"
    "   9  09  "+chr(9) +"  ^I  HT  Horizontal Tab"
    "  10  0A  "+chr(10)+"  ^J  LF  Line Feed"
    "  11  0B  "+chr(11)+"  ^K  VT  Verical Tab"
    "  12  0C  "+chr(12)+"  ^L  FF  Form Feed"
    "  13  0D  "+chr(13)+"  ^M  CR  Carriage Return"
    "  14  0E  "+chr(14)+"  ^N  SO  Shift Out"
    "  15  0F  "+chr(15)+"  ^O  SI  Shift In"
    "  16  10  "+chr(16)+"  ^P  DLE Data Link Escape"
    "  17  11  "+chr(17)+"  ^Q  DC1 Device Control 1"
    "  18  12  "+chr(18)+"  ^R  DC2 Device Control 2"
    "  19  13  "+chr(19)+"  ^S  DC3 Device Control 3"
    "  20  14  "+chr(20)+"  ^T  DC4 Device Control 4"
    "  21  15  "+chr(21)+"  ^U  NAK Negative Acknowledge"
    "  22  16  "+chr(22)+"  ^V  SYN Synchronous Idle"
    "  23  17  "+chr(23)+"  ^W  ETB End Transmission Block"
    "  24  18  "+chr(24)+"  ^X  CAN Cancel"
    "  25  19  "+chr(25)+"  ^Y  EM  End of Medium"
    "  26  1A  "+chr(26)+"  ^Z  SUB Substitute"
    "  27  1B  "+chr(27)+"  ^[  ESC Escape"
    "  28  1C    ^\  FS  File Separator"
    "  29  1D    ^]  GS  Group Separator"
    "  30  1E    ^^  RS  Record Separator"
    "  31  1F    ^_  US  Unit Separator"
end

proc mAsciiChart()
    integer ok, i, ASCII_id,
            c = CurrChar(),
       saveit = set(ExpandTabs, OFF)

    PushPosition()
    if CreateTempBuffer()                   // load ASCII data into buffer
        ASCII_id = GetBufferID()
        PushBlock()
        InsertData(ASCIIData)
        GotoBlockEnd()
        PopBlock()
        EndLine()
        JoinLine()
        i = 32                              // create remainder of table
        while AddLine(format(i:4, str(i, 16):4, chr(i):3)) and i < 255
            i = i + 1
        endwhile
    endif

    if (ASCII_id)
        GotoBufferId(ASCII_id)
        BegFile()
        if c >= 0                        // position to current cursor char
            GotoLine(c + 1)
        endif
        // DISPLAY TABLE
        ok = List("Dec Hex Chr     Description               ", 44)
        c = CurrLine() - 1               //
        PopPosition()
        if ok
            InsertText(chr(c))
        endif
    endif
    set(ExpandTabs, saveit)
end mAsciiChart

/*=============================================================================
            Sort Menu          GRAFCO INC               12 April 93
 ============================================================================*/
MENU SortTypeMenu()
  "Sort &Ascending"
  "Sort &Descending"
  "Sort Ascending  &Nocase"
  "Sort Descending n&Ocase"
end

proc mSort()
  SortTypeMenu()
  Sort(MenuOption()-1)
end

/*================================================================== semware ==
                   BLOCK SHIFT ROUTINES                  exit keys changed
 ============================================================================*/
constant SHIFTLEFT = -1, SHIFTRIGHT = 1

integer proc mShiftBlock(integer direction)
    integer goal_line = CurrLine(),
                btype = isCursorInBlock(),
         save_marking = Set(Marking, off),
                    p = CurrPos()

    PushPosition()
    if btype or (isBlockInCurrFile() and CurrLine() >= Query(BlockBegLine)
                                     and CurrLine() <= Query(BlockEndLine))
        goal_line = Query(BlockEndLine)
        GotoBlockBegin()
    endif

    repeat
    until not ShiftText(direction) or not RollDown() or CurrLine() > goal_line

    PopPosition()
    GotoPos(p)
    Set(Marking, save_marking)
    return (TRUE)
end  mShiftBlock

proc mShift()
//    integer k = Set(EquateEnhancedKbd, ON)

    loop
        Message("  ->, <-, TAB, Shift TAB to shift text;   Exit ESC unmark-block or ENTER")
        case GetKey()
            when <CursorLeft>
                mShiftBlock(-1)
            when <CursorRight>
                mShiftBlock(1)
            when <Tab>
                mShiftBlock(Query(TabWidth))
            when <Shift Tab>
                mShiftBlock(-Query(TabWidth))
            when <Enter>                            // exit, leave block marked
                break
            when <Escape>                           // exit and unmark block
                if isCursorInBlock()                // if any
                    UnMarkBlock()
                    break
                endif
                break
        endcase
        UpdateDisplay(_REFRESH_THIS_ONLY_ | _WINDOW_REFRESH_)
    endloop
//    Set(EquateEnhancedKbd, k)
    UpdateDisplay()
end

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          BLOCK MACROS       GRAFCO INC               9 April 93

     Toggles for overwrite and fill.  The color of the block changes depending
   on the toggles.
 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
//======================= Block Global Variables ==============================
integer
   blockfill_mode,                  // block fill toggle flag
   blockoverwrite_mode,             // block overwrite toggle flag
   mark_flag                        // block begin mark flag

<HelpLine>      "     Block Color:  OVERWRITE -> Red    FILL -> Blue   BOTH -> Yellow"
<Shift HelpLine>"     Block Color:  OVERWRITE -> Red    FILL -> Blue   BOTH -> Yellow"
<Alt HelpLine>  "     Block Color:  OVERWRITE -> Red    FILL -> Blue   BOTH -> Yellow"
<Ctrl HelpLine> "     Block Color:  OVERWRITE -> Red    FILL -> Blue   BOTH -> Yellow"

//======================= Set Block Color Attribute ===========================
proc gSetBlockAtt()

    if BlockOverwrite_mode and not BlockFill_mode             //^KI
      set(BlockAttr,         color(Red on White))
      set(CursorInBlockAttr, color(Red on White))
    elseif BlockFill_mode and not BlockOverwrite_mode         //^KJ
      set(BlockAttr,         color(Bright Blue on White))
      set(CursorInBlockAttr, color(Bright Blue on White))
    elseif BlockOverwrite_mode and BlockFill_mode             //^KJ and ^KI
      set(BlockAttr,         color(Bright Yellow on White))
      set(CursorInBlockAttr, color(Bright Yellow on White))
    else
      set(BlockAttr, DBlockAttr)                              // reset, default
      set(CursorInBlockAttr, DCursorInBlockAttr)              // colors defined
    endif                                                     // in main()
    UpdateDisplay(_REFRESH_THIS_ONLY_ | _WINDOW_REFRESH_)
    set(ShowHelpLine, BlockOverWrite_mode | BlockFill_mode)
end

//======================= Block Overwrite Toggle ==============================
proc gBlockOverwriteToggle()                   // Over write toggle  ^KI red
  blockoverwrite_mode = blockoverwrite_mode ^ 1       // XOR flips bits
  gSetBlockAtt()
end

//======================= Block Fill Toggle ===================================
proc gBlockFillToggle()                       // Fill toggle         ^KJ blue
  blockfill_mode = blockfill_mode ^ 1                 // XOR
  gSetBlockAtt()
end

/*=============================================================================
    Augmented Block Delete: toggle determins type of delete
         when set blockfill_mode    deleted block is filled with spaces
         else                       does a normal Block Delete
   used: mBlockMove   ^KY
 ============================================================================*/
proc mDelBlock()
  if blockfill_mode
    FillBlock(" ")
  else
    DelBlock()
  endif
end

/*=============================================================================
    Augmented Block Move:  two toggle determine type of move
         when set  blockfill_mode         source block is filled with spaces
                   blockoverwrite_mode    moved block overwrites existing text
         else                             does a normal Block Move

    _OVERWRITE_ works only with column block operations
    A CHAR block cannot overwrite, delete fill OK

    95/03/04  major re-coding ggc
    95/11/01  recode blocktype==_COLUMN_ to allow a target copy ontop of source
 ============================================================================*/
proc mBlockMove()
  integer
    blocktype = IsBlockMarked(),         // type of block
          cid = GetBufferID(),           // current buffer
          tid, h, i, j, k

  if not (BlockOverWrite_mode or BlockFill_mode)  // NO TOGGLES do it and leave
        MoveBlock()
    return()
  endif

  if blocktype == _NONINCLUSIVE_  and BlockOverWrite_mode
    Message("Block is CHAR type: OVERWRITE does not apply  ESC to cancel")
    Alarm()
    if GetKey() == <escape>
        return()
    endif
  endif

  if blocktype == _COLUMN_
    PushBlock()                            // source block
    PushPosition()                         // target block position

    tid = CreateTempBuffer()
    CopyBlock()                            // get copy of block and
    h = Query(BlockBegCol)                 // store block coordinates
    i = Query(BlockBegLine)                // if have blank line at beg
    j = Query(BlockEndCol)                 // or end then Beg/EndFile NG
    k = Query(BlockEndLine)

    GotoBufferID(cid)                      // deal with source block
    PopBlock()                             // restore it
    mDelBlock()                            // deleate or fill
    UnmarkBlock()                          // if filled clear block

    GotoBufferID(tid)                      // remark block copy
    GotoLine(i)
    GotoColumn(h)
    Mark(_COLUMN_)
    GotoLine(k)
    GotoColumn(j)
    Mark(_COLUMN_)

    PopPosition()                          // copy block to target position
    CopyBlock(BlockOverWrite_mode)         // with appropriate copy
    AbandonFile(tid)
    return()
  endif

  // if not overwrite source is inserted above current line
  if blocktype == _LINE_                // LINE TYPE BLOCK
     PushBlock()                        // save source block
     if BlockOverWrite_mode             // OVERWRITE TARGET
        PushPosition()                  // save target position
        BegLine()                       // delete line at target position
        DelLine()
        CopyBlock()                     // copy source block
        PopPosition()                   // restore cursor position at target
        Up()
     else
        CopyBlock()                     // NO OVERWRITE
     endif
     PopBlock()                         // put back source block
     mDelBlock()                        // FILL or DELETE IT
     UnmarkBlock()                      // if filled, unmark source
     MarkLine()                         // mark target
     MarkLine()
     return()
   endif
end

/*=============================================================================
                        ENHANCED BLOCK MOVE
          Set Block Fill and Block Over Write Mode ON
          Moves the Block, unmarks it, and restores previous modes
 ============================================================================*/
proc mMarkColumnMove()
   integer bo = blockoverwrite_mode,
           bf = blockfill_mode

   blockoverwrite_mode = 1        // force fill and overwrite true
        blockfill_mode = 1

   mBlockMove()                   // move block
   UnMarkBlock()                  // unmark block
   blockoverwrite_mode = bo       // restore previous modes
   blockfill_mode      = bf
   gSetBlockAtt()
end

//==============  Save current position for goto previous block ===============
proc mKN()
   mark_flag = mark_flag ^ 1
   if mark_flag                   // mark beginning only
     PlaceMark("k")
   endif
   MarkColumn()
end

//==============  Save current position for goto previous block ===============
proc mKB()
   PlaceMark("k")
   MarkChar()
end

/*=============================================================================
   Augmented MarkWord:   Makes block a column type block
 ============================================================================*/
proc mMarkWord()
    PushPosition()
    UnmarkBlock()
    BegWord()
    mKN()
    EndWord()
    Left()
    mKN()
    PopPosition()
end

//=========================== BLOCK / FILE PRINT  =============================
//============ If block marked print it else print entire file ================
proc mKP()
   If Query(BlockId)
      PrintBlock()
   else
      PrintFile()
   endif
end

//-----------------------  END BLOCK MACROS  ----------------------------------
/*=============================================================================
                         SCROLL ROLE FUNCTIONS

                   SIMPLE SIMULTANEOUS SCROLL OF TWO WINDOWS
 ============================================================================*/
integer   scrolllock_mode = 0,
          scrollroll_mode = 1

proc gScrollLockToggle()

    scrolllock_mode = scrolllock_mode ^ 1
    Message("Scroll Lock turned ", iif(scrolllock_mode, "ON", "OFF"))
end

//===================  Scroll or Roll with scroll keys  =======================
proc gScrollRollToggle()                        // toggle
  scrollroll_mode = scrollroll_mode ^ 1
  Message(iif(scrollroll_mode, "  SCROLLING", "  ROLLING")+" is in effect")
end

//===================  Enhanced scroll/roll function  =========================
proc mRollUp()
    if scrollroll_mode
       ScrollUp()
    else
       RollUp()
    endif
    if scrolllock_mode and NextWindow()         // if lock do both windows
       RollUp()
       PrevWindow()
    endif
end

proc mRollDown()
    if scrollroll_mode
       ScrollDown()
    else
       RollDown()
    endif
    if scrolllock_mode and NextWindow()
       RollDown()
       PrevWindow()
    endif
end
//---------------------- END OF SCROLL ROLE FUNCTIONS -------------------------

/*=============================================================================
    AUGMENTED FIND  marks the find position
 ============================================================================*/
proc mFind()
     Find()
     PlaceMark("l")
end

/*================================================================== semware ==
    FIND WORD AT CURSOR USES CURRENT WORDSET, ASKS FOR FINE OPTIONS
       modified to ask for options with history        95/10/08
 ============================================================================*/
integer proc mFindWordAtCursor()
    string opts[12] = ""
    integer opts_hist

    opts_hist = GetFreeHistory("SE250:findword")
    if Length(GetWord(1))
        Ask("Options [GLIWXBCAV^$+] (Curr-line All-files Vpicklist ):",opts, opts_hist)
        AddHistoryStr(GetWord(1), _FIND_HISTORY_)
        AddHistoryStr(opts, opts_hist)
        PlaceMark("l")                          // mark position ^Qg
        return (Find(GetWord(1), opts))
    endif
    return (Find())
end mFindWordAtCursor

/*================================================================== semware ==
                         FANCY BACKSPACE() COMMAND.
    Sort of like Borlands environment.  In language mode, backspace
    does a "outdent" when there is only white space before the cursor.

    Also does special handling for overwrite mode.  In overwrite mode,
    does a "rubout" instead of a backspace.              update 201y
  ===========================================================================*/
proc mBackSpace()
    if CurrPos() == 1       // at beg-of-line, just join to previous
        if PrevChar()
            JoinLine()
        endif
        return ()
    endif

    // if from here to prev-tabstop is 'white', then TabLeft()

    if Query(AutoIndent) and language
        if CurrPos() <= PosFirstNonWhite()
            TabLeft()
            return ()
        endif
        PushPosition()
        GotoColumn(CurrCol() - DistanceToTab())
        if CurrPos() > PosLastNonWhite()
            PopPosition()
            TabLeft()
            return ()
        endif
        PopPosition()
    endif

    // Finally, do either rubout or backspace based on InsertMode

    Left()
    if CurrChar() >= 0
        if Query(Insert) or CurrPos() == CurrLineLen()
            DelChar()
        else
            InsertText(" ", _OVERWRITE_)
            Left()
        endif
    endif
end mBackSpace

/*================================================================== semware ==
       FANCY CARRIAGE RETURN COMMAND.  WORKS IF LANGUAGE MODE IS ON.
     11-05-93 SEM Handle SmartTabs                     update TSE 32 98/06/20
 ============================================================================*/
integer proc mCReturn()
    integer ok, save_tabtype, found = FALSE

    if language and CurrPos() > PosFirstNonWhite()
        found = Pos(Lower(GetFirstWord()), KeyWords) <> 0
            or (cmode and Pos('{', GetText(1, CurrPos())) <> 0)
    endif
    if not CReturn()
        return (FALSE)
    endif

    ok = TRUE
    if found and ((Query(Insert) and Query(ReturnEqNextLine) == FALSE)
            or PosFirstNonWhite() == 0)

        save_tabtype = Set(TabType, _SOFT_)     // force fixed tabs
        ok = TabRight()
        Set(TabType, save_tabtype)              // restore tabtype
    endif
    return (ok)
end

/*================================================================== semware ==
                          UPPER, LOWER, FLIP CASE
 ============================================================================*/
constant WORDCASE  = 1,
         LINECASE  = 2,
         BLOCKCASE = 3

constant UPPER_CASE = 0,
         LOWER_CASE = 1,
         FLIP_CASE  = 2

integer casetype

// Assume type is always one of WORDCASE, LINECASE or BLOCKCASE.
proc ChangeCase(integer type)
    PushBlock()
    if type <> BLOCKCASE
        UnMarkBlock()
        if type == LINECASE
            MarkLine()
        elseif not MarkWord()
            goto done
        endif
    elseif not IsCursorInBlock()
        goto done
    endif
    case casetype
        when UPPER_CASE
            Upper()
        when LOWER_CASE
            Lower()
        when FLIP_CASE
            Flip()
    endcase
    done:
    PopBlock()
    UnMarkBlock()
end  ChangeCase

MENU CaseMenu()
    Command = ChangeCase(MenuOption())
    history

    "&Word at Cursor"   // if the order of these options is changed,
    "Current &Line"     // Change the order of the constants
    "&Block"            // WORDCASE, LINECASE, and BLOCKCASE
end

proc mUpper()
    casetype = UPPER_CASE
    CaseMenu("Upper Case")
end

proc mLower()
    casetype = LOWER_CASE
    CaseMenu("Lower Case")
end

proc mFlip()
    casetype = FLIP_CASE
    CaseMenu("Flip Case")
end

/*=============================================================================
                              CENTER TEXT
  If a block is marked and the cursor is in the block JustifyMenu()
  Else center the current line.
  The center current line is an extract from external macro CENTER.
 ============================================================================*/
proc gCenterText()
    integer right_margin = Query(RightMargin),
             left_margin = 1,
             cp,p,center

    if isBlockMarked() and isBlockInCurrFile() and isCursorInBlock()
//                        and ExecMacro("ADJUST","")
    else
//        center_it:
       cp = CurrPos()
       PushPosition()
       PushBlock()
       p = PosFirstNonWhite()
       center = ((p + PosLastNonWhite()) / 2)
           - ((left_margin + right_margin) / 2)
       ShiftText(iif(center > 0,
           - (iif(center < p, center, p - 1)), Abs(center)))
       PopPosition()
       GotoPos(cp)
    endif
end  gCenterText

/*================================================================== semware ==
    Macro to wrap text in a column block, without distrubing the surrounding
    text if the cursor is in the block.
    If a column isn't marked, the normal WrapPara() is called.
    From SemWare exernal macro WRAPPARA                            update 201y
 ============================================================================*/
proc mWrapPara()                        // ^B
    integer
        id,                             // work buffer id
        block_beg_col,
        save_leftmargin,
        save_rightmargin,
        save_autoindent,
        save_wrapend,
        curr_id = GetBufferId(),        // current file id
        blocktype = isCursorInBlock()

    if blocktype == 0
        WrapPara()
    else
        Set(Marking, off)               // Stop marking
        if blocktype <> _COLUMN_        // Wrap entire block if not column
            GotoBlockEnd()
            AddLine()                   // add blank line to stop WrapPara()
            GotoBlockBegin()
            BegLine()
            // while we can find something to wrap within the block, and we can
            // wrap it, keep repeating.
            while lFind("[~ \t]", "lx") and WrapPara()
            endwhile
            if CurrLineLen() == 0
                DelLine()
            endif
         else                            // Otherwise, wrap whats in col
            GotoBlockBegin()
            block_beg_col = CurrCol()
            id = CreateTempBuffer()
            CopyBlock()                 // Copy block to temp buffer

            /**************************************************************
              The number of lines in the column may become less than what
              it was - so we must fill the old block with spaces.
             **************************************************************/
            PushBlock()                 // Save block settings
            GotoBufferId(curr_id)       // Back to original file
            CopyBlock(_OVERWRITE_)      // And get the block back
            FillBlock(' ')              // Wipe it out
            GotoBufferid(id)            // Back to where we were
            PopBlock()                  // And get our block marked again

            /**************************************************************
              Prepare to wrap - we need to set the left/right margins to
              1 and the width of the column.  We also need to preserve the
              old settings.
             **************************************************************/
            save_leftmargin = Set(LeftMargin, 1)
            GotoBlockEnd()
            save_rightmargin = Set(RightMargin, CurrCol())
            save_autoindent = Set(AutoIndent, Off)
            save_wrapend = Set(ParaEndStyle, 0)
            BegFile()
            repeat
            until not WrapPara()
            UnmarkBlock()           // We need to re-mark the block
            BegFile()
            MarkColumn()
            EndFile()
            GotoColumn(Query(RightMargin))

            /*************************************************************
              And finally, go back to the original file, and copy the block
              in.
             *************************************************************/
            GotoBufferId(curr_id)
            CopyBlock(_OVERWRITE_)
            AbandonFile(id)
            GotoBlockEnd()
            Down()
            GotoColumn(block_beg_col)

            // Restore saved settings

            Set(LeftMargin, save_leftmargin)
            Set(RightMargin, save_rightmargin)
            Set(AutoIndent, save_autoindent)
            Set(ParaEndStyle, save_wrapend)
        endif
    endif
end mWrapPara


/*=============================================================================
                          WORD SET ROUTINES
 ============================================================================*/
proc WordSetZero()
    Set(wordset, Chrset("A-Za-z0-9_"))
    Set(StatusLineAttr, DStatusLineAttr)    // default
    UpdateDisplay(_STATUSLINE_REFRESH_)
end

proc WordSetOne()
    Set(wordset, ChrSet("A-Za-z0-9_)]+*&/"))
    Set(StatusLineAttr, Color(Blue on White))
    UpdateDisplay(_STATUSLINE_REFRESH_)
end

proc WordSetTwo()
    Set(wordset, ChrSet("A-Za-z0-9_)/"))
    Set(StatusLineAttr, Color(Red on White))
    UpdateDisplay(_STATUSLINE_REFRESH_)
end

MENU WordSetMenu()
  title = 'Word Set Characters'
  history
  command = WordSetZero()

  "&DEFAULT     A-Z a-z 0-9 _"              ,     WordSetZero()
  '&Blue        A-Z a-z 0-9 _ ) ] + *  / &&',     WordSetOne()
  "&Red         A-Z a-z 0-9 _  /"           ,     WordSetTwo()
end
//--------------------------- End Wordset Routines ----------------------------

/*=============================================================================
                          STATUS LINE MACROS
     REPLACEMENT STATUS LINE with custom STATUS LINE
      includes DELTA LINE POSITION AND HEX/DEC CHAR DISPLAY
   toggles:  a auto indent       o block overwrite
             f block fill        b makebackups
             i insert            s scroll roll
             l line draw         w word wrap
 ============================================================================*/
integer statlinehex_mode       // show char, hex and dec for char under cursor
                               // on status line
proc gStat_ShowHex()
    string  cStr[15] = Chr(Query(StatusLineFillChar))
    integer saveAttr = Query(StatusLineAttr),
            curChar  = CurrChar()

   case curChar    // get hex and decimal numbers of character under cursor
   when -1
       cStr = Format(Chr(curChar), Chr(Query(StatusLineFillChar)), //at end of line
                       '<EOL>':-8:Chr(Query(StatusLineFillChar)))
   when -2
       cStr = Format(Chr(curChar), Chr(Query(StatusLineFillChar)), //past end of line
                       '<EOL+>':-8:Chr(Query(StatusLineFillChar)))
   otherwise
       cStr = Format(Chr(curChar), Chr(Query(StatusLineFillChar)), // on a character
                       Str(curChar, 16):2, 'h,', curChar:3, 'd')
   endcase

    Set(Attr, Color(bright yellow on cyan))
    VGotoXY(Query(ScreenCols) - 12, 0)  //Query(StatusLineRow))
    PutStr(cStr)
    Set(Attr, saveAttr)
end gStat_ShowHex

proc gStat_ShowHexToggle()
    statlinehex_mode = statlinehex_mode ^ 1       // XOR flips bits
    if statlinehex_mode
       Hook(_IDLE_, gStat_ShowHex)
       Hook(_AFTER_UPDATE_STATUSLINE_, gStat_ShowHex)
    else
       Unhook(gStat_ShowHex)
    endif
end

integer delta_mode = 1,    // toggle between delta line and delta column
        delta_ofset        // and set delta to 1

proc gDeltaLineToggle ()            // toggle between Col and Line
  delta_mode = delta_mode ^ 1
  if delta_mode delta_ofset = CurrLine() else delta_ofset = CurrPos() endif
end

proc New_Status()                   // build new status line
    string togg[14] = "",
               i[1] = "", a[1] = "", l[1] = "", w[1] = "",
               f[1] = "", o[1] = "", s[1] = "", b[1] = "",
            cfs[30] = Splitpath(CurrFilename(), _DRIVE_|_PATH_),
            cfn[12] = Upper(SplitPath(CurrFilename(), _NAME_|_EXT_)),
           stat[80] = "",
          togg1[80] = ""
    integer vidattr = Query(attr),              // video output attribute
           statattr = Query(StatusLineAttr),
                  k = 0

    // get current status of toggles
    cfs  = iif(FileChanged(), '*' + cfs, cfs)
    i    = iif(Query(insert),       "I", "i")
    a    = iif(Query(autoindent),   "A", "a")
    w    = iif(Query(wordwrap),     "W", "w")
    l    = iif(Query(linedrawing),  "L", "l")
    f    = iif(blockfill_mode,      "F", "f")      // defined in ui
    o    = iif(blockoverwrite_mode, "O", "o")      // defined in ui
    s    = iif(scrollroll_mode,     "S", "s")      // defined in ui
    b    = iif(Query(makebackups),  "B", "b")

    // format toggles
    togg  = Format(i, a, w:-2:" ", f, o:-2:" ", s, b, l:-2:" ")
    togg1 = Format(togg:-11:" ")

    // Using L:line  C:column   >:detla (the delta character is no longer availabel

    if delta_mode                                  // format status line
       stat = Format("L:",CurrLine():-7:" ", "C:", CurrCol():-6:" ",
                  ">L",CurrLine() - delta_ofset + 1:-6, togg:-14:" ", cfs, cfn )
    else
       stat = Format("L:",CurrLine():-7:" ", "C:", CurrCol():-6:" ",
                  ">C",CurrPos() - delta_ofset + 1:-6, togg:-14:" ",  cfs, cfn )
    endif

    // Write out status line with proper attributes
    VGotoXY(1,0)                                // set position
    Set(Attr, statattr)                         // set status line attribute
    PutLine(stat,Query(ScreenCols))             // write status line

    // overwrite toggles with appropriate attribute, if status line attr
    // is changed by wordset, match it
    k = iif(Query(StatusLineAttr) > 100, color(black on white),
                                         color(black on cyan))

    Set(Attr, k)                                // set toggles attribute
    Vgotoxy(26,0)                               // set position  GUI line 0
    PutStr(togg1)                               // write toggles
    Set(Attr,vidattr)                           // restore video attribute
end  New_Status

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  TSE called macros, including:
//
//  WhenLoaded
//  Main
//  Hooked functions
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// This is a hooked macro
// Be careful not to add files without names!
// 04/19/96 SEM ignore case of files for WIN32

proc AddToTop(string s, integer max_count)
    if lFind(s, "^$ig")
        KillLine()
    elseif NumLines() >= max_count
        EndFile()
        KillLine()
    endif
    BegFile()
    InsertLine(s)
end

proc AfterUpdateDisplay()
    string fn[MAXPATH] = CurrFilename()
    integer cid = GetBufferId()
    Unhook(AfterUpdateDisplay)
//#ifdef WIN32
//    SetWindowTitle("SE32 " + SplitPath(CurrFilename(), _NAME_|_EXT_))
//#endif
    SetWindowTitle(SplitPath(fn, _NAME_|_EXT_) + " - " + TSEPro)
    if Length(fn) and BufferType() == _NORMAL_
        if GotoRecentFilesBuffer()
            AddToTop(fn, Query(MaxRecentFiles))
        endif
        GotoBufferId(cid)
    endif
end

/*================================================================== semware ==
    THIS MACRO IS CALLED EVERYTIME EDITFILE() OR NEXT/PREVFILE() IS CALLED.
    This is a hooked macro.
 ============================================================ update 202z ===*/
proc OnChangingFiles()
    // For 'RecentFiles' processing, only show files that are displayed
    Hook(_AFTER_UPDATE_DISPLAY_, AfterUpdateDisplay)     // update 202z

    /* Ok, on with the rest of the show */
    language = FALSE
    cmode = FALSE
    case CurrExt()
        when ".ui",".s",".si",".inc",".asm",".pgm",".prg",".prr",".prc",".bat"
            language = TRUE
        when ".map", ".obj", "pas", ".tpu", "tpl"
            language = TRUE
        when ".c",".h",".cpp",".hpp"
            language = TRUE
            cmode = TRUE
    endcase
end

/*=============================================================================
    THIS MACRO IS CALLED THE FIRSTTIME A FILE IS LOADED INTO THE EDITOR.
 ============================================================================*/
proc OnFirstEdit()
end


/****************
proc MaybeAutoWrap()                      // ??? all new below
    integer line

    if Query(WordWrap) > ON
        line = CurrLine()
        PushPosition()
        EndLine()
        if Abs(CurrCol() - Query(RightMargin)) > 1
            WrapPara()
        endif
        PopPosition()
        GotoXoffset(0)
        if line <> CurrLine() and CurrLine() < Query(WindowRows) / 2
            ScrollUp()
        endif
    endif
end

// called on delchar/bs/drw/dlw
proc OnDelChar()
    MaybeAutoWrap()
end
***************/

/*================================================================== semware ==
                             WORDWRAP
 =============================================================================*/
proc mToggleWordWrap()
    if Query(WordWrap)
        wordwrap_mode = Set(WordWrap, OFF)
    else
        if wordwrap_mode == OFF
            wordwrap_mode = ON
        endif
        Set(WordWrap, wordwrap_mode)
    endif
end

// Called on each char insert.
proc OnSelfInsert()
    if Query(WordWrap) == ON and CurrCol() > Query(RightMargin) + 1
        WrapLine()
//     else
//         MaybeAutoWrap()
    endif
end

// This macro is automaticaly called by TSE just before the _ON_ABANDON_EDITOR_
// hook is called.  On line doc says it is called after an ext macro is purged?
proc WhenPurged()
     PushPosition()
     if Query(PersistentRecentFiles) and GotoBufferID(recent_files) and NumLines()
        SaveAs(RecentFilesStr(), _OVERWRITE_|_DONT_PROMPT_)
     endif
     PopPosition()
end


/*================================================================== semware ==
  This macro is automatically called by TSE just after the editor has
  initialized all necessary proceses and managers.

  Minimally, this macro should call EditFile() if the cammand line is empty,
  or EditFile(Query(DisCmdLine)) id the commend line is non-empty.

  Many additional 'startup' tasks can/should be performed here.

  The following are performed in this version.

    - The recent files list is created, and loaded from disk if persistent.
    - The initial video mode is set
    - TSEStart is executed
    - The autoload macros are loaded
    - Various events are hooked
    - If the output of a command has been piped to us, load it as a file
    - Process the DOS command line, by calling Editfile
    - If the DOS command line is empty, use the StartupFlags editor variable
      to determine what to do
//===========================================================================*/
// proc WhenLoaded()
//     string s[128]
menu StartupMenu()
    history
    nokeys

    "&Open...",         EditFile()
    "&New File",        NewFile()
    "&File Manager...", ExecMacro("f -r")
    "List &Recent...",  mListRecentFiles()
    "&Pick File...",    EditFile("-a- *.*")
    "Restore &State",   ExecMacro("state -r -q")
    "&Where",           ExecMacro("where")
    "E&xit",            AbandonEditor()
end

proc WhenLoaded()
    string s[MAXPATH]
    integer new_handle
    integer rows, cols, changed

    Set(CurrVideoMode, Query(StartupVideoMode))
    // if rows/cols < 25/80, force video mode
    changed = FALSE
    rows = Query(ScreenRows)
    cols = Query(ScreenCols)
    if rows < 25
        rows = 25
        changed = TRUE
    endif
    if cols < 80
        cols = 80
        changed = TRUE
    endif
    if changed
        SetVideoRowsCols(rows, cols)
    endif

    SignOn()
    gStat_ShowHexToggle()
    LoadStartupMacros()                         // tsestart and autoload macros

     DefaultFont()

//     if Query(TemplateExpansion)
//        m LoadMacro(TEMPLATE)
//     endif

    // Hook the events we want to get control of
    Hook(_ON_CHANGING_FILES_,   OnChangingFiles)
    Hook(_ON_FIRST_EDIT_,       OnFirstEdit)
//     Hook(_PROMPT_STARTUP_,      OnPromptStartup)
    Hook(_ON_SELFINSERT_,       OnSelfInsert)
//     Hook(_ON_DELCHAR_,          OnDelChar)


    // See if input is redirected, if so, read it in as a file
    if isCharDevice(_STDIN_) == FALSE and CreateBuffer("")
        fReadFile(_STDIN_)
        BegFile()
        // call ON_FIRST_EDIT and ON_CHANGING_FILES hooks
        ChangeCurrFilename("[<stdin>]", _DONT_EXPAND_)

        new_handle = fOpen(CONSOLE, _OPEN_READWRITE_)
        if new_handle <> -1
            fDup2(new_handle, _STDIN_)
            fClose(new_handle)
        endif
    endif

    // Finally, process the command line
    s = Query(DosCmdLine)
    if Length(s)
        AddHistoryStr(s, _EDIT_HISTORY_)
        EditFile(s, _FROM_CMDLINE_)
    elseif NumFiles() == 0
        case Query(StartupFlags)
            when _STARTUP_RESTORESTATE_
                ExecMacro("state -r -q")
            when _STARTUP_FILEMGR_
                loop
                    ExecMacro("f -r")
                    if NumFiles()
                        Process(1)
                    else
                        return()
                    endif
                endloop
                return()
            when _STARTUP_UNNAMED_
                NewFile()
                return()
            when _STARTUP_RECENTFILES_
                mListRecentFiles()
            when _STARTUP_PICKLIST_
                EditFile("-a- *.*")
            when _STARTUP_MENU_
                loop
                    SignOn()
                    Set(X1, (Query(ScreenCols) / 2) - 9)
                    Set(Y1, (Query(ScreenRows) / 2) -  5)
                    StartupMenu()
                    if MenuOption() == 0
                        return()
                    elseif NumFiles()
                        if NumWindows() < 2 and not isZoomed()
                            OneWindow()
                        endif
                        Process(1)
                    endif
                    OneWindow()
                    lShowEntryScreen()
                endloop
                return()
        endcase
    endif

    // _STARTUP_PROMPT_ case and error loading specified file cases come here
    if NumFiles() == 0
        SignOn()
        EditFile()
    endif
end

/*=============================================================================
     THIS MACRO IS CALLED JUST AFTER THE FIRST FILE IS LOADED, BUT BEFORE THE
     USER IS GIVEN CONTROL, AND BEFORE ANY HOOK FUNCTIONS ARE CALLED.
 ============================================================================*/
proc Main()
     gScrollRollToggle()                                // set roll on

     Set(ShowHelpLine, OFF)
     DBlockAttr         = Query(BlockAttr)
     DCursorInBlockAttr = Query(CursorInBlockAttr)
     DStatusLineAttr    = Query(StatusLineAttr)
     Hook(_AFTER_UPDATE_STATUSLINE_, New_Status)        // gc  status line
end

/*******
/*================================================================== semware ==
                 QEDIT 2.15 STYLE SCRATCH BUFFER PACKAGE
      COMMENT OUT: Moved to external macro ver 2.05a  95/10/12
 ============================================================================
constant
    GETOVERLAY =    0,  // code depends on this order
    GETTING =       1,
    STORING =       2,
    APPENDING =     3,
    CUTTING =       4,
    CUTAPPEND =     5

integer named_clip_hist                         // not in 201y

integer proc mScratchBuffer(integer operation)
    integer cid, id, result, SaveClipBoardId
    string BufferName[40], msg[30]

    if operation > GETTING and (NOT (isBlockInCurrFile() or Query(usecurrlineifnoblock)))
        return (FALSE)
    endif
    BufferName = ""
    result = TRUE                               // assume success
    SaveClipBoardId = Query(ClipBoardId)          // save id
    case operation
        when STORING    msg = "Copy to ClipBoard:"
        when APPENDING  msg = "Copy Append to ClipBoard:"
        when GETTING    msg = "Paste from ClipBoard:"
        when GETOVERLAY msg = "Paste Over from ClipBoard:"
        when CUTTING    msg = "Cut to ClipBoard:"
        when CUTAPPEND  msg = "Cut Append to ClipBoard:"
    endcase
    if ask(msg, BufferName, named_clip_hist) and Length(BufferName)   // get scratch name
        BufferName = "+++" + BufferName         // Fudge for scratch
        id = GetBufferId(BufferName)             // See if already there
        if operation <> GETTING and id == 0
            cid = GetBufferId()
            id = CreateBuffer(BufferName, _SYSTEM_)    // create a buffer
            GotoBufferId(cid)
        endif
        if id <> 0                              // if it worked
            Set(ClipBoardId, id)                  // new ClipBoard
            case operation
                when STORING	result = Copy()
                when APPENDING	result = Copy(_APPEND_)
                when GETTING	result = Paste()
                when GETOVERLAY result = Paste(_OVERWRITE_)
                when CUTTING    result = Cut()
                when CUTAPPEND  result = Cut(_APPEND_)
            endcase
            Set(ClipBoardId, SaveClipBoardId)     // restore ClipBoard
        else
            warn("Could not create/find buffer")
        endif
    endif
    return (result)                               // return result
end
**/
/*
MENU NamedClipBoardMenu()
    title = "NAMED CB"
    history

    "&Copy..."          ,   mScratchBuffer(STORING)
    "Cop&y Append..."   ,   mScratchBuffer(APPENDING)
    "Cu&t..."           ,   mScratchBuffer(CUTTING)
    "C&ut Append..."    ,   mScratchBuffer(CUTAPPEND)
    ""                  ,   ,                           Divide
    "&Paste..."         ,   mScratchBuffer(GETTING)
    "&Paste &Over..."   ,   mScratchBuffer(GETOVERLAY)
end
*/
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                             
//                              THE MENUS 
//                             
//*=========================== Read a menu string ============================*/
string proc ReadStr(string m)
  string s[5] = m
  Return( iif(Read(s), s,m))
end

integer proc ReadNum(integer n)
  string s[5] = str(n)
    return (iif(Read(s), val(s), n))
end ReadNum

/*
integer proc OEMMenuFlags()
    string fontname[32] = ""
    integer pointsize, flags

    GetFont(fontname, pointsize, flags)
    return (iif(not isGUI() or (flags & _FONT_OEM_), _MF_DONT_CLOSE_, _MF_GRAYED_))
end
*/


integer proc GUIMenuFlags()   // Used for font menu
    return (iif(isGUI(), _MF_CLOSE_ALL_BEFORE_, _MF_GRAYED_))
end

MENU MacroMenu()
    Title = "Keyboard Macros"
    history

    "&Record"                       ,   RecordKeyMacro()
    "&Save..."                      ,   SaveKeyMacro()
    "Loa&d..."                      ,   LoadKeyMacro()
    "Run Scrap &Macro"              ,   ExecScrapMacro()
    "Pur&ge"                        ,   PurgeKeyMacro()
end

MENU UtilMenu()
    history

    "Set &Font"             ,   SetFont(), GUIMenuFlags()
    "&AutoLoad List"        ,   EditAutoLoadList()
    "&Hex View" [OnOffStr(DisplayMode() == _DISPLAY_HEX_):3],
            DisplayMode(iif(DisplayMode() == _DISPLAY_TEXT_, _DISPLAY_HEX_, _DISPLAY_TEXT_))
    "Set &Print Options  " ,   ExecMacro("Iconfig PrintConfig"), DontClose

end

MENU AutoIndentMenu()                   //^6, ^OA
    history = query(AutoIndent) + 1
    command = Set(AutoIndent, MenuOption() - 1)

    "O&ff"      ,, CloseBefore
    "O&n"       ,, CloseBefore
    "&Sticky"   ,, CloseBefore
end


MENU TabTypeMenu()
    history = query(TabType) + 1
    command = Set(TabType,MenuOption()-1)

    "&Hard"     ,, CloseBefore
    "&Soft"     ,, CloseBefore
    "Smar&t"    ,, CloseBefore
    "&Variable" ,, CloseBefore
end

MENU TabMenu()
  title = "Set Tabs"
    "&Tab Type"         [MenuStr(TabTypeMenu, Query(TabType)+1) : 8],
                        TabTypeMenu()                             ,DontClose
//     "&Width"            [query(TabWidth) : 5],
//                         set(TabWidth, ReadNum(Query(TabWidth)))   ,DontClose
//     "&Set Variable Tabs" , NewVarTabs()
end

proc mTab()

  TabMenu()
end

integer proc mSaveSettings()
    if YesNo("Overwrite existing config?") == 1
        return (iif(SaveSettings(), TRUE, Warn("Error updating executable")))
    endif
    return (FALSE)
end

MENU ReconfigMenu()
    history

    ""                                                           ,,Divide
    "&Backups"                 [OnOffStr(Query(MakeBackups)) : 3],
                                Toggle(MakeBackups)               ,DontClose
    "Backup &Ext"              [Query(BAckUpExt) : 4],
                        set(BAckUpExt, Readstr(Query(BAckUpExt))) ,DontClose
    ""                                                           ,,Divide
    "&Full Configuration  ",  ExecMacro("ICONFIG")           ,DontClose
    "&Save Current Settings",  mSaveSettings()
end

MENU MarginMenu()
title = "Set Margins"
       "&Right Margin"         [query(RightMargin) : 5],
                    set(RightMargin, ReadNum(Query(RightMargin))) ,DontClose
       "&Left Margin"          [query(LeftMargin) : 5],
                      set(LeftMargin, ReadNum(Query(LeftMargin))) ,DontClose
end

proc mMargin()
  MarginMenu()
end

menu SaveStateMenu()
    command = Set(SaveState, MenuOption() - 1)
    history = Query(SaveState) + 1

    "O&ff"                                  ,, CloseBefore
    "O&n    (Saved in loaddir)"             ,, CloseBefore
    "&Local (Saved in current directory)"   ,, CloseBefore
end
proc ReadLoad()
     ExecMacro("STATE -r -g")            // EXT MACRO  READ Load Dir
end
proc SaveLoad()
    ExecMacro("STATE -s- g")            // EXT MACRO  SAVE Load Dir
end
proc ReadLocal()
     ExecMacro("STATE -r -l")            // EXT MACRO  READ Local Dir
end
proc SaveLocal()
     ExecMacro("STATE -s -l")            // EXT MACRO  SAVE Local Dir
end

menu SaveStateonExitMenu()
    "Automatic on Exit"         ,                   ,   Divide
    "Save State on &Exit"   [iif(Query(SaveState) < 2,
                           OnOffStr(Query(SaveState)), "Local") : 5],
                           SaveStateMenu()            ,   DontClose
    "Immediate"           ,                   ,   Divide
    "READ Load  Dir"   ,    ReadLoad()
    "SAVE Load  Dir"   ,    SaveLoad()
    "READ Local Dir"   ,    ReadLocal()
    "SAVE Loacl Dir"   ,    SaveLocal()
end

MENUBAR MainMenu()
    history

//    "&Clipboard",   NamedClipboardMenu()
    "&Macro"   ,    MacroMenu()
    "SaveState",    SaveStateonExitMenu()
    "&Util"    ,    UtilMenu()
    "&Options" ,    ReconfigMenu()
end
//----------------------- END MENUS -------------------------------------------

//                             _____________
//                                HELP    
//                             _____________

helpdef helptext

"       I insert mide   A auto indent   W wordwrap    F block fill   O block overwrite                    "
"                S scroll/roll   B make backups  L Line draw                                              "
"          ^ = Control    # = Alt     = Shift     = toggles     = ext. macro                     SE4gui"
"________________________  MISC Commands  ____________  HELP  _____________________ PICK LISTS _________  "
" Repeat Cmd      ^QQ       Scroll / Roll      ^0     This HELP        F1   |   STRINGS    comp  ^JS     "
"                           Time stamp         ^1      HELP Index       F2   |   FUNCTIONS  comp  ^JF     "
" Set Tabs        ^OI       Date stamp         ^2      HELP Contents    F3   |   RECENT FILES     ^JR     "
" Set Margins     ^OR       Word Set Select    ^3      HELP on word     F4   |   OPEN   FILES     ^JO    "
" Auto Indent     ^OA ,^6   Status Line Hex    ^4     Previous HELP    F5   |   PREV FINDS w/ V  ^JP     "
" Menu Bar         F10      Save backups       ^OB                          |   BOOK MARKS       ^JB     "
" Set Delta Line   F9      UnDelete           ^U      Draw Line       F1   |   AutoLoad Macros  ^JL     "
" SpellCheck      ^QN      GLOBAL Undelete    #U      Line Type       F2                                "
"                                                                                                         "
"____________________________ BLOCK Commands ___________________________________________________________  "
" Mark block       ^KB      DEL   block      ^KY       FILL block mode  ^KJ     Goto block beg   ^QB     "
" Mark block       ^KK      COPY  block      ^KC       OVERWRITE  mode  ^KI     Goto block end   ^QK     "
" Mark line        ^KL      MOVE  block      ^KV                                 Goto Prev block  ^QV     "
" Mark word        ^KH      ENHANCED move    ^KM       Sort  block      ^OZ                               "
" Mark column      ^KN                                 Shift Block      ^OS      Upper case       ^OU     "
"                           INSERT file      ^KR                                 Lower case       ^OL     "
" UnMark block     ^KU      SAVE  to file    ^KW       PUSH Block Pos.  ^KA      Flip  case       ^OF     "
"                           PRINT to file    ^KP       POP  Block Pos.  ^KZ      Capital          ^OP    "
"                                                                                                         "
"            ___________ BLOCK and NO BLOCK EDIT Commands _________________________                       "
"         JUSTIFY center, left, right ^OC    Wordwrap/JUSTIFY ^OJ      WORDWRAP  ^B                      "
"                                                                                                         "
"_______________ FIND, REPLACE ______________________________ GOTO Commands ____________________________  "
" Find             ^QF      Find / Replace   ^QA       Goto Prev Pos.    ^QP     Goto Word End   ^QW      "
" Find word at cur ^QO      RepeatFind       ^L        Goto Prev Block   ^QV     Goto line       ^QI      "
" Incremental      ^QM     RepeatFind tog   ^QL      Goto Prev Find    ^QG     Goto mark       ^Q0..Q9  "
"                                                                                Set  mark       ^K0..K9  "
"                                                                                                         "
"_______________ CLIPBOARD  _____________________________   KEYBOARD MACROS  ____  COMPILER MACROS _____  "
" NAME CLIPBOARD    GREY /  Paste             grey *  Record            ^MR    COMPILE          #F9    "
" Cut               grey -   Paste Over       ^grey *  Write(file)       ^MW     COMPILE Menu     #F9    "
" Cut Append       ^grey -   Paste from WIN   #P       Load (file)       ^MK     DEBUGER          ^F9    "
" Copy              grey +   Copy  from WIN   #C       Purge             ^MY     Execute          ^ME     "
" Copy Append      ^grey +                             Execute Scrap     ^MX     Load             ^ML     "
"                                                                                                         "
"_____________________________________ FILE Commands  __________________________________________________  "
" Save file          ^KS     Global Save       #KS      Next file       ^PgDn                             "
" Save and Quit      ^KX     Global Save, Quit #KX      Prev file       ^PgUp                             "
" Ask and Quit       ^KQ     Global Ask,  Quit #KQ                                                        "
" Change name        ^KE     ABANDON EDITOR    #KA      UNLOAD UNUSED   #KU                              "
" Save As            ^KT     HEX View          ^OH                                                        "
" Reload current     #KR                                                                                  "
" Open new       F  ^KO                                                                                  "
" DEL CUR Disk File  #KY     GET   STATE FILE  ^MG  ...(local) ^MH                                      "
" Ask DEL disk file  #Y      WRITE STATE FILE  ^MS  ...(local) ^MD                                      "
"                                                                                                         "
"____________________________________  WINDOW Commands  ________________________________________________  "
" Open horizontal  ^OK       Close all but current  #O    ScrollLock    #L                               "
" Make horizontal  #H        Close current          #Q    Sync All      #S                              "
" Make vertical    #V        Delete other then cur  #D                                                    "
" Goto window      #1-5                                                                                   "
" Zoom             #Z        Goto next window   F8, #PgDn                                                 "
" Resize           #R, ^-    Goto prev window   F7, #PgUp                                                 "
"                                                                                                         "
"  _________________________________________________                                                      "
" MAKE_PG  ^MM     GLOB_FR  ^MF      POTPOURR  ^MZ                                                     "
""
//""
//  "  REGULAR EXPRESSION Operations "
//  "  .     matches any single character (except end-of-line)"
//  "  ^     anchors to beginning of line (or block)"
//  "  $     anchors to end of line       (or block)"
//  "  \n    in a REPLACE pattern: ref a Tagged search pattern"
//  "  |     'or' operator: matches preceding or following"
//  "  ?     optionally matches preceding pattern"
//  "  []    identifies a Class of characters"
//  "  [ - ] indicates a range of characters in a Class"
//  "  [~  ] identifies a complement Class"
//  "  *     matches 0 or more occurrences of preceding pattern (minimum closure)"
//  "  +     matches 1 or more occurrences of preceding pattern (minimum closure)"
//  "  @     matches 0 or more occurrences of preceding pattern (maximum closure)"
//  "  #     matches 1 or more occurrences of preceding pattern (maximum closure)"
//  "  {}    tags pattern group or component pattern"
//  "  \     excape operator: overrides Regular Expression operators: references"
//  "                         Tagged component in a Replace operation."
//  "  \a    matches beep      (^G, ASCII 7) "
//  "  \b    matches backspace (^H, ASCII 8) "
//  "  \f    matches formfeed  (^L, ASCII 12)"
//  "  \n    matches line feed (^J, ASCII 10)"
//  "  \r    matches return    (^M, ASCII 13)"
//  "  \t    matches tab       (^I, ASCII 9)"
//  "  \v    vertical tab      (^K, ASCII 11)"
//  "  \c    position cursor on within located string (with FIND command only)"
//  "  \xnn  matches hexadecimal equivalent"
//  "  \dnn  matches decimal equivalent"
//  "  \onn  matches octal   equivalent"

end //-------------------------- END HELP -------------------------------------

//=============================================================================
proc gHelpOnWordAtCursor()
    Help(GetWord(1), TRUE)
end

//=============================================================================
proc mDateStamp()
    InsertText(GetDateStr(), _INSERT_)
end

//=============================================================================
proc mTimeStamp()
    InsertText(GetTimeStr(), _INSERT_)
end

/*=============================================================================
                        DISPLAY BOOKMARKS ROUTINES
     Bookmarks 0-9 (a-j)   Previous BLOCK (k) and previous FIND (L)
 ============================================================================*/

proc MarkSetup()            // routine to build the 'visual' list of bookmarks.
    integer i, tid
    string s[80]

    PushPosition()                          // save place
    tid = CreateTempBuffer()                // for showing current marks
    i = 1

    while i <= 12                           // Get the current marks
        if GotoMark(Chr(Asc('a') + i - 1))  // if mark there, add to list
          if i<=10                          // bookmarks
            s = Format('Q':1, iif(i==10,0,i):1, ':   ',
                SplitPath(CurrFilename(), _NAME_ | _EXT_):-12, ' ',
                CurrLine():6, ' ', GetText(1, 50))
           else                             // Previous BLOCK and FIND
            s = Format(iif(i==11,'BLOCK','FIND '):5,  ':',
                SplitPath(CurrFilename(), _NAME_ | _EXT_):-12, ' ',
                CurrLine():6, ' ', GetText(1, 50))
           endif
            AddLine(s, tid)
        elseif i <=10
            s = Format('Q':1, iif(i==10,0,i):1, ':', '   no mark')
            AddLine(s, tid)
        else
            s = Format(iif(i==11,'BLOCK','FIND '):5,':','   no mark')
            AddLine(s, tid)
        endif
        i = i + 1
    endwhile
    GotoBufferId(tid)
    BegFile()
end  MarkSetup

proc mGotoBookMark()
    integer i

    MarkSetup()
    if NumLines() == 0
        i = 0
        Warn("No Bookmarks found")
    elseif ListIt("Goto Bookmark",Query(ScreenCols))
        i = CurrLine()
    else
        i = 0
    endif
    AbandonFile()                  // Delete the bookmark buffer
    if i
        KillPosition()
        GotoMark(Chr(Asc('a') + i - 1))
    else
        PopPosition()
    endif
end mGotoBookMark
//------------------- END Display Bookmark routines -----------------------
/*================================================================== semware ==
  AUGMENT BEGFILE BY MAINTAINING THE CURRENT COLUMN IF A CLOUMN BLOCK IS OPEN
 ============================================================================*/

proc mBegFile()
    integer col = CurrCol(), xoff = CurrXoffset()

    BegFile()
    if Query(Marking) and isBlockInCurrFile() == _COLUMN_
        GotoColumn(col)
        GotoXoffset(xoff)
    endif
end

/*================================================================== semware ==
  AUGMENT ENDFILE BY MAINTAINING THE CURRENT COLUMN IF A CLOUMN BLOCK IS OPEN
 ============================================================================*/
proc mEndFile()
    integer col = CurrCol(), xoff = CurrXoffset()

    EndFile()
    if Query(Marking) and isBlockInCurrFile() == _COLUMN_
        GotoColumn(col)
        GotoXoffset(xoff)
    endif
end
/*================================================================== semware ==
      AUGMENT DELCHAR BY JOINING LINES IF AT OR PASSED EOL
 ============================================================================*/
integer proc mDelChar()
    return(iif(CurrChar() >= 0, DelChar(), JoinLine()))
end

/*=============================================================================
                   MOVE CURSOR TO THE END OF CURRENT WORD
 ============================================================================*/
proc mEndOfWord()
//    string s[78] = "", t[32] = ""

//     Wrd_Set2Chars(Query(wordset), s)          // get current wordset
//     Set(wordset, Chrset("\d033-\d126"))       // set Alpha and numeric ONLY

    if not isWord()
       WordRight()
    endif
    EndWord()

//     Wrd_Chars2Set(s, t)                       // restore current wordset
//     Set(wordset, t)
end

/*=============================================================================
                   RepeatFind TOGGLE FORWARD, BACKWARD
    finddirection = 0 -> find forward   finddirection -> 1 find backward
 ============================================================================*/
integer repeatfind_mode

proc gRepeatFindToggle(integer finddirection)

    if finddirection                                    // toggle
       repeatfind_mode = repeatfind_mode ^ 1
       Set(HiLiteAttr, iif(repeatfind_mode,color(Red on Cyan),
                                           color(Bright Yellow on Cyan)))
       return()
    endif
    RepeatFind(iif(repeatfind_mode, _BACKWARD_, _FORWARD_))
end

/*=============================================================================
                          ENHANCED WINDOW FUNCTIONS
 ============================================================================*/
proc mOpenWindow()

    HWindow()
    if not EditFile()
        CloseWindow()
    endif
end

integer proc mWindow(integer wind_type)
  string fn[65] = CurrFilename()

    CloseWindow()
    EditFile(fn)
    if wind_type        // VERTICAL     wind_type > 0
       VWindow()
    else
       HWindow()        // HORIZIONTAL  wind_type = 0
    endif
    return(wind_type)
end

/*=============================================================================
                   CLOSE FILE AND RELOAD FILE FROM DISK
 ============================================================================*/
proc mReloadCurrentFile()
  string fn[65] = CurrFilename()
  integer     i = 0

  i = CurrLine()
  AbandonFile()
  EditFile(fn)
  GotoLine(i)
  ScrollToCenter()
  Message("FILE RELOADED FROM DISK")
end

/*================================================================= semware ===
                     CHANGES QuitFile TO ACT LIKE QEDIT
 ============================================================================*/
integer proc mQuitFile()
    if Filechanged()
        if yesno("Lose Changes? ") == 1
            FileChanged(FALSE)
            quitfile()
            CloseWindow()
        else
            return(FALSE)
        endif
    else
        quitfile()
        CloseWindow()
    endif
    return(TRUE)
end

/*================================================================= semware ===
                     CHANGES Exit TO ACT LIKE QEDIT mGPQuit
 ============================================================================*/
proc mQuitAllFiles()
    integer qtp = Set(QuitToPrompt,OFF)

    while mQuitFile()    // call the macro listed above
       UpDateDisplay()
    endwhile
    Set(QuitToPrompt,qtp)
end

/*================================================================= semware ===
                          HEX MODE TOGGLE
 ============================================================================*/
proc ToggleHexEdit()
    DisplayMode(iif(DisplayMode() == _DISPLAY_TEXT_, _DISPLAY_HEX_, _DISPLAY_TEXT_))
    gStat_ShowHexToggle()
end

/*================================================================= semware ===
                          mTABRIGHT need for hex mode
 ============================================================================*/
proc mTabRight()
    If DisplayMode() == _DISPLAY_HEX_
      If HexEdit(ON)  HexEdit(OFF)  endif  // toggle between ascii and hex
    else
      TabRight()
    endif
end

/*=============================================================================
    Augmented DOS function
 ============================================================================*/
/*proc mDos()
  integer vmode = Query(CurrVideoMode)
  Dos()
  Set(CurrVideoMode, vmode)
end

proc mShell()
  integer vmode = Query(CurrVideoMode)
  Shell()
  Set(CurrVideoMode, vmode)
end
*/
proc gDelDiskFile()
  string fn[30] = ""
    Ask("DELETE Filespec, wild cards allowed",fn)
    EraseDiskFile(fn)
end

//=============================================================================
//                             
//                                KEY BINDINGS   
//                             

KeyDef PromptKeys             // temporary reassign keys for prompt boxes
  <ctrl g>     DelChar()
  <grey*>      Paste()
end PromptKeys

<CursorLeft>            Left()
<ctrl s>                Left()
<CursorRight>           Right()
<ctrl d>                Right()
<CursorUp>              Up()
<ctrl e>                Up()
<CursorDown>            Down()
<ctrl x>                Down()

<tab>                  mTabRight()
<ctrl i>               mTabRight()
<shift Tab>             TabLeft()

<ctrl CursorRight>      WordRight()
<ctrl f>                WordRight()
<ctrl CursorLeft>       WordLeft()
<ctrl a>                WordLeft()
<ctrl q><w>            mEndOfWord()

<ctrl CursorUp>         ScrollUp()
<ctrl w>               mRollUp()          //ScrollUp()
<ctrl CursorDown>       ScrollDown()
<ctrl z>               mRollDown()        //ScrollDown()

<home>                  BegLine()
<ctrl q><s>             BegLine()
<end>                   EndLine()
<ctrl q><d>             EndLine()
<pgUp>                  PageUp()
<ctrl r>                PageUp()
<pgDn>                  PageDown()
<ctrl c>                PageDown()

<Ctrl home>             BegWindow()
<ctrl q><e>             BegWindow()
<Ctrl end>              EndWindow()
<ctrl q><x>             EndWindow()

<ctrl q><r>            mBegFile()
<ctrl q><c>            mEndFile()

<ctrl q><p>             PrevPosition()
<ctrl q><g>             GotoMark("l")       // previous find
<ctrl q><v>             GotoMark("k")       // previous block

<ctrl q><0>             GotoMark("j")
<ctrl q><1>             GotoMark("a")
<ctrl q><2>             GotoMark("b")
<ctrl q><3>             GotoMark("c")
<ctrl q><4>             GotoMark("d")
<ctrl q><5>             GotoMark("e")
<ctrl q><6>             GotoMark("f")
<ctrl q><7>             GotoMark("g")
<ctrl q><8>             GotoMark("h")
<ctrl q><9>             GotoMark("i")

<ctrl k><0>             PlaceMark("j")
<ctrl k><1>             PlaceMark("a")
<ctrl k><2>             PlaceMark("b")
<ctrl k><3>             PlaceMark("c")
<ctrl k><4>             PlaceMark("d")
<ctrl k><5>             PlaceMark("e")
<ctrl k><6>             PlaceMark("f")
<ctrl k><7>             PlaceMark("g")
<ctrl k><8>             PlaceMark("h")
<ctrl k><9>             PlaceMark("i")

<ctrl j><b>            mGotoBookMark()      // display bookmark picklist
// Text formatting and editing _______________________________________________
<BackSpace>            mBackSpace()
<ctrl h>               mBackSpace()
<Del>                  mDelChar()
<ctrl g>               mDelChar()
<ctrl t>                DelRightWord()
<ctrl q><y>             DelToEol()
<ctrl y>                DelLine()
<ctrl n>                SplitLine()
<ctrl p>                Literal()
<Enter>                mCreturn()
<ctrl u>                UnDelete()
<ctrl b>               mWrapPara()
<ctrl o><c>            gCenterText()
<ctrl o><j>            ExecMacro("JUSTIFY")

<ctrl o><s>            mShift()
<ctrl o><z>            mSort()
<ctrl o><u>            mUpper()
<ctrl o><l>            mLower()
<ctrl o><f>            mFlip()
<ctrl o><p>            ExecMacro("CAPITAL")

<alt u>                 GlobalUnDelete()

// Block Marking commands ____________________________________________________
<ctrl k><b>            mKB()                // marks current block for ^QV
<ctrl k><k>             MarkChar()
<ctrl k><l>             UnmarkBlock() MarkLine() MarkLine()
<ctrl k><h>            mMarkWord()
<ctrl k><u>             UnmarkBlock()
<ctrl k><n>            mKN()                // marks current block for ^QV
<ctrl k><m>            mMarkColumnMove()    // enhanced mark and move

<ctrl k><i>            gBlockOverwriteToggle()
<ctrl k><j>            gBlockFillToggle()
<ctrl k><y>            mDelBlock()
<ctrl k><c>             CopyBlock(blockoverwrite_mode)
<ctrl k><v>            mBlockMove()
<ctrl k><r>             InsertFile()
<ctrl k><w>             SaveBlock()

<ctrl q><b>             GotoBlockBegin()
<ctrl q><k>             GotoBlockEnd()

<ctrl k><a>             PushBlock()
<ctrl k><z>             PopBlock()

<ctrl k><p>            mKP()             //Print Block / Print file

// File/Exit _________________________________________________________________
<ctrl k><s>             SaveFile()              // save current
<alt k><s>              SaveAllFiles()          // save global
<ctrl k><x>             SaveAndQuitFile()       // save and exit current
<alt k><x>              SaveAllAndExit()        // save and exit global
<ctrl k><q>            mQuitFile()              // ask to save and exit current
<alt k><q>             mQuitAllFiles()          // ask to save and exit global
<ctrl k><t>             SaveAs()
<ctrl k><e>             ChangeCurrFilename()
<ctrl k><o>             EditFile()
<alt f>                 EditFile()
<alt k><r>             mReloadCurrentFile()
<Ctrl PgUp>             NextFile()
<Ctrl PgDn>             PrevFile()
<alt k><a>              AbandonEditor()
<alt k><u>              ExecMacro("UNLOAD")
<alt k><y>              KillFile()          //Erase disk file
<alt y>                gDelDiskFile()

// Window _____________________________________________________________________
<ctrl o><k>            mOpenWindow()
<alt h>                mWindow(0)           // change/open horizontal
<alt v>                mWindow(1)           // change/open vertical
<alt z>                 ZoomWindow()
<alt o>                 OneWindow()
<alt q>                 CloseWindow()
<alt d>                 DelWindow()
<alt PgUp>              PrevWindow()
<f7>                    PrevWindow()
<alt PgDn>              NextWindow()
<f8>                    NextWindow()
<ctrl ->                ResizeWindow()
<alt r>                 ResizeWindow()
<alt l>                gScrollLockToggle()
<alt s>                ExecMacro("SYNCHSCR")

<alt 1>                 GotoWindow(1)
<alt 2>                 GotoWindow(2)
<alt 3>                 GotoWindow(3)
<alt 4>                 GotoWindow(4)
<alt 5>                 GotoWindow(5)

// Find/Replace ______________________________________________________________
<ctrl q><f>            mFind()
<ctrl q><m>            ExecMacro("ISRCH")          // EXT MACRO
<ctrl q><o>            mFindWordAtCursor()
<ctrl q><a>             Replace()
<ctrl l>               gRepeatFindToggle(0)
<ctrl q><l>            gRepeatFindToggle(1)      // toggle forward backward
<ctrl q><i>             GotoLine()
// Picklist __________________________________________________________________
<ctrl j><o>             ExecMacro("LISTOPEN")  // EXT MACRO
<ctrl j><r>            mListRecentFiles()
<ctrl j><s>            mCompressView(0)         // list string
<ctrl j><f>            mCompressView(1)         // list functions
<ctrl j><p>             ViewFinds()             // previous finds with 'v'


// Clipboard _________________________________________________________________
<grey*>                 Paste()
<grey+>                 Copy()
<grey->                 Cut()
<ctrl  grey*>           Paste(_OVERWRITE_)
<ctrl  grey+>           Copy(_APPEND_)
<ctrl  grey->           Cut(_APPEND_)
//<alt grey*>             PasteFromWinClip()
<alt p>                 PasteFromWinClip()
<alt c>                 CopyToWinClip()
<grey/>                 ExecMacro("NAMECLIP")

// Macro _____________________________________________________________________
<ctrl m><r>             RecordKeyMacro()
<ctrl m><w>             SaveKeyMacro()
<ctrl m><k>             LoadKeyMacro()
<ctrl m><y>             PurgeKeyMacro()
<ctrl m><x>             ExecScrapMacro()

<ctrl m><p>             PurgeMacro()
<ctrl m><e>             ExecMacro()
<ctrl m><l>             LoadMacro()
<ctrl j><l>             EditAutoLoadList()      // autoload external macro list
<ctrl  F9>             mDebugCurrFile()
<alt   F9>              ExecMacro("COMPILE " + QuotePath(CurrFilename()))  // EXT MACRO
<shift F9>              ExecMacro("COMPILE -m")            // EXT MACRO

<ctrl m><a>           mAsciiChart()
<ctrl m><m>            ExecMacro("MAKE_PG")                // EXT MACRO
<ctrl m><f>            ExecMacro("GLOB_FR")                // EXT MACRO
<ctrl q><n>            ExecMacro("SPELLCHK")               // EXT MACRO

<ctrl m><g>            ExecMacro("STATE -r -g")            // EXT MACRO  READ Load Dir
<ctrl m><s>            ExecMacro("STATE -s- g")            // EXT MACRO  SAVE Load Dir
<ctrl m><h>            ExecMacro("STATE -r -l")            // EXT MACRO  READ Local Dir
<ctrl m><d>            ExecMacro("STATE -s -l")            // EXT MACRO  SAVE Local Dir
<ctrl m><z>            ExecMacro("POTPOURR")               // EXT MACRO

// Other _____________________________________________________________________
<Ins>                   ToggleInsert()
<ctrl v>                ToggleInsert()
<ctrl 0>               gScrollRollToggle()
<ctrl 6>                AutoIndentMenu()
<ctrl o><a>             AutoIndentMenu()
<ctrl o><w>            mToggleWordWrap()
<ctrl q><q>             RepeatCmd()

<ctrl o><h>             ToggleHexEdit()
//<alt  k><f>            mShell()

<ctrl o><i>            mTab()
<ctrl o><r>            mMargin()

<ctrl 3>                WordSetMenu()
<f9>                   gDeltaLineToggle ()
<ctrl 4>               gStat_ShowHexToggle()

<ctrl 2>               mDateStamp()
<ctrl 1>               mTimeStamp()
<ctrl o><b>            Toggle(makebackups)

<shift f1>              Toggle(LineDrawing)
<shift f2>              LineTypeMenu()

<f1>                    QuickHelp(HelpText)
<f2>                    Help("Index")
<f3>                    Help('Table of Contents')
<f4>                   gHelpOnWordAtCursor()
<f5>                    PrevHelp()
<f6>                    SearchHelp()
<f10>                   MainMenu()

//*** Mouse keys ************************************************************
<LeftBtn>               mLeftBtn()
//Ctrl LeftBtn>          MouseMarking(_COLUMN_)
//<Alt LeftBtn>           MouseMarking(_LINE_)
//<Shift LeftBtn>         mTrackMouseCursor()
<RightBtn>              mRightBtn()
<WheelUp>               RollUp(GetWheelScrollLines())
<WheelDown>             RollDown(GetWheelScrollLines())





/**____________________  UNUSED KEY BINDINGS _____________________________
ctrl Ja   ctrl Qh    ctrl Mb       alt a
          ctrl Qj    ctrl Mc       alt b
ctrl Jc              ctrl Mi
ctrl Jd   ctrl Qt    ctrl Mj
ctrl Je   ctrl Qu    ctrl Mn       alt e
          ctrl Qz    ctrl Mo       alt g
ctrl Jg              ctrl Mq       alt i
ctrl Jh              ctrl Mt       alt j
ctrl Ji              ctrl Mu       alt k
ctrl Jj   ctrl Od    ctrl Mv
ctrl Jk   ctrl Oe    ctrl Kd       alt m
ctrl Jl   ctrl Og    ctrl Kg       alt n
ctrl Jm   ctrl Om
ctrl Jn   ctrl Ot
ctrl Jq   ctrl Ov                  alt t
          ctrl Ox
ctrl Jt   ctrl Oy                  alt x
ctrl Ju
ctrl Jv          ctrl Mg, Ms, Mh, Md Mo   reserved for STATE macro
ctrl Jw          ctrl Mm                  reserved for MAKE_PG macro
ctrl Jx
ctrl Jy
ctrl Jz
ctrl Kf
 ___________________________________________________________________________**/

