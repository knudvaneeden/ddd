/*
  Macro           KeyboardLogger
  Author          Carlo Hogeveen
  Website         eCarlo.nl/tse
  Compatibility   TSE Pro v4 upwards
  Version         v2.0.1   17 Sep 2022


  PURPOSE

  This TSE extension and tool can (only!) log your TSE keystrokes.

  Default it logs your keystrokes to your user folder to the subfolder
  "Log\Tse\<macro name>" to the file "<yyyymmdd>_<hhmmss>_<ssssss>.txt", where
  "<yyyymmdd>_<hhmmss>" indicates the start of the log session and "<ssssss>"
  is the number that Windows uses to identify your TSE session.

  For example for Windows logging could default be written to:
    C:\Users\Alice\Log\Tse\KeyboardLogger\20191231_2359_123.txt
  or for example for Linux could default be written to:
    /home/alice/log/tse/KeyboardLogger/20191231_2359_123.txt


  INSTALLATION

  Copy this file to TSE's "mac" folder, open the file in TSE, and compile it
  as a macro with the Macro Compile menu.

  Optionally add the macro's name (default "KeyboardLogger") in TSE's
  "Macro -> AutoLoad List" menu.

  If you do, then where in the list you add the macro is very important:
    A few other autoloaded macros intercept TSE keys, replace their original
    functionality with their own, and overwrite the keys' key code with -1
    to prevent TSE from seeing the original key and executing its original
    function. The keyname of key -1 is usually <CtrlAltShift Ÿ>.
    Typical examples of such macros are Semware's CUAMark and my Keys macro.
    If KeyboardLogger is below CUAMark and Keys in the Macro AutoLoad List,
    then KeyboardLogger will "see" new key strokes before they do, and it can
    can log them before they are overwritten by CUAMark or Keys.

  If you do not autoload KeyboardLogger but load it during a TSE session,
  then it will always see keys before autoloaded macros do: The last loaded
  macro "sees" keys first.

  Exucuting the macro during a TSE session only loads it if it was not loaded
  yet.

  Execute the macro to turn logging on or off or to configured it.


  WHAT IS LOGGED

  At the start of the logfile information is logged about TSE and the session.

  The full name of the file in which the keystrokes occur
  is logged in a line with that full filename between "[" and "]".

  Any sequence of keys that are characters
  is logged as a line between "{" and "}".

  Any sequence of keys that are not characters
  is logged as a line of keynames,
  where each keyname is enclosed between "<" and ">".

  If TSE is closed properly or the macro is purged, then an extra line is added
  to the logfile to confirm that.



  CAVEAT
  Purge this macro before using TSE to do anything related to passwords,
  so that typed passwords are not written to a logfile.
  You can reload the macro or restart TSE afterwards.




  HISTORY

  v1.0    18 Nov 2018
    First released version.
  v1.1     2 Jan 2019
    Deleted code that compensated for garbage generated by
    the RemoveTrailingWhiteBugWorkAround macro,
    since I stopped using that macro some time ago,
    and I want to upload the KeyboardLogger macro for general usage.
  v1.1.1   3 Jan 2019
    Documented that and why KeyboardLogger needs to be installed
    below CuaMark in the Macro AutoLoad List.
  v1.1.2  17 Oct 2019
    Improved robustness for old TSE versions by updating VersionStr()
    from 1.0 to 1.1.
  v2       8 May 2020
    Instead of first logging keystrokes to a buffer and afterwards copying the
    buffer to a file, now keystrokes are immediately logged to a file on disk.
    The formerly proscribed method of autoloading the macro is loosened and
    enhanced with intermediate options.
    Executing the macro now provides a menu with run-tim and configuration
    options.
    Added Linux compatibility.

  v2.0.1   17 Sep 2022
    Fixed incompatibility with TSE's '-i' command line option
    and the TSELOADDIR environment variable.

*/





// Start of compatibility restrictions and mitigations



#ifdef WIN32
#else
   16-bit versions of TSE are not supported. You need at least TSE 4.0.
#endif

#ifdef EDITOR_VERSION
#else
   Editor Version is older than TSE 3.0. You need at least TSE 4.0.
#endif

#if EDITOR_VERSION < 4000h
   Editor Version is older than TSE 4.0. You need at least TSE 4.0.
#endif



#if EDITOR_VERSION < 4200h
  /*
    MkDir() 1.0

    This procedure implements the MkDir() command of TSE 4.2 upwards.
  */
  integer proc MkDir(string dir)
    Dos('MkDir ' + QuotePath(dir), _START_HIDDEN_)
    return(not DosIOResult())
  end MkDir
#endif



#if EDITOR_VERSION < 4400h
  /*
    StrReplace() 1.0

    If you have TSE Pro 4.0 or 4.2, then this proc almost completely implements
    the built-in StrReplace() function of TSE Pro 4.4.
    The StrReplace() procedure replaces a string (pattern) inside a string.
    It works for strings like the Replace() function does for files, so read
    the Help for the Replace() function for the usage of the options, but apply
    these differences while reading:
    - Where Replace() refers to "file" and "line", StrReplace() refers to
      "string".
    - The options "g" ("global", meaning "from the start of the string")
      and "n" ("no questions", meaning "do not ask for confirmation on
      replacements") are implicitly always active, and can therefore be omitted.
    Notable differences between the procedure below with TSE 4.4's built-in
    function are, that here the fourth parameter "options" is mandatory
    and that the fifth parameter "start position" does not exist.
  */
  integer strreplace_id = 0
  string proc StrReplace(string needle, string haystack, string replacer, string options)
    integer i                      = 0
    integer org_id                 = GetBufferId()
    string  result  [MAXSTRINGLEN] = haystack
    string  validated_options [20] = 'gn'
    for i = 1 to Length(options)
      if (Lower(SubStr(options, i, 1)) in '0'..'9', 'b', 'i','w', 'x', '^', '$')
        validated_options = validated_options + SubStr(options, i, 1)
      endif
    endfor
    if strreplace_id == 0
      strreplace_id = CreateTempBuffer()
    else
      GotoBufferId(strreplace_id)
      EmptyBuffer()
    endif
    InsertText(haystack, _INSERT_)
    lReplace(needle, replacer, validated_options)
    result = GetText(1, CurrLineLen())
    GotoBufferId(org_id)
    return(result)
  end StrReplace
#endif



#if EDITOR_VERSION < 4400h
  /*
    VersionStr()  v1.1

    This procedure implements TSE Pro 4.4 and above's VersionStr() command
    for lower versions of TSE.
    It returns a string containing TSE's version number in the same format
    as you see in the Help -> About menu, starting with the " v".

    Examples of relevant About lines:
      The SemWare Editor Professional v4.00e
      The SemWare Editor Professional/32 v4.00    [the console version]
      The SemWare Editor Professional v4.20
      The SemWare Editor Professional v4.40a

    v1.1 fixes recognition of the TSE Pro v4.0 console version.
  */
  string versionstr_value [MAXSTRINGLEN] = ''

  proc versionstr_screen_scraper()
    string  attributes [MAXSTRINGLEN] = ''
    string  characters [MAXSTRINGLEN] = ''
    integer position                  = 0
    integer window_row                = 1
    while versionstr_value == ''
    and   window_row       <= Query(WindowRows)
      GetStrAttrXY(1, window_row, characters, attributes, MAXSTRINGLEN)
      position = Pos('The SemWare Editor Professional', characters)
      if position
        position = Pos(' v', characters)
        if position
          versionstr_value = SubStr(characters, position + 1, MAXSTRINGLEN)
          versionstr_value = GetToken(versionstr_value, ' ', 1)
        endif
      endif
      window_row = window_row + 1
    endwhile
  end versionstr_screen_scraper

  string proc VersionStr()
    versionstr_value = ''
    Hook(_BEFORE_GETKEY_, versionstr_screen_scraper)
    PushKey(<Enter>)
    PushKey(<Enter>)
    BufferVideo()
    lVersion()
    UnBufferVideo()
    UnHook(versionstr_screen_scraper)
    return(versionstr_value)
  end VersionStr
#endif



// End of compatibility restrictions and mitigations





//  Global constants:
string  FILE_CLOSE_DELIMITER      [1] = ']'   // In logfile.
string  FILE_OPEN_DELIMITER       [1] = '['   // In logfile.
string  KEYNAME_CLOSE_DELIMITER   [1] = '>'   // In logfile.
string  KEYNAME_OPEN_DELIMITER    [1] = '<'   // In logfile.
integer MAX_LOG_LINE_LENGTH           = 80    // In logfile.
string  MY_LOG_DIR     [MAXSTRINGLEN] = ''    // A non-default log folder.
integer SAVE_LOGFILE_PERIOD           = 300   // Seconds.
string  STRING_CLOSE_DELIMITER    [1] = '}'   // In logfile.
string  STRING_OPEN_DELIMITER     [1] = '{'   // In logfile.


// Global variables:
integer first_call_to_idle            = TRUE
string  last_file_name [MAXSTRINGLEN] = ''
string  log_dir        [MAXSTRINGLEN] = ''
string  log_file       [MAXSTRINGLEN] = ''
integer log_id                        = 0
integer save_logfile_clockticks       = 0
string  macro_name     [MAXSTRINGLEN] = ''
integer old_DateFormat                = 0
integer old_DateSeparator             = 0
integer old_TimeFormat                = 0
integer old_TimeSeparator             = 0
integer prev_clockticks               = 0


/*
  Return TSE's original LoadDir() if LoadDir() has been redirected
  by TSE's "-i" commandline option or a TSELOADDIR environment variable.
*/
string proc original_LoadDir()
  return(SplitPath(LoadDir(TRUE), _DRIVE_|_PATH_))
end original_LoadDir

proc after_getkey()
  string  curr_file_name [MAXSTRINGLEN] = ''
  string  key_name                 [32] = KeyName(Query(Key))
  integer org_id                        = GetBufferId()
  if log_id
    curr_file_name = CurrFilename()
    GotoBufferId(log_id)
    if curr_file_name <> last_file_name
      AddLine(FILE_OPEN_DELIMITER + curr_file_name + FILE_CLOSE_DELIMITER)
      EndLine()
      last_file_name = curr_file_name
    endif
    if Length(key_name) > 1
      if key_name == 'Spacebar'
        key_name = ' '
      else
        key_name = KEYNAME_OPEN_DELIMITER + key_name + KEYNAME_CLOSE_DELIMITER
      endif
    endif
    if Length(key_name) == 1
      if  CurrLineLen() < MAX_LOG_LINE_LENGTH
      and GetText(CurrLineLen(), 1) == STRING_CLOSE_DELIMITER
        InsertText(key_name, _INSERT_)
      else
        AddLine(STRING_OPEN_DELIMITER + key_name + STRING_CLOSE_DELIMITER)
        GotoPos(3)
      endif
    else
      if  CurrLineLen() + Length(key_name) <= MAX_LOG_LINE_LENGTH
      and GetText(CurrLineLen(), 1) == KEYNAME_CLOSE_DELIMITER
        InsertText(key_name, _INSERT_)
      else
        AddLine(key_name)
        EndLine()
      endif
    endif
    GotoBufferId(org_id)
  endif
end after_getkey

proc save_logfile()
  integer old_msglevel = 0
  integer org_id       = GetBufferId()
  if log_id
    GotoBufferId(log_id)
    old_msglevel = Set(MsgLevel, _WARNINGS_ONLY_)
    SaveFile()
    Set(MsgLevel, old_msglevel)
    GotoBufferId(org_id)
  endif
end save_logfile

proc idle()
  integer clockticks = GetClockTicks()
  if first_call_to_idle
    // The check has to be done here too, once,
    // because the rtwbwa macro can be autoloaded after this macro.
    prev_clockticks = clockticks
    first_call_to_idle = FALSE
  endif
  if clockticks - prev_clockticks > save_logfile_clockticks
    prev_clockticks = clockticks
    save_logfile()
  endif
end idle

proc customise_date_time_formats()
  old_DateFormat    = Set(DateFormat   , 6 )
  old_DateSeparator = Set(DateSeparator, Asc('*'))
  old_TimeFormat    = Set(TimeFormat   , 3 )
  old_TimeSeparator = Set(TimeSeparator, Asc('*'))
end customise_date_time_formats

proc restore_date_time_formats()
  Set(DateFormat   , old_DateFormat   )
  Set(DateSeparator, old_DateSeparator)
  Set(TimeFormat   , old_TimeFormat   )
  Set(TimeSeparator, old_TimeSeparator)
end restore_date_time_formats

string proc standardise_dir(string dir)
  string result [MAXSTRINGLEN] = dir
  if (result[Length(result):1] in '\', '/')
    result = result[1:Length(result) - 1]
  endif
  return(result)
end standardise_dir

integer proc set_env_dir(var string dir, string env_var_1, string env_var_2)
  string  env_path [MAXSTRINGLEN] = GetEnvStr(env_var_1) + GetEnvStr(env_var_2)
  integer result                  = FALSE
  if FileExists(env_path) & _DIRECTORY_
    dir    = env_path
    result = TRUE
  endif
  return(result)
end set_env_dir

integer proc add_subdir(var string dir, string subdir)
  integer result = FALSE
  if not (FileExists(dir + '\' + subdir) & _DIRECTORY_)
    MkDir(dir + '\' + subdir)
  endif
  if FileExists(dir + '\' + subdir) & _DIRECTORY_
    dir    = dir + '\' + subdir
    result = TRUE
  else
    Warn('ERROR: Could not create folder: ', dir + '\' + subdir)
  endif
  return(result)
end add_subdir

proc WhenPurged()
  integer org_id = GetBufferId()
  if log_id
    GotoBufferId(log_id)
    AddLine('')
    AddLine(Format('Logfile closed on ',
                   GetDateStr(), ' at ', GetTimeStr(), '.'))
    GotoBufferId(org_id)
  endif
  save_logfile()
end WhenPurged

proc WhenLoaded()
  integer org_id = GetBufferId()
  save_logfile_clockticks = SAVE_LOGFILE_PERIOD * 18
  macro_name = SplitPath(CurrMacroFilename(), _NAME_)
  if MY_LOG_DIR <> ''
    log_dir = MY_LOG_DIR
  endif
  if log_dir == ''
    if set_env_dir(log_dir, 'USERPROFILE', ''        )
    or set_env_dir(log_dir, 'HOMEDRIVE'  , 'HOMEPATH')
      standardise_dir(log_dir)
      if not add_subdir(log_dir, 'Log')
      or not add_subdir(log_dir, 'Tse')
      or not add_subdir(log_dir, macro_name)
        Warn('ERROR: Cannot create subfolder in: ', log_dir)
        log_dir = ''
      endif
    else
      Warn('ERROR: No USERPROFILE or HOMEDRIVE\HOMEPATH environment variables with folders.')
      log_dir = ''
    endif
  else
    standardise_dir(log_dir)
    if FileExists(log_dir) & _DIRECTORY_
      if Lower(SplitPath(log_dir, _NAME_|_EXT_)) <> Lower(macro_name)
      or not add_subdir(log_dir, macro_name)
        Warn('ERROR: Cannot create subfolder in: ', log_dir)
        log_dir = ''
      endif
    else
      Warn('ERROR: Folder does not exist: ', log_dir)
      log_dir = ''
    endif
  endif
  if log_dir <> ''
    customise_date_time_formats()
    log_file = Format(log_dir, '\', GetDateStr(), '_', GetTimeStr(), '_',
                      GetWinHandle(), '.txt')
    restore_date_time_formats()
    log_file = StrReplace('*', log_file, '', '')
    log_id   = CreateBuffer(log_file, _SYSTEM_)
    AddLine(Format('Logfile started on ', GetDateStr(), ' at ', GetTimeStr(),
                   ' for window handle ', GetWinHandle(), '.'))
    AddLine(Format('TSE program  folder: ', original_LoadDir()))
    AddLine(Format('TSE settings folder: ', LoadDir()))
    AddLine(Format('TSE EDITOR_VERSION : ', Str(EDITOR_VERSION, 16), ' (hex)'))
    AddLine(Format('TSE Version()      : ', Str(Version()     , 16), ' (hex), ', Version(), ' (dec).'))
    AddLine(Format('TSE VersionStr()   : ', VersionStr()           , '.'))
    AddLine(Format('This is the ', iif(isGUI(), 'GUI', 'Console'),
                   ' version of the editor.'))
    case WhichOS()
      when _WINDOWS_
        AddLine(Format('The OS is Windows 95, 98, Millennium or older.'))
      when _WINDOWSNT_
        AddLine(Format('The OS is Windows NT or newer.'))
#if EDITOR_VERSION >= 4400h
      when _LINUX_
        AddLine(Format('The OS is Linux.'))
#endif
      otherwise
        AddLine(Format('The OS is unknown.'))
    endcase
    AddLine('')
    AddLine('')
    GotoBufferId(org_id)
    save_logfile()
    Hook(_AFTER_GETKEY_     , after_getkey)
    Hook(_IDLE_             , idle        )
    Hook(_ON_ABANDON_EDITOR_, WhenPurged  )
  endif
end WhenLoaded

