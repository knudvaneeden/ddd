/*
   Macro : oSqlFmt
   Author: carlo.hogeveen@xs4all.nl
   Date  : 21 June 2001

   If you export Oracle database tables to an "insert script" using Toad,
   then it isn't in an optimal format for mass editing with TSE.

   This macro remedies that.

   First it wraps the insert statements to one line for each statement.

   Then this macro makes the columns of equal length, left justifying
   alfanumeric columns, and right-justifying numeric columns.

   For those who feel the desire to delve into the macro: to view the
   "to_date" function as one culumn, the macro ignores second-level
   parentheses.

   Two problems remain:
   -  The insert statement for a tuple might be longer than TSE's maximum
      line length, in that case the remainder of the statement stays
      unwrapped.
   -  Alfanumeric fields may contain single quotes. Since Oracle sql demands
      single quotes around alphanumeric fields, this creates a problem: the
      macro adds unwanted spaces in fields containing single quotes.
      It is solvable, and might be solved in a future version of this macro.

   Since these problems rarely occur in practice (well, my practice),
   this macro is normally very useful.

   Caveat:
      The macro depends on the sql format as generated by Toad. For instance,
      it expects a blank line between tables, and a ";" at the end of each
      insert statement.

   Thanks:
      To Sammy Mitchell. I used a slightly modified version of his integer
      array solution, as published on his web-page on Semware's web-site.
      It is included as "IntArray.si".

   Installation and use:
      Copy this file and "IntArray.si" to TSE's "mac" directory,
      and compile only this macro, not the "IntArray.si" file.
      Load an "insert script" into TSE, and execute this macro: there are no
      parameters.
*/

#define SPACE 32

integer array_id          = 0
integer formatted_line_id = 0
integer parenthesis_level = 0

#include ["intarray.si"]

integer proc create_formatted_line()
   integer result = 0
   PushPosition()
   result = CreateTempBuffer()
   PopPosition()
   return(result)
end

proc init_formatted_line(integer formatted_line_id)
   PushPosition()
   GotoBufferId(formatted_line_id)
   EmptyBuffer()
   PopPosition()
end

proc add_to_formatted_line(integer formatted_line_id, string text)
   Set(RemoveTrailingWhite, OFF)
   PushPosition()
   GotoBufferId(formatted_line_id)
   EndLine()
   InsertText(text)
   if text in ",", ")"
      EndLine()
      InsertText(" ")
   endif
   if text == ";"
      Left(2)
      if CurrChar() == SPACE
         DelChar()
      endif
   endif
   PopPosition()
   Set(RemoveTrailingWhite, ON)
end

proc replace_line_by_formatted_line(integer formatted_line_id)
   PushBlock()
   UnMarkBlock()
   PushPosition()
   GotoBufferId(formatted_line_id)
   MarkColumn(1, 1, 1, CurrLineLen())
   Copy()
   PopPosition()
   BegLine()
   KillToEol()
   Paste()
   UnMarkBlock()
   EndLine()
   PopBlock()
end

proc delete_formatted_line(integer formatted_line_id)
   AbandonFile(formatted_line_id)
end

string proc get_column()
   string result [255] = ""
   string quote    [1] = ""
   string char     [1] = ""
   while CurrChar() == SPACE
      Right()
   endwhile
   if CurrChar() <> _AT_EOL_
      char = Chr(CurrChar())
      if char in ",", "(", ")"
         result = char
         Right()
         if char == "("
            parenthesis_level = parenthesis_level + 1
         else
            if char == ")"
               parenthesis_level = parenthesis_level - 1
            endif
         endif
      else
         if char in "'", '"'
            quote  = char
            result = char
            Right()
            char = Chr(CurrChar())
            while char       <> quote
            and   CurrChar() <> _AT_EOL_
               result = result + char
               Right()
               char = Chr(CurrChar())
            endwhile
            if char == quote
               result = result + char
               Right()
            endif
         else
            quote  = ""
            result = char
            Right()
            char = Chr(CurrChar())
            while (char      <> "," or parenthesis_level > 1)
            and   (char      <> "(" or parenthesis_level > 0)
            and   (char      <> ")" or parenthesis_level > 1)
            and   CurrChar() <> _AT_EOL_
               if char == "("
                  parenthesis_level = parenthesis_level + 1
               else
                  if char == ")"
                     parenthesis_level = parenthesis_level - 1
                  endif
               endif
               result = result + char
               Right()
               char = Chr(CurrChar())
            endwhile
         endif
      endif
   endif
   return(result)
end

proc format_block()
   string  column  [255] = ""
   integer column_length = 0
   integer index         = 0
   // Determine the max length per column.
   if GetIntArrayNumItems(array_id) > 0
      FillIntArray(array_id, GetIntArrayNumItems(array_id), 0)
   endif
   GotoBlockBegin()
   repeat
      BegLine()
      parenthesis_level = 0
      index             = 1
      column            = get_column()
      column_length     = Length(column)
      while column_length > 0
         if column_length > GetIntArray(array_id, index)
            SetIntArray(array_id, index, column_length)
         endif
         index         = index + 1
         column        = get_column()
         column_length = Length(column)
      endwhile
   until index == 85
      or not Down()
      or not isCursorInBlock()
   // Now justify the columns in each line to those maximum lengths.
   GotoBlockBegin()
   repeat
      init_formatted_line(formatted_line_id)
      BegLine()
      parenthesis_level = 0
      index             = 1
      column            = get_column()
      column_length     = Length(column)
      while column_length > 0
         if column [1] in "0" .. "9"
            column = Format(column:GetIntArray(array_id, index))
         else
            column = Format(column:GetIntArray(array_id, index) * -1)
         endif
         add_to_formatted_line(formatted_line_id, column)
         index         = index + 1
         column        = get_column()
         column_length = Length(column)
      endwhile
      replace_line_by_formatted_line(formatted_line_id)
   until not Down()
      or not isCursorInBlock()
end

proc sql_statement_oneliner()
   // Currently only for insert statements.
   integer errors = FALSE
   integer old_linelen1 = 0
   integer old_linelen2 = 0
   integer old_break = Set(break, ON)
   integer old_rtw = Set(RemoveTrailingWhite, ON)
   BegFile()
   Down()
   repeat
      if PosFirstNonWhite() > 0
         old_linelen2 = CurrLineLen()
         Up()
         if  lFind("^insert into ", "cgix")
         and CurrChar(CurrLineLen()) <> Asc(";")
            old_linelen1 = CurrLineLen()
            if old_linelen1 + old_linelen2 + 1 > MAXLINELEN
               errors = TRUE
               Down()
            else
               EndLine()
               JoinLine()
               if CurrChar() <> Asc(",")
                  InsertText(" ", _INSERT_)
               endif
            endif
         else
            Down()
         endif
      endif
   until not Down()
   if errors
      Alarm()
      UpdateDisplay()
      Warn("Some lines were not joined for being too long")
   endif
   Set(RemoveTrailingWhite, old_rtw)
   Set(break, old_break)
end

proc Main()
   integer line_from = 0
   integer line_to   = 0
   integer old_rtw = Set(RemoveTrailingWhite, ON)
   Message("Working ... ")
   PushPosition()
   PushBlock()
   sql_statement_oneliner()
   array_id          = CreateIntArray()
   formatted_line_id = create_formatted_line()
   BegFile()
   repeat
      if PosFirstNonWhite() <> 0
         line_from = CurrLine()
         repeat
         until not Down()
            or PosFirstNonWhite() == 0
         if PosFirstNonWhite() == 0
            Up()
         endif
         line_to = CurrLine()
         MarkLine(line_from, line_to)
         format_block()
      endif
   until not Down()
   // Pacify compiler:
   line_from = InsertIntArray(array_id, 1, 0)
   line_from = DeleteIntArrayItem(array_id, 1)
   // End pacify compiler.
   DeleteIntArray(array_id)
   delete_formatted_line(formatted_line_id)
   Set(RemoveTrailingWhite, old_rtw)
   PopPosition()
   PopBlock()
   PurgeMacro("oSqlFmt")
   Message("Done")
end

