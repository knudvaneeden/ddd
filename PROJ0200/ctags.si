// MASTER FILE: ["proj.si"]
//#pragma inhouse,chrisant

// CTAGS.SI ---------------------------------------------------------------
// - exuberant ctags support for PROJ macro
// - BSC information support for PROJ macro

/*	CTAGS:

	Tag file should be generated with:
	ctags --excmd=p *.c

	//$ todo: CTags settings for project: extensions, ignore strings
	//$ todo: way to specify which paths/files to generate tags from.
	//$ todo: way to generate tags in the background.

	//$ todo: ADVANCED: write individual tags files for each directory,
	// concatenate them into one project-wide tags file; this should allow us
	// to refresh one directory's tags w/o refreshing tags for all directories
	// in the project (but we would still have to re-concatenate the
	// project-wide tags file).
	//$ todo: ADVANCED: simply recurse all dirs in the project looking for
	// "tags" file, load them all into memory in the DLL, and do an n-way
	// merge of sorted lists?

	//---------------------------------------------------------------------
	//done: per-directory/whole-project
*/


/*	BSC:

	Browse file must be generated by MSVC6.
	Requires MSVCRT.DLL and MSBSC60.DLL for operation.

*/



// #include "dosflag.si" // old [kn, ri, sa, 10-12-2022 22:11:19]
#include [ "dosflag.si" ] // new [kn, ri, sa, 10-12-2022 22:11:23]



#define CTAGS_ENABLE_IGNORE 1



forward proc GenerateTags()
forward proc Prompt_AfterCommand_Tags()
forward proc Prompt_DelayedMatch_Tags()



#ifdef CTAGS
#ifdef CTAGS_ENABLE_IGNORE
datadef dataIgnore
// CTags 1.7.3 has some parsing problems which we try to work around
"STDMETHOD"
"STDMETHODIMP"
"STDMETHODIMP_"
"STDMETHODIMPV_"
"STDAPI"
"STDAPI_"
"STDAPIV_"
"STDAPIIMP"
"STDAPIIMP_"
"STDAPIIMPV_"

// Microsoft Office
"MSOAPI"
"MSOAPI_"
"MSOAPIX_"
"MSOAPIMX_"
"MSOAPIXX_"

// Outlook
"DeclareGenericArrayBegin"
"DeclareGenericArrayAccessors"
"DeclareGenericArrayContructDestruct"
"DeclareGenericArrayDebug"
"DeclareGenericArrayEnd"
end
#endif


string c_stOtherTags[] = "[OtherTagFiles]"



///////////////////////////////////////////////////////////////////////////
// Extract Function Name from text

// mMatch
// matches (){}[]<> chars.
// NOTE:  gets confused by (){}[]<> inside of quotes
string match_chars[] = "(){}[]<>"   // pairs of chars to match
integer proc mMatch()
	integer p, level
	integer mc, ch
	integer start_line = CurrLine(), start_row = CurrRow()

	p = Pos(chr(CurrChar()), match_chars)
	// If we're not already on a match char, go forward to find one
	if p == 0 and lFind("[(){}[\]<>]", "x")
		ScrollToRow(CurrLine() - start_line + start_row)
		return (FALSE)
	endif

	PushPosition()
	if p
		ch = asc(match_chars[p])		// Get the character we're matching
		mc = asc(match_chars[iif(p&1, p+1, p-1)])	// And its reverse
		level = 1						// Start out at level 1

		while lFind("[\" + chr(ch) + "\" + chr(mc) + "]", iif(p & 1, "x+", "xb"))
			case CurrChar()				// And check out the current character
				when ch
					level = level + 1
				when mc
					level = level - 1
					if level == 0
						KillPosition()			// Found a match, remove position
						GotoXoffset(0)			// Fix up possible horizontal scrolling
						ScrollToRow(CurrLine() - start_line + start_row)
						return (TRUE)			// And return success
					endif
			endcase
		endwhile
	endif
	PopPosition()						// Restore position
	return (FALSE)
end


// IsSupportedFileType()
// used by GetFunctionName to decide whether to look for a function name
integer proc IsSupportedFileType(string ext)
	return (Length(ext) and
			Pos(ext+".", ".c.cpp.cxx.cc.s.si.ui.asm.inc.pas.prg.bas.ini."))
end


// GetFunctionStr()
// gets regex search string based on file type, returns index of token that
// represents function name in search string, or returns -1 if the search
// string does not contain such a token.
integer proc GetFunctionStr(string ext, var string expr)
	integer i = 0

	// get search expression for functions
	expr = ""
	case ext
//		when ".c"
//			expr = "^_@[a-zA-Z][a-zA-Z0-9_* \t]@([~;]*$"

		when ".c",".cpp",".cc",".h",".hpp",".cxx",".hxx"
			//expr = "^_|~@[a-zA-Z:~][a-zA-Z0-9_* \t:~]@([~;]*$"
			// modified to catch functions with parens on next line
			//expr = "^_|~@[a-zA-Z:~][a-zA-Z0-9_* \t:~]@{([~;]*$}|{$}"

			//$ loose - modified by Howard Kapustein to catch more C++ stuff
			//expr = "^{extern[ \t]+\x22C\x22[ \t]+}?_|~@[a-zA-Z:][a-zA-Z0-9_+\-*/%^&|~!=<>,\[\] \t:~]@([~;]*$"

			//$ tight - chrisant
			//expr = "^{[~ \t]*[ \t]*}?[a-zA-Z_~][a-zA-Z0-9_* \t~]@{::[a-zA-Z_~][a-zA-Z0-9_* \t~]@}?{[~=;/]*([~;:/]@}|{[~=;:/]@}{//.@}?$"
			expr = "{^STDMETHOD.*(.+)[ \t]+}|{^{[~ \t]*[ \t]*}?[a-zA-Z_~][a-zA-Z0-9_* \t~]@{::[a-zA-Z_~][a-zA-Z0-9_* \t~]@}?{[~=;/]*([~;:/]@}|{[~=;:/]@}{//.@}?$}"
			i = -1

		when ".s",".ui",".si"
			//expr = "^[ \t]*{menu}|{keydef}|{datadef}|{helpdef}|{{public #}?{{integer #}|{string #}}?proc} +[a-zA-Z_]"
			expr = "^[\t ]*{menu}|{keydef}|{datadef}|{{public[\t ]#}?{{integer}|{string}[\t ]#}?proc}[\t ]+\c[a-zA-Z_]"
			i = -1

		when ".asm",".inc"
			expr = "^{{proc}|{macro}[\t ]+\c[A_Za-z_0-9]#}|{\c[A-Za-z_0-9]#[\t ]+{proc}|{macro}}"
			i = -1

		when ".pas"
			expr = "{procedure}|{function}[\t ]+{[A-Za-z_0-9]#}"
			i = 3

		when ".prg",".spr",".mpr",".qpr",".fmt",".frg",".lbg",".ch"
			expr = "^{static[\t ]+}?{{procedure}|{function}}[\t ]+{[A-Za-z_0-9]#}"
			i = 5

		when ".bas"
			expr = "^{[\t ]@def fn}|{[\t ]@sub}[\t ]+{[A-Za-z_0-9]#}"
			i = 3

		when ".ini"
			expr = "\[.*\]"
			i = 0
	endcase

	return (i)
end


proc FindBlankLine(integer dir)
	while iif(dir, Down(), Up()) and PosFirstNonWhite()
	endwhile
end


proc FindNonBlankLine(integer dir)
	while iif(dir, Down(), Up()) and not PosFirstNonWhite()
	endwhile
end


// FindFunc()
// find next/prev function beginning.  for performance reasons, it sets a 1000
// line range to search in.
integer proc FindFunc(integer next)
	string opt[1], s[255] = ""
	integer fRet = FALSE

	GetFunctionStr(CurrExt(), s)
	if Length(s)
		PushPosition()

		if not next
			BegLine()
			opt = 'b'
		else
			EndLine()
			opt = ''
		endif

		PushBlock()
		MarkLine(CurrLine(), iif(next, CurrLine()+1000, CurrLine()-1000))
		fRet = lFind(s, "ilx+" + opt)
		PopBlock()

		if fRet
			KillPosition()
		else
			PopPosition()
		endif
	endif
	return (fRet)
end


// mBegFunc()
// find beginning of function
proc mBegFunc()
	integer row = CurrRow(), cline = CurrLine()
	integer pline

	FindFunc(FALSE)
	pline = CurrLine()
	FindFunc(TRUE)
	if cline <> CurrLine()
		GotoLine(pline)
	endif

	// hold screen still unless we went off screen
	row = row + CurrLine() - cline
	if row < 1 or row > Query(WindowRows)
		ScrollToRow(Query(WindowRows)/5)
	else
		ScrollToRow(row)
	endif
end


// mEndFunc()
// find end of function
proc mEndFunc()
	integer row = CurrRow(), cline = CurrLine()
	string s[255] = ""
	integer fFound = FALSE

	PushPosition()
	GetFunctionStr(CurrExt(), s)

	if not FindFunc(TRUE)
		EndFile()
		repeat until CurrLine() <= cline or PosFirstNonWhite() or not Up()
	endif

	if Length(s)
		FindFunc(FALSE)
		BegLine()
		if Pos(CurrExt()+".", ".s.si.ui.inc.")
			fFound = lFind("proc", "wi") and lFind("[ \t]*end", "^xiw")
		elseif Pos(CurrExt()+".", ".asm.inc.")
			fFound = lFind("{proc}|{macro}", "wi") and
					lFind("[A-Za-z_0-9]*[ \t]*{endp}|{endm}", "^xiw")
		elseif Pos(CurrExt()+".", ".c.h.cc.cpp.hpp.cxx.hxx.")
			fFound = lFind("{", "") and mMatch()
		else
			fFound = TRUE				// perhaps a bit optimistic, no?
			FindBlankLine(FALSE)
			FindNonBlankLine(FALSE)
		endif
	endif

	if fFound
		KillPosition()
	else
		PopPosition()
	endif

	// hold screen still unless we went off screen
	row = row + CurrLine() - cline
	if row < 1 or row > Query(WindowRows)
		ScrollToRow((Query(WindowRows)*4)/5)
	else
		ScrollToRow(row)
	endif
end


// GetFunctionName()
// returns name of function.  it does a decent job, but don't expect miracles!
string proc GetFunctionName()
	string expr[255] = ""
	string ws[32]
	integer i = CurrLine()

	PushPosition()

	// check if we support this file type
	if not IsSupportedFileType(CurrExt())
		// not a supported file extension
		goto Out
	endif

	// is the line in a function?
	mEndFunc()
	if CurrLine() < i
		goto Out
	endif
	mBegFunc()
	if CurrLine() > i
		goto Out
	endif

	// line is in a function; get name of function
	i = GetFunctionStr(CurrExt(), expr)
	if Length(expr)
		if lFind(expr, "gxc")
			if i == -1
				// special methods for extracting function names
				case CurrExt()
					// C/C++ is darn complicated
					when ".c",".cpp",".cc",".h",".hpp",".cxx",".hxx"
						EndLine()
						lFind("//", "bc")
						ws = Set(WordSet, ChrSet("A-Za-z_0-9:"))
						// take the word before the last parenthesis, or the
						// last word on the line.
						lFind("(", "bc")
						WordLeft()
						expr = GetWord()
						Set(WordSet, ws)

					// cursor is placed at beginning of function name
					when ".s",".ui",".si",
							".asm",".inc"
						if lFind("[A-Za-z_0-9]#", "xc")
							expr = GetFoundText()
						endif
				endcase
			else
				expr = GetFoundText(i)
			endif
		else
			expr = ""
		endif
	endif

Out:
	PopPosition()
	return(expr)
end



///////////////////////////////////////////////////////////////////////////
// Context Window

#define CWBORDER 1
#define DBLCLK_TIME 5

constant BSC_INFO	= 0
constant BSC_INST	= 1
constant BSC_DEF	= 2
constant BSC_REF	= 3


integer dblclk_tick = 0

constant pctCtxWin = 30					// percentage of screen to use for context window
constant nIdleMS = 1					// idle milliseconds before update context window

integer g_nCtxLine = 0
integer cyCtxWin = 0

integer g_bscSelectType

integer g_idSaveWindow = 0


#if 0
proc RestoreWindow()
	integer cid
	integer x1, y1, cols, rows
	integer i, j, k, l
	string s[255], a[255]

	if not g_idSaveWindow
		return()
	endif

	cid = GotoBufferId(g_idSaveWindow)
	if cid
		BegFile()
		x1 = Val(GetToken(GetText(1, 255), " ", 1))
		y1 = Val(GetToken(GetText(1, 255), " ", 2))
		cols = Val(GetToken(GetText(1, 255), " ", 3))
		rows = Val(GetToken(GetText(1, 255), " ", 4))
		KillLine()
		EndFile()

		i = Query(PopWinX1)
		j = Query(PopWinY1)
		k = Query(PopWinCols)
		l = Query(PopWinRows)
		Window(1, 1, Query(ScreenCols), Query(ScreenRows))

		while rows
			rows = rows - 1
			a = GetText(1, cols)
			Up()
			s = GetText(1, cols)
			Up()
			VGotoXYAbs(x1, y1+rows)
			PutStrAttr(s, a)
		endwhile

		Window(i, j, i+k-1, j+l-1)

		GotoBufferId(cid)
		AbandonFile(g_idSaveWindow)
	endif
	g_idSaveWindow = 0
end


integer proc SaveWindow(integer x1, integer y1, integer cols, integer rows)
	integer cid = GetBufferId()
	integer i
	string s[255] = ""
	string a[255] = ""

	if not g_idSaveWindow
		g_idSaveWindow = CreateTempBuffer()
		if g_idSaveWindow
			BegFile()
			for i = 1 to rows
				VGotoXYAbs(x1, y1+i-1)
				if GetStrAttr(s, a, cols)
					AddLine(s)
					AddLine(a)
				else
					// error: clean up and abort
					GotoBufferId(cid)
					AbandonFile(g_idSaveWindow)
					g_idSaveWindow = 0
					goto error_saving_window
				endif
			endfor
			BegFile()
			InsertLine(Format(x1; y1; cols; rows))
			GotoBufferId(cid)
		else
			error_saving_window:
			Warn("error saving window")
		endif
	endif

	return(g_idSaveWindow)
end
#endif


proc SetWindow(integer x1, integer y1, integer cols, integer rows)
#ifdef CWBORDER
	Window(x1+1, y1+1, x1+cols-2, y1+rows-2)
#else
	Window(x1, y1+1, x1+cols-1, y1+rows-1)
#endif
end


#ifdef CWBORDER
proc DrawWindow(integer x1, integer y1, integer cols, integer rows,
		integer boxtype, string path, integer attr, integer line, string func)
#else
proc DrawWindow(integer x1, integer y1, integer cols, integer rows,
		string path, integer attr, integer line, string func)
#endif

	if not g_idSaveWindow
		g_idSaveWindow = SaveWindow(x1, y1, cols, rows)
	endif
	BufferVideo()

	Window(x1, y1, x1+cols-1, y1+rows-1)

	Set(Attr, attr)
#ifdef CWBORDER
	DrawBox(boxtype, attr)
	Set(Attr, Query(StatusLineAttr))
	if Length(path)
		VGotoXY(Query(ScreenCols)/2, 1)
		PutStr(" "+SqueezePath(path, Query(ScreenCols)/2-6)+" ")
	endif
	if line
		// line number indicator
		VGotoXY(2, 1)
		PutStr(" L "+Str(line)+" ")
	endif
	if Length(func)
		// function name
		VGotoXY(13, 1)
		PutStr(" "+Ellipsify(func, Query(ScreenCols)/2-13-2)+" ")
	endif
#else
	VGotoXY(1, 1)
	ClrEol()
	VGotoXY(35, 1)
	PutStr(path)
	if line
		// line number indicator
		VGotoXY(1, 1)
		PutStr("L "+Str(line))
	endif
	if Length(func)
		// function name
		VGotoXY(11, 1)
		PutStr(Ellipsify(func, 35-11-1), Query(HiliteAttr))
	endif
#endif
	SetWindow(x1, y1, cols, rows)

	UnBufferVideo()
end


integer g_fCloseWhenDone = TRUE
integer g_idContextFile = 0
integer g_nRowOfs = 0
integer g_nRowOfsFresh = 0
integer g_nRowOfsPrev = 0
proc NonEditIdle_BSC()
	integer a, b, c, d
	integer ln
	string path[255]
	string tmp[255]
	string func[80]
	integer cid
	integer i
	integer tw
	integer p
	integer rowofsprev = g_nRowOfsPrev
	integer fLnOK = FALSE
	integer x, y
	integer fFileError = FALSE

	if g_nCtxLine <> CurrLine() or g_nRowOfs <> g_nRowOfsPrev
		if g_nCtxLine <> CurrLine()
			fLnOK = TRUE
			#ifdef CWBORDER
			g_nRowOfs = -(cyCtxWin-2)/3
			#else
			g_nRowOfs = -cyCtxWin/3
			#endif
			g_nRowOfsFresh = g_nRowOfs
		endif
		g_nRowOfsPrev = g_nRowOfs

		// get line number and filename
		case g_bscSelectType
			when BSC_DEF
				path = GetDef(CurrLine(), ln)
			when BSC_REF
				path = GetRef(CurrLine(), ln)
			otherwise
				UnHook(NonEditIdle_BSC)
				return()
		endcase
		tmp = GetFilePath(path)
		if tmp == "*"
			path = tmp
			fFileError = TRUE
		endif

		// make sure idle or file already loaded
		if Query(IdleTime) < nIdleMS and not fFileError and not GetBufferId(path)
			return()
		endif

		// ok, we'll do it
		UnHook(NonEditIdle_BSC)
		g_nCtxLine = iif(fFileError, 0, CurrLine())

		// open file
		cid = GetBufferId()
		if not fFileError
			if GetBufferId(path)
				// file already open in a buffer
				if g_fCloseWhenDone and g_idContextFile
					if GetBufferId(path) <> g_idContextFile
						AbandonFile(g_idContextFile)
						g_fCloseWhenDone = FALSE
					endif
				else
					g_fCloseWhenDone = FALSE
				endif
				g_idContextFile = GetBufferId(path)
				GotoBufferId(g_idContextFile)
			else
				// open file
				if not CreateBuffer(path, _HIDDEN_)
					fFileError = TRUE
					goto LOpenError
				endif
				PushBlock()
				if not InsertFile(path, _DONT_PROMPT_)
					PopBlock()
					AbandonFile()
					GotoBufferId(cid)
					fFileError = TRUE
					goto LOpenError
				endif
				PopBlock()
				if g_fCloseWhenDone and g_idContextFile
					AbandonFile(g_idContextFile)
				endif
				g_fCloseWhenDone = TRUE
				g_idContextFile = GetBufferId()
			endif

			// verify row offset is within bounds
			if ln + g_nRowOfs < 1
				g_nRowOfs = 1 - ln
			elseif ln + g_nRowOfs > NumLines()
				g_nRowOfs = NumLines() - ln
			endif
			g_nRowOfsPrev = g_nRowOfs
			if not fLnOK and rowofsprev == g_nRowOfs
				// don't abandon file
				GotoBufferId(cid)
				return()
#if 0
				fFileError = TRUE
				goto LOpenError
#endif
			endif

			// go to line
			PushPosition()
			GotoLine(ln)
		endif

LOpenError:
		// remember current window coordinates
		a = Query(PopWinX1)
		b = Query(PopWinY1)
		c = Query(PopWinCols)
		d = Query(PopWinRows)

		BufferVideo()

		if fLnOK
			if not fFileError
				// get function name
				func = GetFunctionName()
			endif

			// draw context window
			#ifdef CWBORDER
			DrawWindow(1, Query(ScreenRows)-cyCtxWin+1,
					Query(ScreenCols), cyCtxWin,
					//Query(CurrWinBorderType), path,
					1, path,
					Query(CurrWinBorderAttr), ln, func)
			#else
			DrawWindow(1, Query(ScreenRows)-cyCtxWin+1,
					Query(ScreenCols), cyCtxWin,
					path, Query(StatusLineAttr), ln, func)
			#endif
		else
			SetWindow(1, Query(ScreenRows)-cyCtxWin+1,
					Query(ScreenCols), cyCtxWin)
		endif

		Set(Attr, Query(MsgAttr))
		ClrScr()

		if fFileError
			VGotoXY(1, 1)
			if path == ""
				PutLine("File not found.", Query(PopWinCols))
			elseif path == "*"
				PutLine("Ambiguous filename.", Query(PopWinCols))
			else
				PutLine("Unexpected error.", Query(PopWinCols))
			endif
		else
			// get lines and draw them
			BegLine()
			GotoLine(ln + g_nRowOfs)
			for i = 1 to Query(PopWinRows)
				if ln == CurrLine()
					Set(Attr, Query(HiLiteAttr))
				else
					Set(Attr, Query(MsgAttr))
				endif
				VGotoXY(1, i)
				path = GetText(1, 255)
				if Query(ExpandTabs)
					// expand tabs
					//$ review: (chrisant) or could preserve current line, use
					// ExpandTabsToSpaces(), get line, restore line.
					tw = Query(TabWidth)
					loop
						p = Pos(Chr(9), path)
						if not p
							break
						endif
						path = Format(SubStr(path, 1, p-1):-(p-1+tw-((p-1) mod tw)):" ", DelStr(path, 1, p))
					endloop
				endif
				PutLine(path, Query(PopWinCols))
				if not Down()
					break
				endif
			endfor
		endif

		#ifdef CWBORDER
		// draw indicators
		i = Query(PopWinRows)
		x = Query(PopWinX1) + Query(PopWinCols)
		y = Query(PopWinY1)
		Window(1, 1, Query(ScreenCols), Query(ScreenRows))

		// draw indicator to show what line we'll jump to if user hits <Enter>
		Set(Attr, Query(CurrWinBorderAttr))
		VGotoXYAbs(1, y)
		PutOemCharV("³", i)
		VGotoXYAbs(1, y - g_nRowOfsFresh)
		PutOemChar("")

		// draw "percentage meter"...

		// draw bar
		Set(Attr, Query(CurrWinBorderAttr))
		VGotoXYAbs(x, y)
		//PutCharV("°", i)
		PutOemCharV("³", i)

		if not fFileError
			// draw thumb button
			Set(Attr, Query(StatusLineAttr))
			VGotoXYAbs(x, y - 1 + iif(NumLines() <= i, 1,
					(min(1 + ((ln+g_nRowOfs)*i-1) / (NumLines() - (i + 1)), i))))
			//PutChar(iif(fDragging, "", "Û"))
			//PutChar("Û")
			PutOemChar("þ")
		endif
		#else
		// shut up the compiler
		x = 1
		y = 1
		x = x
		y = y
		#endif

		UnBufferVideo()

		// reset window coordinates
		Window(a, b, a+c-1, b+d-1)

		// cleanup
		if not fFileError
			PopPosition()
		endif
		GotoBufferId(cid)
	endif
end


proc AfterNonEditCommand_BSC()
	Hook(_NONEDIT_IDLE_, NonEditIdle_BSC)
end


proc ScrollContext(integer fDown)
	if fDown
		g_nRowOfs = g_nRowOfs - 1
	else
		g_nRowOfs = g_nRowOfs + 1
	endif
	NonEditIdle_BSC()
end


proc ListLeftBtn()
	if Query(MouseY) > Query(WindowY1) + Query(WindowRows)
		EndProcess(TRUE)
	else
		case MouseHotSpot()
			when _MOUSE_MARKING_
				PushPosition()
				GotoMouseCursor()
				if Query(MouseY) == Query(WindowY1) + CurrRow() - 1
					UpdateDisplay()
					KillPosition()
					if dblclk_tick and Query(LastMouseX) == Query(MouseX) and
							Query(LastMouseY) == Query(MouseY)
						if Abs(GetClockTicks() - dblclk_tick) <= DBLCLK_TIME
							EndProcess(TRUE)
						endif
						dblclk_tick = 0
					else
						dblclk_tick = GetClockTicks()
					endif
				else
					PopPosition()
				endif
			otherwise
				ProcessHotSpot()
		endcase
	endif
end


keydef ListKeys_BSC
<Ctrl Enter>			EndProcess(1)			// same as <Enter>
<Alt L>					EndProcess(2)			// load all files
<Alt E>					EndProcess(3)			// copy list to a new buffer
//<F1>					mHelp("Grep List")
<Ctrl CursorUp>			ScrollContext(TRUE)
<Ctrl CursorDown>		ScrollContext(FALSE)
<LeftBtn>				ListLeftBtn()
end


// buffer to clean up after, otherwise we'd clean up after every list window
// that came up, even windows from GETHELP.MAC.
integer idCleanup = 0

proc ListCleanup_BSC()
	if GetBufferId() == idCleanup
		// let go of cached context file
		if g_fCloseWhenDone and g_idContextFile
			AbandonFile(g_idContextFile)
		endif
		UnHook(NonEditIdle_BSC)
		UnHook(AfterNonEditCommand_BSC)
		RestoreWindow(g_idSaveWindow)
		UpdateDisplay(_ALL_WINDOWS_REFRESH_)

		UnHook(ListCleanup_BSC)
	endif
end


proc ListStartup_BSC()
	integer a, b, c, d

	Unhook(ListStartup_BSC)

	idCleanup = GetBufferId()
	Hook(_LIST_CLEANUP_, ListCleanup_BSC)
	Enable(ListKeys_BSC)
	ListFooter(" {Alt E}-Edit list  {Alt L}-Goto all ")

	g_nCtxLine = 0
	Hook(_AFTER_NONEDIT_COMMAND_, AfterNonEditCommand_BSC)
	AfterNonEditCommand_BSC()
	// remember current window coordinates
	a = Query(PopWinX1)
	b = Query(PopWinY1)
	c = Query(PopWinCols)
	d = Query(PopWinRows)
	#ifdef CWBORDER
	DrawWindow(1, Query(ScreenRows)-cyCtxWin+1,
			Query(ScreenCols), cyCtxWin, Query(CurrWinBorderType),
			"", Query(CurrWinBorderAttr), 0, "")
	#else
	DrawWindow(1, Query(ScreenRows)-cyCtxWin+1,
			Query(ScreenCols), cyCtxWin,
			"", Query(StatusLineAttr), 0, "")
	#endif
	Set(Attr, Query(MsgAttr))
	ClrScr()
	// reset window coordinates
	Window(a, b, a+c-1, b+d-1)

	BreakHookChain()
end



///////////////////////////////////////////////////////////////////////////
// Tags Stuff

#if 0
// RegExTagStr()
// returns string with regular expression operator chars escaped so it can be
// used as part of a regex string -- except ^ and $ and \ (used by ctags).
string proc RegExTagStr(string st)
	integer i, j
	integer n = Length(st)
	string stRet[255] = ""

	j = 1
	for i = 1 to n
		// escape regex chars
		if Pos(st[i], "[]{}.*+@#|?")
			if j + 1 >= sizeof(stRet)
				// avoid escape char being last char in string
				break
			endif
			stRet[j] = '\'
			j = j + 1
		endif
		stRet[j] = st[i]
		j = j + 1
	endfor
	return(stRet)
end
#endif


string proc GetTagFilename()
#ifdef DEBUG
	Assert(Length(CurrFilename()), "GetTagFilename: CurrFilename() is empty")
	Assert(BufferType() == _NORMAL_, "GetTagFilename: BufferType() != _NORMAL_")
#endif

	if Get_Int(iFProjectTags)
		if not Length(Get_Str(iTagFile))
			if Length(Get_Str(iTagsLocation))
				Set_Str(iTagFile, AddTrailingSlash(SplitPath(Get_Str(iTagsLocation), _DRIVE_|_NAME_)) + "tags")
			else
				Set_Str(iTagFile, SplitPath(Get_Str(iProjectFilename), _DRIVE_|_NAME_) + c_stExtTag)
			endif
		endif
	else
		Set_Str(iTagFile, SplitPath(CurrFilename(), _DRIVE_|_PATH_) + "tags")
	endif
	return (Get_Str(iTagFile))
end


proc FreeAllTags()
	// release any tags files we're currently holding on to
	//$ todo: not very friendly...
	Tags_FreeAll()
	Set_Str(iTagFile, "")
	if not Get_Int(iProjectId)
		Set_Int(iFProjectTags, FALSE)
	endif
end


integer proc LoadTags(string stTitle, string stFile, integer fReload)
	integer n

#ifdef DEBUG
	Assert(Length(stTitle), "LoadTags: no title")
	Assert(Length(stFile), "LoadTags: no filename")
#endif

	if fReload
		Tags_FreeFile(stFile)
	endif

Retry:
	if Tags_Load(stFile, FALSE) < 0
		Message("Loading tags for"; stTitle, "...")

		// load tags file
		n = Tags_Load(stFile, TRUE)

		UpdateDisplay(_STATUSLINE_REFRESH_)

		case n
			when loadError, loadInProgress
				Warn(c_errLoadingTags)

			when loadNotFound
				if stFile == Get_Str(iTagFile)
					if MsgBox(c_stTitle, "Can't find tag file "+stFile+". "+
							  "Do you want to generate tags now?", _YES_NO_) == YES
						GenerateTags()
						goto Retry
					endif
				else
					Warn("Can't find tag file "+stFile+".")
				endif

			when loadBadFormat
				Warn(c_errBadTagFormat)

			when loadUnsorted
				Warn(c_errUnsortedTagFile)

			otherwise
				return (TRUE)
		endcase

		return (FALSE)
	endif

	return (TRUE)
end


proc SelectTagFile()
	integer cid = GetBufferId()
	integer id
	integer n
	string st[255]
	string stFile[255]

	id = CreateTempBuffer()
	if id and GotoBufferId(Get_Int(iProjectId))
		if MarkProjectSection(c_stOtherTags)
			GotoBufferId(id)
			CopyBlock()
		endif
		GotoBufferId(id)
		BegFile()
		InsertLine(Get_Str(iProjectTitle) + c_stDiv + Get_Str(iTagFile))
		if Tags_FLoaded()
			lFind(c_stDiv + Tags_CurrentTagFile(), "gi$")
		endif

		n = DoMenu("Select tags file")
		st = GetText(1, CurrLineLen())
		GotoBufferId(cid)
		if n
			stFile = GetToken(st, c_stDiv, 2)
			ExpandEnvVars(stFile)
			LoadTags(GetToken(st, c_stDiv, 1), stFile, FALSE)
		endif
	endif
	GotoBufferId(cid)
	AbandonFile(id)
end
#endif


integer g_fShowHelpLine
proc DrawMatchLine(integer fCursorLine)
	integer iIndex = Val(GetText(1, 20))
	integer type = Tags_GetType(iIndex)
	//integer i, j, k, l

	PutLine(CapToken(SplitPath(Tags_GetFilename(iIndex), _NAME_|_EXT_)), 16)
	#ifdef TSE28
	PutLine(Chr(type)+" ", 2, iif(fCursorLine, Query(MenuSelectGrayAttr), Query(MenuGrayAttr)))
	#else
	PutLine(Chr(type)+" ", 2, (iif(fCursorLine, Query(MenuSelectAttr), Query(MenuTextAttr)) & 0xf0) + 0x07)
	#endif

	if Tags_GetLine(iIndex)
		PutLine(Format("line"; Tags_GetLine(iIndex)), Query(WindowCols) - VWhereX() + 1)
	else
		//$ todo: hard tabs are difficult to see
		PutLine(Tags_GetSearchLine(iIndex), Query(WindowCols) - VWhereX() + 1)
	endif

	if fCursorLine
		if g_fShowHelpLine
			//i = Query(PopWinX1)
			//j = Query(PopWinY1)
			//k = Query(PopWinCols)
			//l = Query(PopWinRows)

			Window(1, GetHelpLineRow(), Query(ScreenCols), GetHelpLineRow())
			PutLine(PrettyPath2(Tags_GetFilename(iIndex), Query(ScreenCols)),
					Query(ScreenCols), Query(HelpTextAttr))

			//Window(i, j, i+k-1, j+l-1)
			FullWindow()
		endif
	endif
end


proc ListStartup_Center()
	ScrollToRow(Query(PopWinRows)/3)
end


integer proc MatchMenu(string stTag, integer iStart)
	integer n = 0
	integer cid = GetBufferId()
	integer id = 0
	integer iIndex = iStart
	integer iDefault = iStart

	PushBlock()
	UnMarkBlock()
	id = CreateTempBuffer()
	GotoBufferId(cid)

	// find # of matches
	repeat
		if Tags_GetType(iIndex) == symClass and iDefault == -1
			iDefault = iIndex
		endif
		if id
			AddLine(Str(iIndex), id)
		endif

		n = n + 1
		iIndex = iIndex + 1
	until Tags_Lookup(stTag, iIndex, lookNext|lookExact) == -1
	iIndex = iDefault

	if id
		if n > 1
			// show menu
			Message(n; "matches found.")
			GotoBufferId(id)
			BegFile()
			lFind(Str(iDefault), "g^$")

			iIndex = -1
			g_fShowHelpLine = Query(ShowHelpLine)
			HookDisplay(DrawMatchLine,,, Hilite)
			Hook(_LIST_STARTUP_, ListStartup_Center)
			if lList(stTag, 78, 1000, _FIXED_WIDTH_|_PRESERVE_HELPLINE_)
				iIndex = Val(GetText(1, 20))
			endif
			UnHook(ListStartup_Center)
			UnHookDisplay()
		endif
	endif

	GotoBufferId(cid)
	AbandonFile(id)
	PopBlock()
	return (iIndex)
end


integer proc FindMatch_Tags(string st, integer iStart, integer ulFlags)
	return (Tags_Lookup(st, iStart, ulFlags))
end


proc ListMatches_Tags(integer mode)
	integer c = 0
	integer cRows
	integer i, j, k, l
	integer iIndex
	integer iPrev = -1
	integer ulFlags
	string st[48]
	string stHelpline[255] = ""
	integer attr = iif(g_iCurrent <> -1, Query(MsgAttr), Grayize(Query(MsgAttr)))

	#ifdef DEBUG
	Set(Break, ON)
	#endif

	i = Query(PopWinX1)
	j = Query(PopWinY1)
	k = Query(PopWinCols)
	l = Query(PopWinRows)

	Window(g_x1List, g_y1List, g_x2List, g_y2List)
	cRows = Query(PopWinRows)

	if mode <> lmPROGRESS
		if Tags_FLoaded()
			iIndex = iif(g_iTop == -1, 0, g_iTop)
			ulFlags = iif(g_iTop == -1, lookFirst, lookNext)
			iPrev = iIndex
			//BufferVideo()
			while c < cRows
				iIndex = FindMatch_Tags(g_stPrompt, iIndex, ulFlags)
				if iIndex == -1
					break
				endif

				ulFlags = lookNext
				c = c + 1

				//$ review: should this use Menu___Attr instead?
				VGotoXY(1, c)
				PutLine(Chr(Tags_GetType(iIndex))+"  "+Tags_GetSymbol(iIndex), 3,
						Grayize(iif(iIndex == g_iCurrent, Query(HiLiteAttr), attr)))
				PutLine(Tags_GetSymbol(iIndex), Query(PopWinCols)-3,
						iif(iIndex == g_iCurrent, Query(HiLiteAttr), attr))

				if iIndex == g_iCurrent
					if fShowHelpLine
						//stHelpline = PrettyPath2(Tags_GetFilename(iIndex), Query(ScreenCols)/4)
						if Tags_GetLine(iIndex)
							stHelpline = Format("line"; Tags_GetLine(iIndex) : -Query(ScreenCols) : " ")
						else
							stHelpline = Format(Tags_GetSearchLine(iIndex) : -Query(ScreenCols) : " ")
						endif
						st = "³  " + PrettyPath2(Tags_GetFilename(iIndex), 32)
						stHelpline = DelStr(stHelpline, Query(ScreenCols) - Length(st), 255)
						stHelpline = stHelpline + st
					endif
				endif

				iPrev = iIndex
				iIndex = iIndex + 1
			endwhile
			//UnBufferVideo()
		endif

		g_iBottom = iPrev
		g_rowBottom = c

		if c < cRows and (mode == lmINIT or Tags_FLoaded())
			Window(g_x1List, g_y1List+c, g_x2List, g_y2List)
			c = Set(Attr, attr)
			ClrScr()
			Set(Attr, c)
		endif

		if fShowHelpLine and (mode == lmINIT or Tags_FLoaded())
			Window(1, GetHelpLineRow(), Query(ScreenCols), GetHelpLineRow())
			//VHomeCursor()
			PutLine(stHelpline, Query(ScreenCols), Query(HelpTextAttr))
		endif
	endif

	Window(i, j, i+k-1, j+l-1)
end


proc Match_Tags(string st)
	g_iTop = -1
	g_rowCurrent = 0
	g_iCurrent = FindMatch_Tags(st, 0, lookFirst)
	if g_iCurrent <> -1
		g_iTop = g_iCurrent
		g_rowCurrent = 1
		g_stPrompt = st
	else
		g_stPrompt = ""
	endif
end


proc NextTag(integer flag)
	integer iTop = g_iTop
	integer iCurrent = g_iCurrent
	integer iIndex
	integer c, cRows = g_y2List - g_y1List + 1

	if g_iCurrent <> -1
		case flag
			when matchPREV
				iIndex = FindMatch_Tags(g_stPrompt, g_iCurrent-1, lookPrev)
				if iIndex <> -1
					g_iCurrent = iIndex
					if g_rowCurrent == 1
						g_iTop = iIndex
					else
						g_rowCurrent = g_rowCurrent - 1
					endif

					#ifdef DEBUG
					Assert(g_rowCurrent > 0, "probably forgot to initialize g_rowCurrent somewhere")
					#endif
				endif

			when matchNEXT
				iIndex = FindMatch_Tags(g_stPrompt, g_iCurrent+1, lookNext)
				if iIndex <> -1
					g_iCurrent = iIndex
					if g_rowCurrent == (g_y2List - g_y1List + 1)
						g_iTop = FindMatch_Tags(g_stPrompt, g_iTop+1, lookNext)
					else
						g_rowCurrent = g_rowCurrent + 1
					endif

					#ifdef DEBUG
					Assert(g_rowCurrent <= (g_y2List - g_y1List + 1), "how did g_rowCurrent become > number of rows?")
					#endif
				endif

			when matchTOP
				g_iCurrent = FindMatch_Tags(g_stPrompt, 0, lookFirst)
				g_iTop = g_iCurrent
				g_rowCurrent = 1

			when matchBOTTOM
				iIndex = FindMatch_Tags(g_stPrompt, FlatFile_GetCount()-1, lookLast)
				g_iCurrent = iIndex
				g_rowCurrent = 1

				if iIndex <> -1
					// set g_iTop
					c = cRows - 1
					g_iTop = iIndex
					while c
						iIndex = FindMatch_Tags(g_stPrompt, iIndex - 1, lookPrev)
						if iIndex == -1
							break
						endif
						g_iTop = iIndex
						g_rowCurrent = g_rowCurrent + 1
						c = c - 1
					endwhile
				endif

			when matchPGUP
				c = cRows - 1
				iIndex = g_iCurrent
				while c
					iIndex = FindMatch_Tags(g_stPrompt, iIndex - 1, lookPrev)
					if iIndex == -1
						g_rowCurrent = 1
						g_iTop = g_iCurrent
						break
					endif
					g_iCurrent = iIndex
					c = c - 1
				endwhile
				if not c
					c = cRows - 1
					iIndex = g_iTop
					while c
						iIndex = FindMatch_Tags(g_stPrompt, iIndex - 1, lookPrev)
						if iIndex == -1
							g_rowCurrent = 1
							g_iCurrent = g_iTop
							break
						endif
						g_iTop = iIndex
						c = c - 1
					endwhile
				endif

			when matchPGDN
				c = cRows - 1
				iIndex = g_iBottom
				if g_rowBottom == cRows
					while c
						iIndex = FindMatch_Tags(g_stPrompt, iIndex + 1, lookNext)
						if iIndex == -1
							g_rowCurrent = cRows
							g_iCurrent = g_iBottom
							break
						endif
						g_iBottom = iIndex
						g_iCurrent = FindMatch_Tags(g_stPrompt, g_iCurrent + 1, lookNext)
						g_iTop = FindMatch_Tags(g_stPrompt, g_iTop + 1, lookNext)
						c = c - 1
					endwhile
				else
					g_iCurrent = g_iBottom
					g_rowCurrent = g_rowBottom
				endif
		endcase

		if iTop <> g_iTop or iCurrent <> g_iCurrent
			ListMatches_Tags(0)
		endif
	else
		case Query(Key)
			when <CursorUp>, <GreyCursorUp>
				// can't chain b/c histories are done via CmdMaps
				PushKey(<BOGUS_UP>)
			when <CursorDown>, <GreyCursorDown>
				// can't chain b/c histories are done via CmdMaps
				PushKey(<BOGUS_DOWN>)
			otherwise
				GreyChainCmd()
		endcase
	endif
end


proc Click_Tags()
	integer x, y
	integer iIndex
	integer iNext

	x = Query(MouseX)
	y = Query(MouseY)
	if x > 32767
		x = x - 65536
	endif
	if y > 32767
		y = y - 65536
	endif

	x = x + Query(PopWinX1) - 1
	y = y + Query(PopWinY1) - 1

	if x >= g_x1List and x <= g_x2List and y >= g_y1List and y <= g_y2List
		if g_iCurrent <> -1
			iIndex = -1
			iNext = g_iTop

			do y - g_y1List times
				iIndex = FindMatch_Tags(g_stPrompt, iNext, lookNext)
				iNext = iIndex + 1
			enddo

			if iIndex <> -1
				g_iCurrent = iIndex
				EndProcess(TRUE)
			endif
		endif
	else
		ChainCmd()
	endif
end


string s_stInsert[64] = ""
proc InsertTag()
	if g_iCurrent <> -1
		s_stInsert = Tags_GetSymbol(g_iCurrent)
		EndProcess(TRUE)
	endif
end


#if 0
proc RefreshFileList()
	integer fInPrompt

	if not Get_Int(iProjectId)
		Warn(c_errNoProject)
		return()
	endif

	Set_Int(iFNeedToEnsure, TRUE)

	fInPrompt = (QueryEditState() and g_idPrompt and GetBufferId() == g_idPrompt)
	if fInPrompt
		// avoid resolving whatever user has typed so far
		g_stPrompt = ""

		// force resize of match window
		fDontDelGlobalVar = TRUE
		//ExecHook(_PROMPT_CLEANUP_)
		//ExecHook(_PROMPT_STARTUP_)		// this also calls Setup_Ensure()
		Prompt_Cleanup()
		Prompt_Startup()				// this also calls Setup_Ensure()
	else
		Setup_Ensure()
	endif
end
#endif


#ifdef PROMPT_TAG_MENU
proc DoPromptTagsMenu()
	integer i, j, k, l
	integer fEditState = QueryEditState()
	integer id

	i = Query(PopWinX1)
	j = Query(PopWinY1)
	k = Query(PopWinCols)
	l = Query(PopWinRows)

	Set(X1, WhereXAbs())
	Set(Y1, WhereYAbs()+1)

	g_stPrompt = ""
	Prompt_Cleanup()
	Set_Int(iCPrompts, Get_Int(iCPrompts) + 1)

	if fEditState
		id = PushMessage("")
	endif

	ShowVersion(FALSE)
	Set_Int(iFDoingMenu, TRUE)

	SelectTagFile()

	Set_Int(iFDoingMenu, FALSE)

	if fEditState
		PopMessage(id, not Get_Int(iFTimeoutHooked))
	elseif not Get_Int(iFTimeoutHooked)
		UpdateDisplay(_STATUSLINE_REFRESH_)
	endif

	Window(i, j, i+k-1, j+l-1)

	Set_Int(iCPrompts, Get_Int(iCPrompts) - 1)
	Prompt_Startup()
end
#endif


keydef MatchKeys_Tags
<CursorUp>					NextTag(matchPREV)
<CursorDown>				NextTag(matchNEXT)
<PgUp>						NextTag(matchPGUP)
<PgDn>						NextTag(matchPGDN)
<Ctrl PgUp>					NextTag(matchTOP)
<Ctrl PgDn>					NextTag(matchBOTTOM)
<LeftBtn>					Click_Tags()
<Ctrl Enter>				InsertTag()
<Shift Enter>				InsertTag()
<CtrlShift Enter>			InsertTag()

<BOGUS_UP>					Up()
<BOGUS_DOWN>				Down()
end


#ifdef PROMPT_TAG_MENU
keydef PromptKeys_Tags
<PROJECT_MENU_KEY>			DoPromptTagsMenu()
<TAGS_TagsMenu>				DoPromptTagsMenu()
<F10>						DoPromptTagsMenu()
<0x8000>					DoPromptTagsMenu()

<F11>						DoPromptTagsMenu()
<Shift F11>					DoPromptTagsMenu()
<Ctrl F11>					DoPromptTagsMenu()
<CtrlShift F11>				DoPromptTagsMenu()
<Alt F11>					DoPromptTagsMenu()
<AltShift F11>				DoPromptTagsMenu()
end
#endif


#define MAX_WIDTH_TAGS 64
proc InitMatchWindow_Tags()
	integer i, j, k, l
	integer cx
	integer cy = max(Query(ScreenRows)/2, 12)
	integer attr

	#ifdef DEBUG
	Assert(not g_idPrompt_Save, "window already saved")
	Assert(Tags_FLoaded(), "tags are not loaded")
	Assert(Length(Get_Str(iTagFile)), "Get_Str(iTagFile) has not been ensured (call GetTagFilename())")
	#endif

	// calc width
	cx = Max(16, Tags_CchLongest() + 4)
	//$ todo: tags title
	cx = Max(cx, Length(Get_Str(iTagFile)) + 2)
	cx = Min(cx, MAX_WIDTH_TAGS)

	// calc window location and dimensions
	g_x1List = Query(PopWinX1) + 3
	if g_x1List + cx > Query(ScreenCols)
		g_x1List = Query(ScreenCols) - cx
	endif
shrink_vert:
	g_y1List = Query(PopWinY1) + Query(PopWinRows) + 1
	if g_y1List + cy > Query(ScreenRows) - 1
		if Query(PopWinY1) - (cy + 2) > 2
			g_y1List = Query(PopWinY1) - (cy + 2)
		else
			//$ review: el cheapo iterative shrink instead of the more
			// intellectually challenging absolute shrink.  so i'm lazy.
			cy = cy - 1
			goto shrink_vert
		endif
	endif
	g_x2List = g_x1List + cx - 1
	g_y2List = g_y1List + cy - 1

	g_idPrompt_Save = SaveWindow(g_x1List-1, g_y1List-1, cx+2, cy+2)
	if g_idPrompt_Save
		i = Query(PopWinX1)
		j = Query(PopWinY1)
		k = Query(PopWinCols)
		l = Query(PopWinRows)

		Window(g_x1List-1, g_y1List-1, g_x2List+1, g_y2List+1)
		DrawBox(1, Query(MenuBorderAttr))
		attr = Set(Attr, Query(MenuBorderAttr))
		//$ todo: use friendly name
		PutCtrStr(Ellipsify(Get_Str(iTagFile), cx-2), 1)
		Set(Attr, attr)
		Window(i, j, i+k-1, j+l-1)

		if not fMatchKeys
			fMatchKeys = Enable(MatchKeys_Tags)
			WindowFooter(" {<Enter>}-Lookup selected tag  {<Ctrl-Enter>}-Insert selected tag ")
		endif

		Match_Tags(g_stPrompt)
		ListMatches_Tags(lmINIT)

		g_fNeedToMatchAfterCommand = FALSE
		Hook(_AFTER_NONEDIT_COMMAND_, Prompt_AfterCommand_Tags)
	else
		g_x1List = 0
		g_y1List = 0
		g_x2List = 0
		g_y2List = 0
		Warn("Unable to save area under window.")
	endif
end


proc Prompt_DelayedMatch_Tags()
	string st[MAXPATH]

	g_fNeedToMatchAfterCommand = FALSE
	UnHook(Prompt_DelayedMatch_Tags)
	if g_idPrompt == GetBufferId()
		st = GetText(1, MAXPATH)
		if g_stPrompt <> st
			Match_Tags(st)
			ListMatches_Tags(0)
		endif
	endif
end


proc Prompt_AfterCommand_Tags()
	Hook(_NONEDIT_IDLE_, Prompt_DelayedMatch_Tags)
	g_fNeedToMatchAfterCommand = TRUE
end


#if 0
proc Prompt_Cleanup_Tags()
	Set_Int(iCPrompts, Get_Int(iCPrompts) - 1)
	if not Get_Int(iCPrompts)
		if fPromptHooked
			if fMatchKeys
				fMatchKeys = FALSE
				Disable(MatchKeys_Tags)
			endif

			UnHook(Prompt_AfterCommand_Tags)
			UnHook(Prompt_DelayedMatch_Tags)
			fPromptHooked = FALSE

			if g_fNeedToMatchAfterCommand
				g_fNeedToMatchAfterCommand = FALSE
				Prompt_DelayedMatch_Tags()
			endif

			RestoreWindow(g_idPrompt_Save)
			g_idPrompt = 0

			g_x1List = 0
			g_y1List = 0
			g_x2List = 0
			g_y2List = 0

			// g_iCurrent is the index of the selected symbol
		endif
	endif
end
#endif


#if 0
proc Prompt_Startup_Tags()
	if not Get_Int(iCPrompts)
		fPromptHooked = Tags_FLoaded() and Query(PromptString) == c_stPromptFindTag
		if fPromptHooked
			g_idPrompt = GetBufferId()
			g_stPrompt = GetText(1, MAXPATH)

			InitMatchWindow_Tags()
		endif
	endif

	Set_Int(iCPrompts, Get_Int(iCPrompts) + 1)
end
#endif


string proc GetWordAtCursor()
	string st[255] = ""
	string ws[32]

	// get tag at cursor
	if isCursorInBlock() and (isCursorInBlock() <> _LINE_)
		st = GetMarkedText()
	else
		ws = Set(WordSet, ChrSet("A-Za-z_~0-9"))
		st = GetWord(TRUE)
		Set(WordSet, ws)
	endif

	return(st)
end


#ifdef BSCTAGS
string proc mGetName(integer i)
	integer typ, atr
	return (GetName(i, typ, atr))
end


integer proc SelectBase(string title, integer idTmp, integer bscSelectType)
	integer cid = GetBufferId()
	integer id = 0
	integer ii = 0
	integer y

	GotoBufferId(idTmp)
	BegFile()

	y = Query(ScreenRows) - 2

	g_bscSelectType = bscSelectType
	g_nRowOfs = 0
	g_nRowOfsFresh = 0
	cyCtxWin = 0
	if bscSelectType in BSC_DEF, BSC_REF
		cyCtxWin = Query(ScreenRows)*pctCtxWin/100

		Hook(_LIST_STARTUP_, ListStartup_BSC)
		Hook(_LIST_CLEANUP_, ListCleanup_BSC)
	endif

	Set(Key, -1)

	y = y - cyCtxWin
	case lList(title, min(LongestLineInBuffer(), Query(ScreenCols)-10), y,
			   _ENABLE_SEARCH_|_FIXED_HEIGHT_)
		when 1
			// selected one
			ii = CurrLine()
		when 2
			// all
			ii = -1
		when 3
			// copy list
			PushPosition()
			PushBlock()
			MarkLine(1, NumLines())
			case bscSelectType
				when BSC_DEF
					id = CreateBuffer("Definitions of "+title, _NORMAL_)
				when BSC_REF
					id = CreateBuffer("References of "+title, _NORMAL_)
			endcase
			if id
				cid = id
				if isBlockMarked()
					CopyBlock()
				endif
			else
				TimeOutMessage(ERROR_TIMEOUT, "Unable to create buffer.")
			endif
			GotoBufferId(idTmp)
			PopBlock()
			PopPosition()
	endcase

	Unhook(ListCleanup_BSC)
	Unhook(ListStartup_BSC)

	GotoBufferId(cid)
	AbandonFile(idTmp)

	return (ii)
end


integer proc mSetCurrentSymbol(var string st)
/*
	integer n
*/

	if st == ""
/*
		PushKey(<CursorRight>)
		#ifdef TSE30
		n = MsgBoxEx(c_stTitle,
					 "Are you sure you want to browse the entire symbol " +
					 "namespace?  Depending on the size of your .BSC file, " +
					 "it could take several minutes to build the list.  " +
					 "(Note, the list will be unsorted)",
					 "[ Yes, &All Symbols ];[ &Cancel ]")
		#else
		n = MsgBox(c_stTitle,
				   "Are you sure you want to browse the entire symbol " +
				   "namespace?  Depending on the size of your .BSC file, " +
				   "it could take several minutes to build the list.  " +
				   "(Note, the list will be unsorted)", _YES_NO_)
		#endif
		if n <> 1
*/
			if not Ask("Find references:", st) or st == ""
				return (-1)
			endif
/*
		endif
*/
	endif
	return (SetCurrentSymbol(st))
end


constant LIST_MEMBERS	= 0
constant LIST_USES		= 1
constant LIST_USEDBY	= 2
constant LIST_BASES		= 3
constant LIST_DERVS		= 4
integer proc ListInfo(string title, integer infotype, integer c)
	integer idTmp
	integer ii = 0
	integer iGen
	integer typ, atr
	string st[255]
	string stAttr[255]

	idTmp = mCreateTempBuffer()
	if idTmp
		for ii = 1 to c
			case infotype
				when LIST_MEMBERS
					iGen = GetMember(ii)
				when LIST_USES
					iGen = GetUse(ii)
				when LIST_USEDBY
					iGen = GetUby(ii)
				when LIST_BASES
					iGen = GetBase(ii)
				when LIST_DERVS
					iGen = GetDerv(ii)
			endcase
			st = GetName(iGen, typ, atr)
			stAttr = GetAttr(atr)
			AddLine(Format(st; "(", GetType(typ), iif(Length(stAttr), " ", ""), stAttr, ")"), idTmp)
		endfor
		ii = SelectBase(title, idTmp, BSC_INFO)
	endif
	return (ii)
end


integer proc SelectInst(string title, integer cInst)
	integer idTmp
	integer ii = 0
	integer typ, atr
	string st[255]

	idTmp = mCreateTempBuffer()
	if idTmp
		for ii = 1 to cInst
			st = GetName(GetSymbol(ii), typ, atr)
			AddLine(Format(GetType(typ):-12; st), idTmp)
		endfor
		ii = SelectBase(title, idTmp, BSC_INST)
	endif
	return (ii)
end


integer proc SelectDef(string title, integer c)
	integer idTmp
	integer ii = 0
	string st[255]
	integer ln

	idTmp = mCreateTempBuffer()
	if idTmp
		for ii = 1 to c
			st = GetDef(ii, ln)
			AddLine(Format(st; "(", ln, ")"), idTmp)
		endfor
		ii = SelectBase(title, idTmp, BSC_DEF)
	endif
	return (ii)
end


integer proc SelectRef(string title, integer c)
	integer idTmp
	integer ii = 0
	string st[255]
	integer ln

	idTmp = mCreateTempBuffer()
	if idTmp
		for ii = 1 to c
			st = GetRef(ii, ln)
			AddLine(Format(st; "(", ln, ")"), idTmp)
		endfor
		ii = SelectBase(title, idTmp, BSC_REF)
	endif
	return (ii)
end


constant BSC_SEARCH_SLOP = 250
integer proc LoadFileAndGoto(string _fn, integer ln, string st)
	string ws[32] = Query(WordSet)
	integer cf
	string fn[MAXPATH] = _fn
	integer fFound = FALSE
	integer fIgnore = FALSE
	integer fTwoWindows = FALSE

	if GetFilePathPrompt(fn)
		if Query(Key) == <Ctrl Enter>
			//$ HACK: ouch, but it's so centralized i couldn't resist
			fTwoWindows = TRUE
			OneWindow()
			HWindow()
			cyCtxWin = iif(cyCtxWin, cyCtxWin, Query(ScreenRows)*pctCtxWin/100)
			ResizeWindow(_UP_, cyCtxWin - Query(WindowRows) -
						 iif(Query(ShowHelpLine), 3, 2))
		endif

		if not EditFile(QuotePath(fn))
			Warn("Can't load"; fn)
			goto Error
		endif
		if NumLines() == 0
			AbandonFile()
			Warn("File"; fn; "not found!")
			goto Error
		endif

		// goto line
		GotoLine(ln)

		// search for nearest match
		if Pos("~", st)
			Set(WordSet, ChrSet("A-Za-z_~0-9"))
		else
			Set(WordSet, ChrSet("A-Za-z_0-9"))
		endif
		if GetText(PosFirstNonWhite(), 1) <> "{"
			PushBlock()
			MarkLine(CurrLine(), CurrLine() + BSC_SEARCH_SLOP)
			BegLine()
			fFound = TRUE
			if not lFind(st, "wl")
				ln = CurrLine() - BSC_SEARCH_SLOP
				if ln < 1
					ln = 1
				endif
				MarkLine(ln, CurrLine())
				EndLine()
				Right()
				if not lFind(st, "wlb")
					fIgnore = TRUE
					MarkLine(CurrLine(), CurrLine() + BSC_SEARCH_SLOP)
					BegLine()
					if not lFind(st, "wli")
						MarkLine(ln, CurrLine())
						EndLine()
						Right()
						if not lFind(st, "wlbi")
							BegLine()
							fFound = FALSE
						endif
					endif
				endif
			endif
			PopBlock()
		else
			PushPosition()
			while Up() and PosFirstNonWhite() <> 1
			endwhile
			if PosFirstNonWhite() == 1
				fFound = TRUE
				EndLine()
				if not lFind(st, "wcb")
					fIgnore = TRUE
					if not lFind(st, "wcbi")
						fFound = FALSE
					endif
				endif
			endif
			if fFound
				KillPosition()
			else
				PopPosition()
			endif
		endif

		// scroll nicely
		ScrollToRow(Query(WindowRows)/3)
		UpdateDisplay(_STATUSLINE_REFRESH_)
		cf = Set(CenterFinds, OFF)
		if not fFound
			BufferVideo()
			PushPosition()
		endif
		Find(st, iif(fIgnore, "wi", "w"))
		if not fFound
			PopPosition()
			UnBufferVideo()
		endif
		Set(CenterFinds, cf)

		Set(WordSet, ws)
		return (TRUE)
	endif

Error:
	if fTwoWindows
		OneWindow()
	endif
	return (FALSE)
end


integer proc BscInfo(string stTag, integer infotype)
	integer nRet = FALSE
	integer cInst
	integer c
	string stBscFile[MAXPATH] = Get_Str(iBscFile)
	string st[80] = stTag
	string title[255] = ""
	string none[255] = ""

	ExpandEnvVars(stBscFile)
	if not OpenBrowseFile(stBscFile)
		nRet = -1
		goto Error
	endif

	cInst = mSetCurrentSymbol(st)
	if cInst > 1
		cInst = SelectInst(st, cInst)
	elseif cInst == 0
		Message("Unable to find symbol '", st, "'.")
	endif
	if cInst > 0
		case infotype
			when LIST_MEMBERS
				c = GetMembers(cInst, mbfAll)
				title = "Members of "+st
				none = "'"+st+" has no members."
			when LIST_USES
				c = GetUses(cInst, mbfAll)
				title = st+" uses"
				none = "'"+st+"' does not use any symbols."
			when LIST_USEDBY
				c = GetUbys(cInst, mbfAll)
				title = "Used by "+st
				none = "'"+st+"' is not used."
			when LIST_BASES
				c = GetBases(cInst)
				title = "Bases of "+st
				none = "'"+st+"' has no bases."
			when LIST_DERVS
				c = GetDervs(cInst)
				title = "Derived from "+st
				none = "Nothing derives from '"+st+"'."
		endcase
		if c > 0
			c = ListInfo(title, infotype, c)
		elseif c == 0
			Message(none)
		endif
	endif

Error:
	CloseBrowseFile()
	return (nRet)
end


// BscGotoRef()
// goto references of specified tag; prompt if not specified
integer proc BscGotoRef(string stTag)
	integer nRet = FALSE
	integer cInst
	integer cRef
	integer ii = 0
	string stBscFile[MAXPATH] = Get_Str(iBscFile)
	string st[80] = stTag
	integer ln

	ExpandEnvVars(stBscFile)
	if not OpenBrowseFile(stBscFile)
		nRet = -1
		goto Error
	endif

	cInst = mSetCurrentSymbol(st)
	if cInst > 1
		cInst = SelectInst(st, cInst)
	elseif cInst == 0
		Message("Unable to find symbol '", st, "'.")
	endif
	if cInst > 0
		cRef = GetReferences(cInst)
		if cRef >= 1
			if cRef == 1
				ii = 1
			else
				ii = SelectRef(mGetName(GetSymbol(cInst)), cRef)
			endif
		elseif cRef == 0
			Message("No references.")
		endif
		if ii > 0
			stBscFile = GetRef(ii, ln)
			nRet = LoadFileAndGoto(stBscFile, ln, st)
		elseif ii < 0
			for ii = cRef downto 1
				stBscFile = GetRef(ii, ln)
				nRet = LoadFileAndGoto(stBscFile, ln, st)
			endfor
		endif
	endif

Error:
	CloseBrowseFile()
	return (nRet)
end


menu ClassOrConst()
"Co&nstructor"
"C&lass"
"&Cancel"
end


// BscGotoTag()
// goto specified tag; prompt if not specified
integer proc BscGotoTag(string stTag)
	integer nRet = FALSE
	integer cSym
	integer cInst
	integer cDef
	integer ii = 0
	string stBscFile[MAXPATH] = Get_Str(iBscFile)
	string st[80] = stTag
	integer ln
	integer fAlt = FALSE

	ExpandEnvVars(stBscFile)
	if not OpenBrowseFile(stBscFile)
		nRet = -1
		goto Error
	endif

	cSym = mSetCurrentSymbol(st)
	if cSym > 1
		cInst = SelectInst(st, cSym)
	elseif cSym == 0
		Message("Unable to find symbol '", st, "'.")
	else
		cInst = cSym
	endif
	if cSym > 0 and cInst > 0
		cDef = GetDefinitions(cInst)
		if cDef >= 1
			if cDef == 1
				ii = 1
				cSym = SetCurrentSymbol(st + "::" + st)
				if cSym == 1
					case ClassOrConst(st)
						when 1
							// constructor, we're the 'alternate'
							fAlt = TRUE
							cDef = GetDefinitions(cSym)
							if cDef == 1
								ii = 1
							else
								ii = SelectDef(mGetName(GetSymbol(cSym)), cDef)
							endif
						when 2
							// class, so not 'alternate'
						otherwise		// cancel
							ii = 0
					endcase
				else
					// not 'alternate'
				endif
				if not fAlt
					cSym = SetCurrentSymbol(st)
					cDef = GetDefinitions(cInst)
				endif
			else
				ii = SelectDef(mGetName(GetSymbol(cInst)), cDef)
			endif
		elseif cDef == 0
			Message("No definitions.")
		endif
		if ii > 0
			stBscFile = GetDef(ii, ln)
			nRet = LoadFileAndGoto(stBscFile, ln, st)
		elseif ii < 0
			for ii = cDef downto 1
				stBscFile = GetDef(ii, ln)
				nRet = LoadFileAndGoto(stBscFile, ln, st)
			endfor
		endif
	endif

Error:
	CloseBrowseFile()
	return (nRet)
end
#endif


#ifdef CTAGS
// TagsGotoTag()
// goto specified tag; prompt if not specified
integer proc TagsGotoTag(string st)
	string stTag[255]
	string fn[_MAXPATH_]
	integer nLine
	string stTarget[255]
	integer fAsked = TRUE
	integer f
	integer iIndex = -1
	string stTitle[255]

	// make sure tags file is loaded
	stTitle = Get_Str(iProjectTitle)
	if stTitle == ""
		stTitle = SqueezePath(SplitPath(GetTagFilename(), _DRIVE_|_PATH_), 48)
	endif
	if not LoadTags(stTitle, GetTagFilename(), FALSE)
		return (FALSE)
	endif

	if st <> ""
		fAsked = FALSE
		stTag = Trim(st)
	else
		s_stInsert = ""

		stTag = GetWordAtCursor()
		f = Ask(c_stFindTag, stTag, g_hist)
		if not f
			return (FALSE)
		endif

		if Length(s_stInsert)
			PushBlock()
			PushPosition()
			if not MarkWord()
				Left()
				if not MarkWord()
					PopPosition()
					PushPosition()
				endif
			endif
			KillPosition()
			if isCursorInBlock()
				KillBlock()
			endif
			InsertText(s_stInsert, _INSERT_)
			PopBlock()
			return (FALSE)
		endif

		iIndex = g_iCurrent
	endif

	if not fAsked
		if stTag <> ""
			// find tag in tags file
			Message("Searching...")
			iIndex = Tags_Lookup(stTag, 0, lookFirst|lookExact)
			UpdateDisplay(_STATUSLINE_REFRESH_)
			if iIndex == -1
				Message("Unable to find tag '", stTag, "'.")
				return (FALSE)
			endif

			// check for multiple matches, show menu of matching tags
			iIndex = MatchMenu(stTag, iIndex)
		endif
	endif

	if iIndex == -1
		return (FALSE)
	endif

	// get filename and target
	fn = Tags_GetFilename(iIndex)
	nLine = Tags_GetLine(iIndex)
	stTarget = Tags_GetSearchLine(iIndex)
	if not Pos(":", fn) and SubStr(fn, 1, 2) <> "\\"
		fn = AddTrailingSlash(SplitPath(GetTagFilename(), _DRIVE_|_PATH_))+fn
	endif

	// load file
	if not EditFile(QuotePath(fn))
		Warn("Can't load"; fn)
		return (FALSE)
	endif

	if NumLines() == 0
		AbandonFile()
		Warn("File"; fn; "not found!")
		return (FALSE)
	endif

	// find target
	if nLine or lFind(stTarget, iif(Tags_FAnchorToEnd(iIndex), "g^$", "g^"))
		if nLine
			GotoLine(nLine)
		endif
		if lFind(stTag, "c")
			AddHistoryStr(stTag, g_hist)
		endif
		ScrollToRow(Query(WindowRows)/3)
		UpdateDisplay(_STATUSLINE_REFRESH_)
		return (TRUE)
	endif

	Warn("Target not found:"; stTarget)

	return (FALSE)
end
#endif


#ifdef BOTHTAGS
integer proc GotoTag(string st)
	integer ret = -1

	if Length(Get_Str(iBscFile)) and Length(st)
		ret = BscGotoTag(st)
	endif
	if ret < 0
		ret = TagsGotoTag(st)
	endif
	return (ret)
end
#else
	#ifdef CTAGS
	integer proc GotoTag(string st)
		return (TagsGotoTag(st))
	end
	#else
	integer proc GotoTag(string st)
		return (BscGotoTag(st) > 0)
	end
	#endif
#endif


integer proc GotoTagAtCursor()
	return (GotoTag(GetWordAtCursor()))
end


proc GotoTagInWindow()
	integer cRows

	OneWindow()
	cRows = Query(WindowRows)
	PushPosition()
	PushPosition()
	HWindow()
	ResizeWindow(_UP_, cRows/3 - 2 - Query(WindowRows))
	PopPosition()
	if not GotoTagAtCursor()
		CloseWindow()
	endif
	GotoWindow(1)
	PopPosition()
end


#ifdef CTAGS
proc GenerateTags()
	string stDir[_MAXPATH_] = CurrDir()
	string stFile[_MAXPATH_]
	integer cid = GetBufferId()
	integer id = 0
	integer ml
	string stCmd[MAXSTR]
#ifdef CTAGS_ENABLE_IGNORE
	integer idIgnore = 0
	string stIgnore[_MAXPATH_] = ""
#endif

	if Get_Int(iFProjectTags)
		#ifdef DEBUG
		Assert(Get_Int(iProjectId), "Get_Int(iFProjectTags) should imply Get_Int(iProjectId)")
		#endif
		if not Get_Int(iFListEnsured)
			Setup_Ensure()
			Warn(c_errNotEnsured)
			return()
		endif
	endif

	stCmd = LoadDir()+"ctags.exe --excmd=p"

#ifdef CTAGS_ENABLE_IGNORE
	idIgnore = CreateTempBuffer()
	if idIgnore
		PushBlock()
//$ todo: way to customize what to ignore?
		InsertData(dataIgnore)
		PopBlock()

		// if there's anything to ignore, write it out to a file
		if NumLines()
			stIgnore = GetTempFile()
			if not Length(stIgnore) or not SaveAs(stIgnore, _DONT_PROMPT_)
				stIgnore = ""
				GotoBufferId(cid)
				goto Out
			endif
			//stCmd = stCmd + " -I " + QuotePath(".\" + SplitPath(stIgnore, _NAME_|_EXT_))
			stCmd = stCmd + " -I " + QuotePath(stIgnore)
		else
			GotoBufferId(cid)		// go to a different buffer so AbandonFile doesn't generate an _ON_CHANGING_FILES_ event
			AbandonFile(idIgnore)
			idIgnore = 0
		endif

		// go back to original buffer
		GotoBufferId(cid)
	endif
#endif

	if Get_Int(iFProjectTags)
		// a project is open, do tags for whole project
		Message('Generating tags file for '+Get_Str(iProjectTitle)+'...')

		// make list of files for ctags to process
		id = CreateTempBuffer()
		if id
			ml = Set(MsgLevel, _NONE_)
			PushBlock()

			// copy file list
			InsertFileList(FALSE)

			// preprocess file list
			#ifdef DEBUG
			BegFile()
			do NumLines() times
				Assert(CurrLineLen(), "should be no blank lines!")
				Down()
			enddo
			#endif
			//$ review: can these operations be optimized?
			lReplace(Format("^{.*}\x", Asc(c_stDiv):2:"0":16, "{.*}$"), "\2\1", "gxn")
			BegFile()
			do NumLines() times
				stFile = SplitPath(GetText(1, 255), _EXT_)+"."
				if Length(stFile) == 1
					#ifdef DEBUG
					Assert(stFile == ".", 'stFile == "."')
					#endif
					stFile = ".."
				endif
				if not Pos(stFile, c_stTagExts)
					KillLine()
				else
					Down()
				endif
			enddo

			PopBlock()
			Set(MsgLevel, ml)

			#ifdef DEBUG_CTAGS
			if List("Files for CTags:", 80)
				// in DEBUG mode, let user review list of files we're giving
				// to ctags; if user hits <Escape>, we abort.
			#endif

			// save list to temp file
			stFile = GetTempFile()
			if SaveAs(stFile, _DONT_PROMPT_)
//				if CDD(SplitPath(stIgnore, _DRIVE_|_PATH_))
					// sometimes CTags thinks it can't overwrite the tags file
					// even though it really can, so we'll delete it ourselves
					// to avoid confusion.
					GotoBufferId(cid)		// make GetTagFilename() happy
					EraseDiskFile(GetTagFilename())

					//$ review: hm, not sure what a good way to check for errors is, if it
					// is even possible without taking a performance hit.
					Dos(stCmd + " -L " + QuotePath(stFile) +
								" -f " + QuotePath(GetTagFilename()),
							_RETURN_CODE_|_DONT_PROMPT_|_DONT_CLEAR_|GrfHiddenConsole())

					CDD(stDir)
//				else
//					Warn(c_errChangeDirs)
//				endif

				#ifndef DEBUG_CTAGS
				EraseDiskFile(stFile)
				#endif
			else
				Warn("Unable to write temporary file list")
			endif

			#ifdef DEBUG_CTAGS
			endif
			#endif

			GotoBufferId(cid)
			AbandonFile(id)
		else
			Warn(c_errTmpBuf)
		endif
	else
		// go to current file's directory
		if CDD(SplitPath(CurrFilename(), _DRIVE_|_PATH_))
			// no project open, just do tags for current directory
			Message('Generating tags file for '+SqueezePath(CurrDir(), Query(ScreenCols)-28)+'...')

			//$ review: hm, not sure what a good way to check for errors is, if it
			// is even possible without taking a performance hit.
			Dos(stCmd + " *.c *.h *.cc *.cpp *.hpp *.cxx *.hxx",
					_RETURN_CODE_|_DONT_PROMPT_|_DONT_CLEAR_|GrfHiddenConsole())

			CDD(stDir)
		else
			Warn(c_errChangeDirs)
			goto Out
		endif
	endif

	// force reload on demand
	Tags_FreeFile(GetTagFilename())

Out:
	UpdateDisplay(_STATUSLINE_REFRESH_)

#ifdef CTAGS_ENABLE_IGNORE
	if idIgnore
		AbandonFile(idIgnore)
		#ifndef DEBUG_CTAGS
		EraseDiskFile(stIgnore)
		#endif
	else
		Warn(c_errTmpBuf)
	endif
#endif
end
#endif


#ifdef BSCTAGS
forward menu BSCTagMenu()
#endif


#ifdef CTAGS
menu ECTagMenu()
title = "Tags"
history
"&Goto tag at cursor", GotoTagAtCursor(), mfNotPrompt(mfOpen(_MF_CLOSE_ALL_BEFORE_)), "Goto tag under cursor."
"Goto &tag", GotoTag(""), mfNotPrompt(mfOpen(_MF_CLOSE_ALL_BEFORE_)), "Goto specified tag."
"&Display tag in separate window", GotoTagInWindow(), mfNotPrompt(mfOpen(_MF_CLOSE_ALL_BEFORE_)), "Display tag under cursor in a separate window."
"",, Divide
"&Purge all tags files from memory", Tags_FreeAll(), CloseAllBefore
"Ge&nerate tags file", GenerateTags(), mfOpen(_MF_CLOSE_ALL_BEFORE_)
"",, Divide
"&Ignore Case" [OnOffStr(Get_Int(iFIgnoreCase)):3], Toggle_Int(iFIgnoreCase), mfOpen(_MF_CLOSE_ALL_BEFORE_)
#ifdef BSCTAGS
"",, Divide
"BSC Menu  ", BSCTagMenu(), iif(Length(Get_Str(iBscFile)), _MF_CLOSE_BEFORE_, _MF_GRAYED_)
#endif
end
#endif


#ifdef BSCTAGS
menu BSCTagMenu()
title = "Symbol Info (BSC)"
history
"Look up",, Divide
//"Go to &Definition", GotoTagAtCursor(), CloseAllBefore, "Goto tag under cursor."
"Look up &Definition", GotoTagAtCursor(), mfNotPrompt(mfOpen(_MF_CLOSE_ALL_BEFORE_)), "Goto definition of symbol under cursor."
"  in separate &window", GotoTagInWindow(), mfNotPrompt(mfOpen(_MF_CLOSE_ALL_BEFORE_)), "Display definition of symbol under cursor in a separate window."
"Look up &References", BscGotoRef(GetWordAtCursor()), mfNotPrompt(mfOpen(_MF_CLOSE_ALL_BEFORE_)), "Goto references of symbol under cursor."
"Info",, Divide
"&Uses...", BscInfo(GetWordAtCursor(), LIST_USES), mfNotPrompt(mfOpen(_MF_CLOSE_ALL_BEFORE_)), "List all symbols used by symbol under cursor."
"Used &by...", BscInfo(GetWordAtCursor(), LIST_USEDBY), mfNotPrompt(mfOpen(_MF_CLOSE_ALL_BEFORE_)), "List all functions that use symbol under cursor."
"Bases...", BscInfo(GetWordAtCursor(), LIST_BASES), mfNotPrompt(mfOpen(_MF_CLOSE_ALL_BEFORE_)), "List all base classes/structs from which symbol under cursor inherits."
"Derivations...", BscInfo(GetWordAtCursor(), LIST_DERVS), mfNotPrompt(mfOpen(_MF_CLOSE_ALL_BEFORE_)), "List all classes/structs that derive from symbol under cursor."
"Members...", BscInfo(GetWordAtCursor(), LIST_MEMBERS), mfNotPrompt(mfOpen(_MF_CLOSE_ALL_BEFORE_)), "List all members of symbol under cursor."
#ifdef CTAGS
"",, Divide
"Tags Menu  ", ECTagMenu(), CloseBefore
#endif
end
#endif


#ifdef BOTHTAGS
proc TagMenu()
	integer fIgnore

	if Length(Get_Str(iBscFile))
		BSCTagMenu()
	else
		fIgnore = Get_Int(iFIgnoreCase)
		ECTagMenu()
		if fIgnore <> Get_Int(iFIgnoreCase)
			FreeAllTags()
		endif
	endif
end
#else
	#ifdef CTAGS
	proc TagMenu()
		integer fIgnore

		fIgnore = Get_Int(iFIgnoreCase)
		ECTagMenu()
		if fIgnore <> Get_Int(iFIgnoreCase)
			FreeAllTags()
		endif
	end
	#else
		#ifdef BSCTAGS
		proc TagMenu()
			BSCTagMenu()
		end
		#else
		error: "not possible to get here"
		#endif
	#endif
#endif



///////////////////////////////////////////////////////////////////////////
// Keys

<TAGS_GotoTagAtCursor>			GotoTagAtCursor()
<TAGS_GotoTagIn2ndWindow>		GotoTagInWindow()
<TAGS_GotoTag>					GotoTag("")
<TAGS_TagsMenu>					TagMenu()

